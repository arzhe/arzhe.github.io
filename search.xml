<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>为“异常安全”而努力是值得的</title>
    <url>/2020/08/11/%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84/</url>
    <content><![CDATA[<hr>
<h1 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h1><p>&emsp;&emsp;异常安全有几分像是……呃……怀孕。但等等，在我们完成求偶之前，实在无法确实地谈论生育。</p>
<p>&emsp;&emsp;假设有个class用来表现夹带背景图案的GUI菜单。这个class希望用语多线程环境，所以它有个互斥器作为并发控制之用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span>;  <span class="comment">//改变背景图像</span></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;       <span class="comment">//互斥器</span></span><br><span class="line">    Image* bgImage;    <span class="comment">//目前的背景图像</span></span><br><span class="line">    <span class="keyword">int</span> imageChanges;  <span class="comment">//背景图像被改变的次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是PrettyMenu的changeBackground函数的一个可能实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    lock(&amp;mutex);                 <span class="comment">//取得互斥器</span></span><br><span class="line">    <span class="keyword">delete</span> bgImage;               <span class="comment">//摆脱旧的背景图像</span></span><br><span class="line">    ++imageChanges;               <span class="comment">//修改图像变更次数</span></span><br><span class="line">    bgImage = <span class="keyword">new</span> Image(imgSrc);  <span class="comment">//安装新的背景图像</span></span><br><span class="line">    unlock(&amp;mutex);               <span class="comment">//释放互斥器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从“异常安全性”的观点来看，这个函数很糟。“异常安全”有两个条件，而这个函数没有满足其中任何一个条件。</p>
<p>&emsp;&emsp;当异常被抛出时，带有异常安全性的函数会：</p>
<ul>
<li><strong>不泄漏任何资源</strong>。上述代码没有做到这一点，因为一旦“new Image(imgSrc)”导致异常，对unlock的调用就绝不会执行。于是互斥器就永远被把持住了。</li>
<li><strong>不允许数据破坏</strong>。如果“new Image(imgSrc)”抛出异常，bgImage就是指向一个已被删除的对象，imageChanges也已被累加，而其实并没有新的图像被成功安装起来。</li>
</ul>
<p>&emsp;&emsp;解决资源泄漏的问题很容易，因为之前的“<a href="/2020/07/27/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/" title="以对象管理资源">以对象管理资源</a>”讨论过如何以对象管理资源，而在“<a href="/2020/07/28/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA/" title="在资源管理类中小心copying行为">在资源管理类中小心copying行为</a>”也导入了Lock class作为一种“确保互斥器被及时释放”的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> Image(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于“管理资源类”如Lock者，一个最棒的事情是，它们通常使函数更短。你看，不再需要调用unlock了不是吗？有个一般性规则是这么说的：较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也比较少。</p>
<p>&emsp;&emsp;把资源泄漏抛诸脑后，现在我们可以专注解决数据的的败坏了。此刻我们需要做个抉择，但是在我们能够抉择之前，必须先面对一些用来定义选项的术语。</p>
<ul>
<li><p><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而破坏，所有对象都处于一种内部前后一致的状态（例如所有的class约束条件都继续获得满足）。然而程序的现实状态恐怕不可预测。举个例子，我们可以撰写changeBackground使得一旦有异常被抛出时，PrettyMenu对象可以继续拥有原背景图像，或是令它拥有某个缺省背景图像，但客户无法预期哪一种情况。如果想知道，他们恐怕必须调用某个成员函数以得知当时的背景图像是什么。</p>
</li>
<li><p><strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。</p>
<p>&emsp;&emsp;和这种提供强烈保证的函数共事，比如刚才说的那种只提供基本承诺的函数共事，容易多了，因为在调用一个提供强烈保证的函数后，程序状态只有两种可能：如预期般地到达函数成功执行后的状态，或回到函数被调用前的状态。与此成对比的是，如果调用一个只提供基本承诺的函数，而真的出现异常，程序有可能处于任何状态——只要那是个合法状态。</p>
</li>
<li><p><strong>不抛掷保证</strong>，承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于内置类型身上的所有操作都提供nothrow保证。这是异常安全码中一个必不可少的关键基础材料。</p>
<p>&emsp;&emsp;如果我们假设，函数带着“空白的异常明细”者必为nothrow函数，似乎合情合理，其实不尽然。举个例子，考虑以下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//空白的异常明细</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这并不是说doSomething绝不会抛出异常，而是说如果doSomething抛出异常，将是严重错误，会有你意想不到的函数被调用。实际上实际上doSomething也许完全没有提供任何异常保证。函数的声明式并不能够告诉你是否它是正确的、可移植的或高效的，也不能够告诉它是否提供任何异常安全性保证。所有那些性质都由函数的实现决定，无关乎声明。</p>
</li>
</ul>
<p>&emsp;&emsp;异常安全码必须提供上述三种保证之一。如果它不这样做，它就不具备异常安全性。因此，我们的抉择是，该为我们所写的每一个函数提供哪一种保证？除非面对不具异常安全性的传统代码，否则你应该只在一种情况下才不提供任何异常安全保证：你那“天才班”需求分析团队确认你的应用程序有“泄漏资源”并“在执行过程中带着败坏数据”的需要。</p>
<p>&emsp;&emsp;一般而言你应该会想提供可实施之最强烈保证。从异常安全性的观点视之，nothrow函数很棒，但我们很难在C part of  C++领域中完全没有调用任何一个可能抛出异常的函数。任何使用动态内存的东西如果无法找到足够内存以满足需求，通常便会抛出一个bad_alloc异常。是的，可能的话请提供nothrow保证，但对大部分函数而言，抉择往往落在基本保证和强烈保证之间。</p>
<p>&emsp;&emsp;对changeBackground而言，提供强烈保证几乎不困难。首先改变PrettyMenu的bgImage成员变量的类型，从一个类型为Image*的内置指针改为一个“用于资源管理”的智能指针。坦白说，这个好构想纯粹只是帮助我们防止资源泄漏。它对“强烈之异常安全保证”的帮助仅仅只是强化了“<a href="/2020/07/27/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/" title="以对象管理资源">以对象管理资源</a>”的论点：以对象（例如智能指针）管理资源是良好设计的根本。以下代码中我使用shared_ptr。</p>
<p>&emsp;&emsp;第二，我们重新排列changeBackground内的语句次序，使得在更换图像之后才累加imageChanges，一般而言这是个好策略：不要为了表示某件事情发生而改变对象状态，除非那件事情真的发生了。</p>
<p>&emsp;&emsp;下面是结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.reset(<span class="keyword">new</span> Image(imgSrc));  <span class="comment">//以“new Image”的执行结果设定bgImage内部指针</span></span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意，这里不再需要手动delete旧图像，因为这个动作已经由智能指针内部处理掉了。此外，删除动作只发生在新图像被成功创建之后。更正确地说，shared_ptr::reset函数只有在其参数被成功生成之后才会被调用。delete只在reset函数内被使用，所以如果从未进入那个函数也就绝对不会使用delete。也请注意，以对象管理资源再次缩减了changeBackground的长度。</p>
<p>&emsp;&emsp;如我之前所言，这两个改变几乎足够让changeBackground提供强烈的异常安全保证。美中不足的是参数imgSrc。如果Image构造函数抛出异常，有可能输入流的读取记号已被移走，而这样的搬移对程序其余部分是一种可见的状态改变。所以changeBackground在解决这个问题之前只提供基本的异常安全保证。</p>
<p>&emsp;&emsp;然而，让我们把它放在一旁，佯装changeBackground的确提供了强烈保证。有个一般化的设计策略很典型地回导致强烈保证，很值得熟悉它。这个策略被称为copy and swap。原则很简单：为你打算修改的对象（原件）做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍然保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换。</p>
<p>&emsp;&emsp;实现上通常是将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的实现对象（即副本）。这种手法常被称为pimpl idiom。对PrettyMenu而言，典型写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChange;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;  <span class="comment">//获得mutex的副本数据</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">  </span><br><span class="line">    pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc));  <span class="comment">//修改副本</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    </span><br><span class="line">    swap(pImpl, pNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此例之中我选择让PMImpl成为一个struct而不是一个class，这是因为PrettyMenu的数据封装性已经由于“pImpl是private”而获得了保证。如果令PMImpl为一个class，虽然一样好，有时候却不太方便（但也保持了面向对象纯度）。如果你要，也可以将PMImpl嵌套于PrettyMenu内，但打包问题（例如“独立撰写异常安全码”）是我们这里所挂虑的事。</p>
<p>&emsp;&emsp;“copy-and-swap”策略是对对象状态做出“全有或全无”改变的一个很好办法，但一般而言它并不保证整个函数有强烈的异常安全性。为了解原因，让我吗考虑changeBackground的一个抽象概念：someFunc。它使用copy-and-swap策略，但函数内还包含对另外两个函数f1和f2的调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...    <span class="comment">//对local状态做一份副本</span></span><br><span class="line">    f1();</span><br><span class="line">    f2();</span><br><span class="line">    ...    <span class="comment">//对修改后的状态置换过来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;很明显，如果f1或f2的异常安全性必“强烈保证”低，就很难让someFunc成为“强烈异常安全”。举个例子，假设f1只提供基本保证，那么为了让someFunc提供强烈保证，我们必须写出代码获得调用f1之前的整个程序状态、捕捉f1的所有可能异常、然后恢复原状态。</p>
<p>&emsp;&emsp;如果f1和f2都是“强烈异常安全”，情况并不就此好转。毕竟如果f1圆满结束，程序状态在任何方面都可能有所改变，因此如果f2随后抛出异常，程序状态和someFunc被调用前并不相同，甚至当f2没有改变任何东西时也是如此。</p>
<p>&emsp;&emsp;问题出在“连带影响”。如果函数只操作局部性状态，便相对容易地提供强烈保证。但是当函数对“非局部性数据”有连带影响时，提供强烈保证就困难得多。举个例子，如果调用f1带来的影响是某个数据库被改动了，那就很难让someFunc具备强烈安全性。一般而言在“数据库修改动作”送出之后，没有什么做法可以取消并恢复数据库旧观，因为数据库的其它客户很可能已经看到这一笔新数据。</p>
<p>&emsp;&emsp;这些议题想必会阻止你为函数提供强烈保证——即使你想那么做。另一个主题是效率。copy-and-swap的关键在于“修改对象数据的副本，然后在一个不抛异常的函数中将修改后的数据和原件置换”，因此必须为每一个即将被改动的对象做出一个副本，那得耗用你可能无法（或不愿意）供应的时间和空间。没错，大家都希望提供“强烈保证”：当它可被实现时你的确应该提供它，但“强烈保证”并非在任何时候都显得实际。</p>
<p>&emsp;&emsp;当“强烈保证”不切实际时，你就必须提供“基本保证”。现实中你或许会发现，你可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。只要你曾经付出适当的心力试图提供强烈保证，万一实际不可行，使你退而求其次地只提供基本保证，任何人都不该因此责难你。对许多函数而言，“异常安全性之基本保证”是一个绝对通情达理的选择。</p>
<p>&emsp;&emsp;这令我想到怀孕，一位女性若非怀孕，就是没怀孕。不可能说她“部分怀孕”。同样的道理，一个软件系统要不就具备异常安全性，要不就全然否定，没有所谓的“局部异常安全性”。如果系统内有一个函数不具备异常安全性，整个系统就不具备异常安全性，因为调用那个（不具备异常安全性的）函数有可能导致资源泄漏或数据结构败坏。不幸的是许多老旧C++代码并不具备异常安全性，所以今天许多系统仍然不能够说是“异常安全”的，因为它们并入了一些并非“异常安全”的代码。</p>
<p>&emsp;&emsp;没有理由让这种情况永垂不朽。当你撰写新码或修改旧码时，请仔细想想如何让它具备异常安全性。首先是“以对象管理资源”，那可阻止资源泄漏。然后是挑选三个“异常安全保证”中的某一个实施于你所写的每一个函数身上。你应该挑选“现实可施作”条件下的最强烈等级，只有当你的函数调用了传统代码，才别无选择地将它设为“无任何保证”。将你的决定写成文档，这一来是为你的函数用户着想，二来是为将来的维护者着想。函数的“异常安全性保证”是其可见接口的一部分，所以你应该慎重选择，就像选择函数接口的其它任何部分一样。</p>
<p>&emsp;&emsp;四十年前，满载goto的代码被视为一种美好实践，而今我们却致力于写出结构化控制流。二十年前，全局数据被视为一种美好实践，而今我们却致力于数据的封装。十年前，撰写“未将异常考虑在内”的函数被视为一种美好实践，而今我们致力于写出“异常安全码”。</p>
<blockquote>
<p>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</p>
<p>“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</p>
<p>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>pkg-config</title>
    <url>/2020/09/18/pkg-config/</url>
    <content><![CDATA[<hr>
<h1 id="pkg-config详解"><a href="#pkg-config详解" class="headerlink" title="pkg-config详解"></a>pkg-config详解</h1><h2 id="什么是pkg-config"><a href="#什么是pkg-config" class="headerlink" title="什么是pkg-config"></a>什么是pkg-config</h2><p>&emsp;&emsp;Pkg-config是一个linux下的命令，用于获取某一个库／模块的所有编译相关的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg-config opencv --libs --cflags</span><br></pre></td></tr></table></figure>

<p>结果是解析出了所有该库的头文件以及链接库</p>
<h2 id="为什么要有pkg-config"><a href="#为什么要有pkg-config" class="headerlink" title="为什么要有pkg-config"></a>为什么要有pkg-config</h2><p>&emsp;&emsp;就上述列子来看，所有用到opencv的其他程序，在编译时，只需要写出<code>pkg-config opencv --libs --cflags</code>，而不需要自己去找opencv的头文件以及库文件在哪。</p>
<p>&emsp;&emsp;如果你写了一个库，不管是静态的还是动态的，要提供给第三方使用，那除了给人家库／头文件，最好也写一个pc文件（package configure是库配置文件，保存在PKG_CONFIG_PATH = xxx。pc文件保存了该库的头文件、库所在的路径信息。GCC等编译器编译时，比如编译某个工程用到glib-2.0这个库，pkg-config会按照PKG_CONFIG_PATH中的路径进行搜索glib-2.0.pc，然后把glib-2.0.pc作为参数传给GCC，那么GCC就可以找到该库了），这样别人使用就方便很多，不用自己再动手写依赖了你哪些库，只需要敲一个<code>pkg-config [YOUR_LIB] --libs --cflag</code>。</p>
<h2 id="pkg-config的信息从哪里来"><a href="#pkg-config的信息从哪里来" class="headerlink" title="pkg-config的信息从哪里来"></a>pkg-config的信息从哪里来</h2><p>&emsp;&emsp;有两种途径：</p>
<ol>
<li>取系统的/usr/lib下的所有*.pc文件。</li>
<li>PKG_CONFIG_PATH环境变量所指向的路径下的所有*.pc文件。</li>
</ol>
<p>&emsp;&emsp;这些pc文件什么时候有的？</p>
<p>&emsp;&emsp;都是在你安装某个库／模块的时候添加的。比如你往系统里面安装opencv时，就会在/usr/lib64/pkgconfig目录下，放一个opencv.pc。比如我个人电脑上就没有pc文件，那么pc文件到底写了什么？</p>
<p>&emsp;&emsp;以我本人的电脑为例，在/usr/lib64/pkgconfig目录下有一个lua.pc文件，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V&#x3D;5.1</span><br><span class="line">R&#x3D;5.1.4</span><br><span class="line">prefix&#x3D;&#x2F;usr</span><br><span class="line">exe_prefix&#x3D;$&#123;prefix&#125;</span><br><span class="line">libdir&#x3D;&#x2F;usr&#x2F;lib64</span><br><span class="line">includedir&#x3D;$&#123;prefix&#125;&#x2F;include</span><br><span class="line"></span><br><span class="line">Name: Lua</span><br><span class="line">Description: An Extensible Extension Language</span><br><span class="line">Version: $&#123;R&#125;</span><br><span class="line">Requires: </span><br><span class="line">Libs: -llua -lm -ldl</span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br></pre></td></tr></table></figure>

<p>当我在本地电脑上面输入如下命令行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg-config lua --libs --cflags</span><br></pre></td></tr></table></figure>

<p>显示出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-llua -lm -ldl</span><br></pre></td></tr></table></figure>

<h2 id="如何添加自己的pc文件"><a href="#如何添加自己的pc文件" class="headerlink" title="如何添加自己的pc文件"></a>如何添加自己的pc文件</h2><p>&emsp;&emsp;如上文所说，有2种方式：</p>
<ol>
<li><p>把你的pc文件，直接放在/usr/lib64/pkgconfig…默认路径下。</p>
</li>
<li><p>把你的pc文件的路径写到PKG_CONFIG_PATH环境变量里。比如，你可以在/etc/.bashrc或者/home/[your count]/.bashrc的文件末尾添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$PGK_CONFIG_PATH:/home/[your count]/[your project]/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p>那么，pkg-config就会到该目录下寻找*.pc文件。</p>
<p>那么这个pc文件何时生效呢？</p>
<p>如果是/usr/lib64/pkgconfig下，立马生效！！！</p>
<p>如果在环境变量里，只要先source ~/.bashrc一下，让环境变量生成，也立马生效。</p>
</li>
</ol>
<h2 id="如何自己写pkg-config的pc文件"><a href="#如何自己写pkg-config的pc文件" class="headerlink" title="如何自己写pkg-config的pc文件"></a>如何自己写pkg-config的pc文件</h2><p>&emsp;&emsp;其实很简单，只需要拿别人的pc文件改一改就行了。</p>
<p>&emsp;&emsp;pc文件的所有参数：</p>
<ul>
<li><p>Name：该模块的的名字，比如你的pc名字是xxx.pc，那么名字最好也是xxx。</p>
</li>
<li><p>Description：模块的简单描述。<code>pkg-config --list-all</code>该命令可以查看到所有的模块信息，该命令的结果，每个模块的名字后面就是description。</p>
</li>
<li><p>URL：用户可以通过该URL获得更多的信息，或者下载信息。也是辅助的，可要可不要。</p>
</li>
<li><p>Version：版本号。</p>
</li>
<li><p>Requires：该模块有没有依赖其他模块。一般没有。</p>
</li>
<li><p>Requires.private：该模块有没有依赖其他模块，并且还不需要第三方知道的。一般也没有。</p>
</li>
<li><p>Conflicts：有没有和别的模块冲突。常用于版本冲突。比如，Confilcts: opencv &lt; 1.0.0，表示和opencv模块的1.0.0以下的版本有冲突。</p>
</li>
<li><p>Cflags：这个就很重要了。pkg-config的参数<code>--cflags</code>就指向这里。主要用于写本模块的头文件路径。</p>
</li>
<li><p>Libs：也很重要，pkg-config的参数<code>--libs</code>就指向这里。主要用于写本模块的库／依赖库的路径。</p>
</li>
<li><p>Libs.private：本模块依赖的库，但不需要第三方知道。</p>
</li>
</ul>
<p>其实必须写的只有5个：Name、Description、Version、Cflags、Libs。</p>
<p>举个例子。一个动态库，一个静态库。</p>
<p>例子1:动态库的pc文件。</p>
<p>假设我写了libfoo.so，我的库会被安装到/usr/local/lib/，头文件会放到/usr/local/include/。那么pc文件可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prefix&#x3D;&#x2F;usr&#x2F;local</span><br><span class="line">exe_prefix&#x3D;$&#123;prefix&#125;</span><br><span class="line">includedir&#x3D;$&#123;prefix&#125;&#x2F;include</span><br><span class="line">libdir&#x3D;$&#123;prefix&#125;&#x2F;lib</span><br><span class="line"></span><br><span class="line">Name: foo</span><br><span class="line">Description: The foo library</span><br><span class="line">Version: 1.0.0</span><br><span class="line">Cflags: -I$&#123;includedir&#125;&#x2F;</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lfoo</span><br></pre></td></tr></table></figure>

<p>例子2:静态库的pc文件</p>
<p>静态库链接动态库时，如何使用该静态库，如果我有个静态库libXXX.a，它依赖了很多其他动态库libAA.so，libBB.so，那么第三方程序要使用libXXX.a时，编译时还得链接libAA.so，libBB.so。为了让第三方程序不用操心我这个libXXX.a到底依赖了什么，可以为我的libXXX.a写一个pc文件。路径位于工程的文件下的lib/pkgconfig/。之后唯一需要做的就是把这些pc文件的路径，写到PKG_CONFIG_PATH。</p>
<p>在/home/parallels/.bashrc内添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:[your path]</span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p>然后<code>source /home/parallels/.bashrc</code>，最后就可以使用了！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>为多态基类声明virtual析构函数</title>
    <url>/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h1><p>&emsp;&emsp;有许多种做法可以记录时间，因此，设计一个TimeKeeper base class和一些derived classes作为不同的计时方法，相当合情合理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;  <span class="comment">//原子钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterClock</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;  <span class="comment">//水钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WristWatch</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;  <span class="comment">//腕表</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多客户只想在程序中使用时间，不想操心时间如何计算等细节，这时候我们可以设计factory函数，返回指针指向一个计时对象。Factory函数会“返回一个base class指针，指向新生成的derived class对象”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TimeKeeper* <span class="title">getTimeKeeper</span><span class="params">()</span></span>;  <span class="comment">//返回一个指针，指向一个</span></span><br><span class="line">                              <span class="comment">//TimeKeeper派生类的动态分配对象</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为遵守factory函数的规矩，被getTimeKeeper()返回的对象必须位于heap，因此为了避免泄漏内存和其它资源，将factory函数返回的每一个对象适当地delete掉很重要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TimeKeeper* ptk = getTimeKeeper();  <span class="comment">//从TimeKeeper继承体系</span></span><br><span class="line">                                    <span class="comment">//获得一个动态分配对象。</span></span><br><span class="line">...                                 <span class="comment">//运用它...</span></span><br><span class="line"><span class="keyword">delete</span> ptk;                         <span class="comment">//释放它，避免资源泄漏。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码有一个根本性弱点：纵使客户把每一件事都做对了，仍然没办法知道程序是如何行动的。</p>
<p>&emsp;&emsp;问题出在getTimeKeeper返回的指针指向一个derived class对象，而那个对象却经由一个base class指针被删除，而目前的base class有个non-virtual析构函数。这将引来灾难，因为C++明确指出，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果将是未定义的——实际执行时通常发生的是对象的derived成分没被销毁。如果getTimeKeeper返回指针指向一个AtomicClock对象，其内的AtomicClock成分（也就是声明于AtomicClock class内的成员变量）很可能没被销毁，而AtomicClock的析构函数也未能执行起来。然而其base class成分（也就是TimeKeeper这一部分）通常会被销毁，于是形成了一个诡异的“局部销毁”对象。这可是形成资源泄漏、败坏的数据结构、在调试器上浪费许多时间的绝佳途径喔。</p>
<p>&emsp;&emsp;消除这个问题的做法很简单：给base class一个virtual析构函数。此后删除derived class对象就会如我们所愿。没错，它会销毁整个对象，包括所有的derived class成分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    <span class="keyword">virtual</span> ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper* ptk = getTimeKeeper();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;  <span class="comment">//现在，行为正确</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;像TimeKeeper这样的base class除了析构函数之外通常还有其它virtual函数，因为virtual函数的目的是允许derived class的实现得以自定义。例如TimeKeeper就可能拥有一个virtual getCurrentTime，它在不同的derived classes中有不同的实现代码。任何class只要带有virtual函数都几乎确定应该也有一个virtual析构函数。</p>
<p>&emsp;&emsp;如果class不含virtual函数，通常表示它并不意图被用做一个base class。当class不企图被当作base class，令其析构函数为virtual往往是个馊主意。考虑一个用来表示二维空间坐标的class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xCoord, <span class="keyword">int</span> yCoord);</span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果int占用32bits，那么Point对象可能塞入一个64-bit缓存器中。更有甚者，这样一个Point对象可被当作一个“64-bit量”传给其他语言如C或FORTRAN编写的函数。然而当Point的析构函数是virtual，形势发生了变化。</p>
<p>&emsp;&emsp;欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数该被调用。这份信息通常是由一个所谓vptr（virtual table pointer）指针指出。vptr指向一个由函数指针构成的数组，称为vtbl（virtual table）；每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数。实际被调用的函数取决于该对象的vptr所指的那个vtbl——编译器在其中寻找适当的函数指针。</p>
<p>&emsp;&emsp;virtual函数的实现细节不重要。重要的是如果Point class内含virtual函数，其对象的体积会增加：在32-bit计算机体系结构中将占用64bits（为了存放两个ints）至96bits（两个ints加上vptr）；在64-bits计算机体系结构中可能占用64-128bits，因为指针在这样的计算机结构中占64bits。因此，为Point添加一个vptr会增加其对象大小达50%～100%！Point对象不再能够塞入一个64-bit缓存器，而C++的Point对象也不再和其他语言（如C）内的相同声明有着一样的结构（因为其他语言的对应物应该没有vptr），因此也就不再可能把它传递至（或接受自）其他语言所写的函数，除非我们明确补偿vptr——这属于实现细节，也因此不再具有移植性。</p>
<p>&emsp;&emsp;因此，无端地将所有classes的析构函数声明为virtual，就像从未声明它们为virtual一样，都是错误的。许多人的心得是：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。</p>
<p>&emsp;&emsp;即使class完全不带virtual函数，被“non-virtual析构函数问题”给咬伤还是有可能的。举个例子，标准string不含任何virtual函数，但有时候程序员会错误地把它当作base class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialString</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">string</span> &#123;  <span class="comment">//馊主意！std::string有个</span></span><br><span class="line">    ...                                    <span class="comment">//non-virtual析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;乍看之下似乎无害，但如果我们在程序任意某处无意间将一个pointer-to-SpecialString转换为一个pointer-to-string，然后将转换的那个string指针delete掉，我们将立刻被流放到“行为不正确”的荒地上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SpecialString* pss = <span class="keyword">new</span> SpecialString(<span class="string">"Impending Doom"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* ps;</span><br><span class="line">...</span><br><span class="line">ps = pss;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;  <span class="comment">//未定义！实际中的*ps的SpecialString资源会泄漏，</span></span><br><span class="line">            <span class="comment">//因为SpecialString析构函数没被调用。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;包括所有STL容器如vector，list，set，tr1::unordered_map等等，如果我们企图继承一个标准容器或任何其他“带有non-virtual析构函数”的class，拒绝这个诱惑吧！很不幸C++没有提供类似Java的final classes或C#的sealed classes那样的“禁止派生”机制。</p>
<p>&emsp;&emsp;有时候令class带一个pure virtual析构函数，可能颇为便利。pure virtual函数导致abstract class——也就是不能被实体化的class。也就是说，我们不能为这种类型创建对象。然而有时候我们希望拥有抽象class，但手上没有任何pure virtual函数，怎么办？由于抽象class总是企图被当作一个base class来用，而又由于base class应该有个virtual析构函数，并且由于pure virtual函数会导致抽象class，因此解法很简单：为我们希望它成为抽象的那个class声明一个pure virtual析构函数。下面是个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span>  <span class="comment">//AWOV = "Abstract w/o to Virtuals"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;  <span class="comment">//声明pure virtual析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个class有一个pure virtual函数，所以它是个抽象class，又由于它有个virtual析构函数，所以我们不需要担心析构函数的问题，然而这里有个窍门：我们必须为这个pure virtual析构函数提供一份定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AWOV::~AWOV() &#123;&#125;  <span class="comment">//pure virtual析构函数的定义</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;析构函数的运作方式是，最深层派生的那个class其析构函数最先被调用，然后是其每一个base class的析构函数被调用。编译器会在AWOV的derived class的析构函数中创建一个对～AWOV的调用动作，所以我们必须为这个函数提供一份定义。如果不这样做，编译器会发出抱怨。</p>
<p>&emsp;&emsp;“给base class一个virtual析构函数”，这个规则只适用于polymorphic（带有多态性质的）base class身上。这种base class的设计目的是为了用来“通过base class接口处理derived class对象”。TimeKeeper就是一个polymorphic base class，因为我们希望处理AtomicClock和WaterClock对象，纵使我们只有TimeKeeper指针指向它们。</p>
<p>&emsp;&emsp;并非所有base class的设计目的都是为了多态用途。例如标准string和STL容器都不被设计作为base class使用，更别提多态了。某些class的设计目的是作为base class使用，但不是为了多态用途。这样的class如input_iterator_tag等，它们并非被设计用来“经由base class接口处理derived class对象”，因此它们不需要virtual析构函数。</p>
<blockquote>
<p>Polymorphic（带多态性质的）base class应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。</p>
<p>Class的设计目的如果不是作为base class使用，或不是为了具备多态性，就不该声明virtual析构函数。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>了解C++默默编写并调用哪些函数</title>
    <url>/2020/07/20/%E4%BA%86%E8%A7%A3C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="了解C-默默编写并调用哪些函数"><a href="#了解C-默默编写并调用哪些函数" class="headerlink" title="了解C++默默编写并调用哪些函数"></a>了解C++默默编写并调用哪些函数</h1><p>&emsp;&emsp;对于一个class来说，如果我们自己没有声明，编译器就会为它声明（编译器版本的）一个copy构造函数，一个copy assignment操作符和一个析构函数。此外如果我们没有声明任何构造函数，编译器也会为我们声明一个default构造函数。所有这些函数都是public和inline。因此，如果我们写下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这就好像写下这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() &#123; ... &#125;</span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">    ~Empty() &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    Empty <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只要当这些函数被需要（被调用）时，它们才会被编译器创建出来。程序中需要它们是很平常的事。下面代码造成上述每一个函数被编译器产出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Empty e1;  <span class="comment">//default构造函数</span></span><br><span class="line">           <span class="comment">//析构函数</span></span><br><span class="line"><span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;  <span class="comment">//copy构造函数</span></span><br><span class="line">e2 = e1;       <span class="comment">//copy assignment操作符</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;default构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码，像是调用base class和non-static成员变量的构造函数和析构函数。注意，编译器产出的析构函数是个non-virtual，除非这个class的base class自身声明有virtual析构函数（这种情况下这个函数的虚属性主要来自base class）。</p>
<p>&emsp;&emsp;至于copy构造函数和copy assignment操作符，编译器创建的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象。考虑一下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NamedObject(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> T&amp; value);</span><br><span class="line">    NamedObject(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    T objectValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于其中声明了一个构造函数，编译器于是不再为它创建default构造函数。</p>
<p>&emsp;&emsp;NamedObject既没有声明copy构造函数，也没有声明copy assignment操作符，所以编译器会为它创建那些函数（如果它们被调用的话）。现在，看看copy构造函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">no1</span><span class="params">(<span class="string">"Smallest Prime Number"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">no2</span><span class="params">(no1)</span></span>;  <span class="comment">//调用copy构造函数</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编译器生成的copy构造函数必须以no1.nameValue和no1.objectValue为初值设定no2.nameValue和no2.objectValue。两者之中，nameValue的类型是string，而标准string有个copy构造函数，所以no2.nameValue的初始化方式是调用string的copy构造函数并以no1.nameValue为实参。另一个成员NamedObject&lt;int&gt;objectValue的类型是int，这是个内置类型，所以no2.objectValue会以“拷贝no1.objectValue内的每一个bits”来完成初始化。</p>
<p>&emsp;&emsp;编译器为NamedObject&lt;int&gt;所生成的copy assignment操作符，其行为基本上与copy构造函数如出一辙，但一般而言只有当生成的代码合法且有适当机会证明它有意义，其表现才会如我先前所说。万一两个条件有一个不符合，编译器会拒绝为class生成operator=。</p>
<p>&emsp;&emsp;举个例子，假设NameObject定义如下，其中nameValue是个reference to string，objectValue是个const T：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NamedObject(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value);</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    <span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑下面会发生什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">newDog</span><span class="params">(<span class="string">"Alice"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">oldDog</span><span class="params">(<span class="string">"Bob"</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(newDog, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(oldDog, <span class="number">36</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p = s;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;赋值之后p.nameValue应该指向s.nameValue所指的那个string吗？也就是说reference自身可被改动吗？如果可以，那可就不得了了，因为C+并不允许“让reference改指向不同对象”。换一个想法，p.nameValue所指的那个string对象该被修改，进而影响“持有pointers或references而且指向该string”的其它对象吗？也就是对象不被直接牵扯到赋值操作内？编译器生成的copy assignment操作符究竟该如何做呢？</p>
<p>&emsp;&emsp;面对这个难题，C++的响应是拒绝编译那一行赋值动作。如果我们打算在一个“内含reference成员”的class内支持赋值操作，我们必须自己定义copy assignment操作符。面对“内含const成员”的classes，编译器的反应也一样。更改const成员是不合法的，所以编译器不知道如何在它自己生成的赋值函数内面对它们。最后还有一种情况：如果某个base class将copy assignment操作符声明为private，编译器将拒绝为其derived classes生成一个copy assignment操作符。毕竟编译器为derived classes所生成的copy assignment操作符想象中可以处理base class成分，但它们当然无法调用derived classes无权调用的成员函数。编译器两手一摊，无能为力。</p>
<blockquote>
<p>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>令operator=返回一个reference to *this</title>
    <url>/2020/07/25/%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference%20to%20*this/</url>
    <content><![CDATA[<hr>
<h1 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator=返回一个reference to *this"></a>令operator=返回一个reference to *this</h1><p>&emsp;&emsp;关于赋值，有趣的是我们可以把它们写成连锁形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样有趣的是，赋值采用右结合律，所以上述连锁赋值被解析为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = (y = (z = <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里1先被赋值给z，然后其结果再被赋值给y，然后其结果再被赋值给x。</p>
<p>&emsp;&emsp;为了实现“连锁赋值，赋值操作符必须返回一个reference指向操作符的左侧实参。这是我们为class实现赋值操作符时应该遵循的协议：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//返回类型是个reference，指向当前对象</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;                       <span class="comment">//返回左侧对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//这个协议适用于+=，-=，*=等等</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span> rhs) &#123;             <span class="comment">//此函数也适用，</span></span><br><span class="line">        ...                                  <span class="comment">//即使此操作符的参数类型不符合协定</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意，这只是个协议，并无强制性。如果不遵循它，代码一样可以通过编译。然而这份协议被所有内置类型和标准程序库提供的类型如string，vector，complex，tr1::shared_ptr或即将提供的类型共同遵守。因此除非我们有一个标新立异的好理由，不然还是从众吧。</p>
<blockquote>
<p>令赋值操作符返回一个reference to *this。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>以对象管理资源</title>
    <url>/2020/07/27/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<hr>
<h1 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h1><p>&emsp;&emsp;假设我们使用一个用来塑模投资行为的程序库，其中各式各样的投资类型继承自一个root class Investment：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span> ... &#125;;  <span class="comment">//投资类型体系中的root class</span></span><br></pre></td></tr></table></figure>

<p>进一步假设，这个程序库系通过一个工厂函数供应我们某特定的Investment对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;  <span class="comment">//返回指针，指向Investment继承体系内的动态分配对象。</span></span><br><span class="line">                                 <span class="comment">//调用者有责任删除它，这里为了简化，刻意不写参数。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如上注释所述，createInvestment的调用端使用了函数返回的对象后，有责任删除之。现在考虑有个f函数履行了这个责任：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Investment* pInv = createInvestment();  <span class="comment">//调用factory函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;                            <span class="comment">//释放pInv所指对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这看起来妥当，但若干情况下f可能无法删除它得自createInvestment的投资对象——或许因为“…”区域内的一个过早的return语句。如果这样一个return被执行起来，控制流就绝不会触及delete语句。类似情况还可能发生在很多其他地方。</p>
<p>&emsp;&emsp;为确保createInvestment返回的资源总是被释放，我们需要将资源放进对象内，当控制流厉害f，该对象的析构函数会自动释放那些资源。把资源放进对象内，我们便可依赖C++的“析构函数自动调用机制”确保资源被释放。</p>
<p>&emsp;&emsp;我们可以使用“引用计数型智能指针”（RCSP）。所谓RCSP也是个智能指针，持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源。RCSP提供的行为类似垃圾回收，不同的是RCSP无法打破环状引用（例如两个其实已经没被使用的对象彼此互指，因而好像还处于“被使用”状态）。</p>
<p>&emsp;&emsp;C++标准库中的shared_ptr就是个RCSP，所以我们可以这样写f：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//调用factory函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;  <span class="comment">//经由share_ptr析构函数自动删除pInv</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;share_ptr在其析构函数内做delete而不是delete[]动作。这意味着在动态分配而得的array身上使用shared_ptr是个馊主意。尽管如此，可叹的是，那么做仍能通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>])</span></span>;  <span class="comment">//馊主意！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们或许会惊讶地发现，并没有针对“C++动态分配数组”而设计的类似shared_ptr这样的东西。这是因为vector和sting几乎总是可以取代动态分配而得的数组。如果你们还是认为拥有针对数组而设计、类似shared_ptr这样的class较好，看看Boost吧。在那儿我们会很高兴地发现boost::scoped_array和boost::shared_array class，它们都提供我们想要的行为。</p>
<blockquote>
<p>为防止资源泄漏，务必使用shared_ptr这类智能指针，它们在构造函数中获得资源并在析构函数中释放资源。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>以独立语句将new对象置入智能指针</title>
    <url>/2020/07/30/%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86new%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<h1 id="以独立语句将new对象置入智能指针"><a href="#以独立语句将new对象置入智能指针" class="headerlink" title="以独立语句将new对象置入智能指针"></a>以独立语句将new对象置入智能指针</h1><p>&emsp;&emsp;假设我们有个函数涌来揭示处理程序的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑调用processWidget：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码可不能通过编译。shared_ptr构造函数需要一个原始指针，但该构造函数是个explicit构造函数，无法进行隐式转换，将得自“newWidget”的原始指针转换为processWidget所要求的shared_ptr。如果写成这样就可以通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然而上述调用却可能泄露资源。</p>
<p>&emsp;&emsp;编译器产出一个processWidget调用码之前，必须首先核算即将被传递的各个实参。上述第二个实参只是一个单纯的对priority函数的调用，但第一个实参std::shared_ptr&lt;Widget&gt;(new Widget)由两部分组成：</p>
<ul>
<li>执行“new Widget”表达式</li>
<li>调用shared_ptr构造函数</li>
</ul>
<p>也是在调用processWidget之前，编译器必须创建代码，做一下三件事：</p>
<ul>
<li>调用priority</li>
<li>执行“new Widget”</li>
<li>调用shared_ptr构造函数</li>
</ul>
<p>&emsp;&emsp;C++编译器以什么样的次序完成这些事情呢？弹性很大。这和其他语言如Java和C#不同，那两种语言总是以特定次序完成函数参数的核算。可以确定的是“new Widget”一定执行于shared_ptr构造函数被调用之前，因为这个表达式的结果还要被传递作为shared_ptr构造函数的一个实参，但对priority的调用则可以排在第一或第二或第三执行。如果编译器选择以第二顺位执行它（说不定可以因此产生更高效的代码，谁知道呢），最终获得这样的操作序列：</p>
<ol>
<li>执行“new Widget”</li>
<li>调用priority</li>
<li>调用shared_ptr构造函数</li>
</ol>
<p>&emsp;&emsp;现在我们想想，万一对priority的调用导致异常，会发生什么事？在此情况下“new Widget”返回的指针将遗失，因为它尚未被置入shared_ptr内，后者是我们期盼用来防卫资源泄漏的武器。没错，在对processWidget的调用过程可能引发资源泄漏。</p>
<p>&emsp;&emsp;避免这类问题的办法很简单：使用分离语句，分别写出（1）创建Widget，（2）将它置入一个智能指针内，然后再把哪个智能指针传给processWidget：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以独立语句将new对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GNU make工具的汇总（3）</title>
    <url>/2020/09/14/%E5%85%B3%E4%BA%8EGNU%20make%E5%B7%A5%E5%85%B7%E7%9A%84%E6%B1%87%E6%80%BB%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h1><h2 id="规则语法"><a href="#规则语法" class="headerlink" title="规则语法"></a>规则语法</h2><p>&emsp;&emsp;通常规则的语法格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGETS: PREQUISITES</span></span><br><span class="line">    COMMAND</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGETS: PREQUISITES; COMMAND</span></span><br><span class="line">    COMMAND</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>书写规则时，需要注意以下几点：</p>
<ol>
<li><p>规则的命令部分有两种书写方式：a.命令可以和目标：依赖描述放在同一行。命令在依赖文件列表后并使用分号（；）和依赖文件列表分开。b.命令在目标：依赖描述的下一行。作为独立的命令行。</p>
<p>当作为独立的命令行时此行必须以“TAB”字符开始。在Makefile中，在第一个规则之后出现的所有以“TAB”字符开始的行都会被当作命令来处理。</p>
</li>
<li><p>Makefile中符号“$”有特殊的含义（表示变量或者函数的引用），在规则中需要用到符号“$”的地方，需要书写两个连续的（“$$”）。</p>
</li>
<li><p>前边已提到过，对于Makefile中一个较长的行，我们可以使用反斜线“\”将其书写到几个独立的行上。虽然make对Makefile文本行的最大长度是没有限制的，但还是建议这样做。</p>
</li>
</ol>
<p>规则的中心思想是：目标文件的内容是由依赖文件决定的，依赖文件的任何一处改动，将导致目前已经存在的目标文件的内容过期。规则的命令为重建目标提供了方法，这些命令运行在系统shell之上。</p>
<h2 id="依赖的类型"><a href="#依赖的类型" class="headerlink" title="依赖的类型"></a>依赖的类型</h2><p>&emsp;&emsp;有时候，需要定义一个这样的规则，在更新目标（目标文件已经存在）时只需要根据依赖文件中的部分来决定目标是否需要被重建，而不是在依赖文件里的任何一个被修改后都重建目标。为了实现这一目的，相应的就需要对规则的依赖就行分类，一类是在这些依赖文件被更新后，需要更新规则的目标；另一类是更新这些依赖后，可以不需要更新规则的目标。我们把第二类称为：“ordered-only”依赖。书写规则时，“ordered-only”依赖使用管道符号“|”开始，作为目标的一个依赖文件。规则依赖列表中管道符号“|”左边是常规依赖，管道右边的就是“ordered-only”依赖。这样的规则书写格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGETS: NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES</span></span><br></pre></td></tr></table></figure>

<p>这样的规则中常规依赖文件可以是空；同样也可以对一个目标就行多次追加依赖。注意：规则依赖文件列表中如果一个文件同时出现在常规列表和“ordered-only”列表中，那么此文件被作为常规依赖处理（因为常规依赖所实现的动作是“ordered-only”依赖所实现的动作的一个超集）。</p>
<h2 id="通配符存在的缺陷"><a href="#通配符存在的缺陷" class="headerlink" title="通配符存在的缺陷"></a>通配符存在的缺陷</h2><p>&emsp;&emsp;在我们的Makefile中，期望能够根据所有的.o文件生成可执行文件“demo”：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = *.o</span><br><span class="line"></span><br><span class="line"><span class="section">demo: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o demo <span class="variable">$(CFLAGS)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>这里变量“objects”的值是一个字符串“*.o”。在重建“demo”的规则中对变量“objects”进行展开，目标“demo”的依赖就是“*.o”，即所有的.o文件列表。如果在工作目录下已经存在必需的.o文件，那么这些.o文件将成为目标的依赖文件，目标“demo”将根据规则重建。</p>
<p>&emsp;&emsp;但是如果将工作目录下的所有.o文件删除，重新执行make将会得到一个类似于“没有创建*.0文件的规则”的错误提示。这当然不是我们想要的结果。为了达到我们想要的结果，在对变量进行定义时需要使用一些高级的技巧，包括使用“wildcard”函数（定义为“objects =$(wildcard *.o)”）和字符串的置换。</p>
<h2 id="函数wildcard"><a href="#函数wildcard" class="headerlink" title="函数wildcard"></a>函数wildcard</h2><p>&emsp;&emsp;在规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用“wildcard”，它的用法是：$(wildcard PATTERN…)。在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。但如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。</p>
<p>&emsp;&emsp;一般来说，我们可以使用“$(wildcard *.c)”来获取工作目录下的所有的.c文件列表。复杂一些的用法，可以使用“$(patsubst %.c,%.o,$(wildcard *.c))”，首先使用“wildcard”函数获取工作目录下的.c文件列表；之后将列表中所有文件名的后缀.c替换为.o。这样我们就可以得到在当前目录下可生成的.o文件列表。因此在一个目录下可以使用如下内容的Makefile来将工作目录下的所有.c文件进行编译并最后连接成为一个可执行文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample Makefile</span></span><br><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o foo <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里使用了make的隐含规则来编译.c的源文件。</p>
<h2 id="Makefile伪命令"><a href="#Makefile伪命令" class="headerlink" title="Makefile伪命令"></a>Makefile伪命令</h2><p>&emsp;&emsp;伪目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令，有时也可以将一个伪目标称为一个标签。使用伪目标有两个原因：</p>
<ol>
<li>避免在我们的Makefile中定义的只执行命令的目标和工作目录下的实际文件名出线名字冲突。</li>
<li>提高执行make时的效率，特别是对一个大型的工程来说，编译的效率我们同时关心。</li>
</ol>
<p>以下就这两个问题我们进行分析讨论：</p>
<ol>
<li><p>如果我们需要编写这样的一个规则：规则所定义的命令不是去创建目标文件，而是通过make命令行指定它来执行一些特定的命令。像很常见的clean目标:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>

<p>规则中“rm”不是创建文件“clean”的命令，而是删除当前目录下的所有.o文件和temp文件。当工作目录下不存在“clean”这个文件时，我们输入“make clean”，“rm *.o temp”总会被执行，这是我们的初衷。</p>
<p>&emsp;&emsp;但是如果当前工作目录下存在文件“clean”，情况就不一样了，同样我们输入“make clean”，由于这个规则没有任何依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令，因此“rm”命令不会被执行。这并不是我们的初衷。为了解决这个问题，我们需要将目标“clean”声明为伪目标。如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br></pre></td></tr></table></figure>

<p>这样目标“clean”就被声明为一个伪目标，无论在当前目录下是否存在“clean”这个文件，我们输入“make clean”之后，“rm”命令都会被执行。而且，当一个目标被声明为伪目标后，make在执行此规则时不会去试图查找隐含规则来创建它。其完整格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪目标的另一种使用场合是在make的并行和递归执行过程中。此情况下一般会存在一个变量，定义为所有需要make的子目录。对多个目录进行make对实现方式可以是：在一个规则的命令行中使用shell循环来完成。如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SUBDIR = one two three</span><br><span class="line"></span><br><span class="line"><span class="section">subdirs:</span></span><br><span class="line">    for dir in <span class="variable">$(SUBDIR)</span>; do\</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C $$dir;\</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>但这种实现方法存在以下几个问题。1.当子目录执行make出现错误时，make不会退出。也就是说，在对某一个目录执行make失败后，会继续对其他的目录进行make。在最终执行失败的情况下，我们很难根据错误提示定位出具体是在哪个目录下执行make时发生错误。2.另一个问题就是使用这种shell的循环方式时，没有用到make对目录的并行处理功能，由于规则的命令是一条完整的shell命令，不能被并行处理。</p>
<p>有了为目标后，我们可以用它来克服上述2个问题：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SUBDIRS = one two three</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: subdirs $(SUBDIRS)</span></span><br><span class="line"><span class="section">subdirs: <span class="variable">$(SUBDIRS)</span></span></span><br><span class="line"><span class="variable">$(SUBDIRS)</span>:</span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$@</span></span><br><span class="line"><span class="section">one: two</span></span><br></pre></td></tr></table></figure>

<p>上述的实现中有一个没有命令行的规则“one: two”，此规则用来限制子目录的make顺序。</p>
<p>&emsp;&emsp;一般情况下，一个伪目标不作为另外一个目标的依赖。这是因为当一个目标文件的依赖包含伪目标时，每一次在执行这个规则时伪目标所定义的命令都会被执行。当一个伪目标没有作为任何目标的依赖时，我们只能通过make的命令行来指定它为make的终极目标，来执行它所在规则所定义的命令。例如“make clean”。</p>
<p>&emsp;&emsp;在Makefile中，一个伪目标可以有自己的依赖（可以是一个或者多个文件、一个或者多个伪目标）。在一个目录下如果需要创建多个可执行程序，我们可以将所有程序的重建规则在一个Makefile中描述。因为Makefile中第一个目标是“终极目标”，约定的做法是使用一个“all”的伪目标来作为终极目标，它的依赖文件就是那些需要创建的程序，以下就是一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: one two three</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"></span><br><span class="line"><span class="section">one: one.o func.o</span></span><br><span class="line">    cc -o one one.o func.o</span><br><span class="line"><span class="section">two: two.o func.o</span></span><br><span class="line">    cc -o two two.o func.o</span><br><span class="line"><span class="section">three: three.o func.o</span></span><br><span class="line">    cc -o three three.o func.o</span><br></pre></td></tr></table></figure>

<p>执行make时，目标“all”被作为终极目标。为了完成对它的更新，make会创建或者重建目标“all”的所有依赖文件。当需要单独更新某一个程序时，我们可以通过make的命令行选项来目前指定需要重建的程序（例如：“make one”）。</p>
<p>&emsp;&emsp;当一个伪目标作为另一个伪目标的依赖时，make将其作为另外一个伪目标的子例程来处理（就跟C语言中的函数调用一样）。下面就是这个做法的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line"><span class="section">cleanall: cleanobj cleandiff</span></span><br><span class="line">    rm program</span><br><span class="line"><span class="section">cleanobj:</span></span><br><span class="line">    rm *.o</span><br><span class="line"><span class="section">cleandiff:</span></span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure>

<p>我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<p>&emsp;&emsp;说明：</p>
<p>&emsp;&emsp;通常在清除文件的伪目标所定义的命令中“rm”使用选项“-f（–force）”来防止在缺少删除文件时出错并退出。也可以在“rm”之前加上“-”来防止“rm”错误退出，使用这个方法时make会提示错误信息但不会退出。为了不看到这些讨厌的信息，需要使用上述第一种方式。</p>
<p>&emsp;&emsp;另外make存在一个内嵌的隐含变量“RM”。它被定义为：“RM=rm -f”。因此在书写“clean”规则的命令时可以使用变量“$(RM)”来替代“rm”。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GNU make工具的汇总（1）</title>
    <url>/2020/09/11/%E5%85%B3%E4%BA%8EGNU%20make%E5%B7%A5%E5%85%B7%E7%9A%84%E6%B1%87%E6%80%BB%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="关于GNU-make工具的汇总（1）"><a href="#关于GNU-make工具的汇总（1）" class="headerlink" title="关于GNU make工具的汇总（1）"></a>关于GNU make工具的汇总（1）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;对于这个话题，想必是每一个Linux程序员的苦手。不像Windows ，Mac等有自己完整的一套编译工具链IDE等，可以一键构建好自己的工程，Linux下的工程构建更多的是需要自己手动来完成，尽管目前已然有许多自动化构建工具，但是掌握好这么一个可以了解到一个工程构建的全部流程的优秀工具对于我们Linux程序员来说是百利而无一害的。不会使用GUN make来构建和管理自己的工程，应该不算是一个合格的程序员，至少不是一个合格的Unix程序员。</p>
<p>&emsp;&emsp;在Unix环境下，使用GNU make工具能够“比较容易”地构建一个属于自己的工程，整个工程最后只需要一个命令就可以完成编译，链接以及执行。在此之前，我们则需要编写一个或者多个Makefile文件，这个环节也是整个过程最难的地方。</p>
<p>&emsp;&emsp;所要完成的Makefile文件描述了整个工程的编译、链接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建那些库文件以及如何创建这些库文件、如何最后产生我们想要得可执行文件。尽管看起来可能是很复杂的事情，但是为工程编写 Makefile 的好处是能够使用一行命令来完成“自动化编译”，一旦提供一个（通常对于一个工程来说会是多个）正确的 Makefile。编译整个工程你所要做的唯一的一件事就是在 shell 提示符下输入 make 命令。整个工程完全自动编译，极大提高了效率。</p>
<p>&emsp;&emsp;make是一个命令工具，它负责解释Makefile中的指令（应该说是规则）。在Makefile文件中描述了整个工程所需文件的编译顺序、编译规则。Makefile有自己的语法规则，书写格式，就像C语言有自己的语法一样。而且更棒的是在Makefile中可以使用系统shell所提供的任何命令来完成自己想要的工作。Makefile在绝大多数的IDE开发环境中都在使用。</p>
<p>&emsp;&emsp;本文以及后续所有关于Makefile的blog都将采用C语言的源程序。</p>
<h2 id="关于学习GNU-make工具，你所需要掌握的知识"><a href="#关于学习GNU-make工具，你所需要掌握的知识" class="headerlink" title="关于学习GNU make工具，你所需要掌握的知识"></a>关于学习GNU make工具，你所需要掌握的知识</h2><p>&emsp;&emsp;在我们开始讨论Makefile之前，首先要明确几个基本概念（这里不对它们作详细的解释，本系列blog主要针对于GUN make工具）：</p>
<ul>
<li>编译：将高级语言转换为计算机可识别的机器指令。转换后的指令虽然可以被计算机识别，但是还不能被执行。编译时，编译器检查高级语言的语法、函数和变量的声明是否正确。只有所有的语法正确、相关变量定义正确，编译器才会编译出中间目标文件。通常，一个高级语言的源文件都可对应一个目标文件。目标文件在Linux中默认后缀为“.o”（如“func.c”的目标文件为“func.o”）。</li>
<li>链接：将多个.o文件，或者.o文件和库文件链接为可被操作系统执行的可执行程序（Linux下可执行文件的格式为：ELF）。链接器不检查函数所在的源文件，只检查所有.o文件中定义的符号。将.o文件中的函数和其他.o和库文件中的相关符号进行合并，对所有文件中的符号进行重定位，并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GUN的“ld”工具。</li>
<li>静态库：又称为“文档文件（Archive File）。它是多个.o文件的集合。Linux中静态文件的后缀为“.a”。静态库中的各个成员没有特殊的存在格式，仅仅是一个.o文件的集合。通常使用“ar”工具维护和管理静态库。</li>
<li>共享库：也是多个.o文件的集合，但是这些.o文件是由编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行的条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行链接。多个可执行程序可共享库文件的代码段（多个程序可以共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。</li>
</ul>
<h2 id="GNU-make介绍"><a href="#GNU-make介绍" class="headerlink" title="GNU make介绍"></a>GNU make介绍</h2><p>&emsp;&emsp;此前说过，在执行make之前，我们需要一个或多个Makefile文件来告诉make该做什么以及怎么做。通常make工具主要被用来进行工程编译和程序链接。</p>
<p>&emsp;&emsp;当使用make工具进行编译时，工程中以下几种文件在执行make时将会被编译（或者重新编译）：</p>
<ol>
<li>所有的源文件没有被编译过，则对各个C源文件进行编译并进行链接，生成最终的可执行程序；</li>
<li>每一个在上次执行make之后修改过的C源文件在本次执行make时将会被重新编译；</li>
<li>头文件在上一次执行make之后被修改，则所有包含此头文件的C源文件在本次执行make时将会被重新编译。</li>
</ol>
<h3 id="Makefile规则介绍"><a href="#Makefile规则介绍" class="headerlink" title="Makefile规则介绍"></a>Makefile规则介绍</h3><p>&emsp;&emsp;一个简单的Makefile描述规则组成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGET...:PREREQUISITES...</span></span><br><span class="line">  COMMAND</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;target：规则的目标。通常是最后需要生成的文件名或者是为了实现这个目的而必需的中间过程文件名。可以是.o文件、也可以是最后的可执行程序的文件名等。另外，目标也可以是一个make执行动作的名称，比如“clean”，我们称这样的目标是“伪目标”。</p>
<p>&emsp;&emsp;prerequisites：规则的依赖。生成规则目标所需的文件名列表。通常一个目标依赖于一个或者多个文件。</p>
<p>&emsp;&emsp;command：规则的命令行。是规则所要执行的动作（任何shell命令或者是可在shell下执行的程序）。它限定了make执行这条规则所需要的动作。</p>
<p>&emsp;&emsp;一个规则可以有多个命令行。每一条命令占一行。注意：每一个命令行必须以“TAB”字符开始，“TAB”字符告诉make此行是一个命令行。</p>
<p>&emsp;&emsp;一个目标可以没有依赖而只有动作（指定的命令）。比如Makefile中的目标“clean”，此目标没有依赖，只有命令。它所定义的命令通常用来删除make过程中产生的中间文件（进行清理工作）。</p>
<h3 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h3><p>&emsp;&emsp;现在，我们来编写一个最为简单的Makefile，此示例由2个头文件，4个C源文件组成，并且最终将生成可执行文件“sample”。示例如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample Makefile</span></span><br><span class="line"><span class="section">sample: main.o func1.o func2.o func3.o</span></span><br><span class="line">    cc -o sample main.o func1.o func2.o func3.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c header1.h</span></span><br><span class="line">    cc -c main.c</span><br><span class="line"><span class="section">func1.o: func1.c header1.h header2.h</span></span><br><span class="line">    cc -c func1.c</span><br><span class="line"><span class="section">func2.o: func2.c header1.h header2.h</span></span><br><span class="line">    cc -c func2.c</span><br><span class="line"><span class="section">func3.o: func3.c header1.h header2.h</span></span><br><span class="line">    cc -c func3.c</span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm sample main.o func1.o \</span><br><span class="line">    func2.o func3.o</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编写Makefile时，可以将一个较长行使用反斜线来分解多行，这样可以使我们的Makefile容易阅读。但需要注意的是：反斜线之后不能有空格。在完成这个Makefile之后，为了创建可执行程序“sample”，所要做的就是在包含此Makefile的目录下输入命令“make”。删除在此目录下之前使用“make”生成的文件（包括那些中间文件），也只需要输入命令“make clean”就可以了。</p>
<p>&emsp;&emsp;在这个Makefile中，我们的目标就是可执行文件“sample”和那些中间.o文件；依赖就是冒号后面的那些.c文件和.h文件。所有的.o文件既是依赖文件又是目标。</p>
<h3 id="make如何工作"><a href="#make如何工作" class="headerlink" title="make如何工作"></a>make如何工作</h3><p>&emsp;&emsp;当在shell提示符下输入“make”命令后。make读取当前目录下的Makefile文件，并将Makefile文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在我们的示例中，第一个规则就是sample所在的规则。规则描述了“sample”的依赖关系，并定义了链接.o文件生成目标“sample”的命令；make在执行这个命令之前，首先处理目标“sample”的所有的依赖文件的更新规则。对这些.o文件为目标的规则处理有以下三种情况：</p>
<ol>
<li>目标.o文件不存在，使用其描述规则创建它；</li>
<li>目标.o文件存在，目标.o文件所依赖的.c源文件、.h头文件中的任何一个比目标.o文件更新（在上一次make之后被修改）。则根据规则重新编译生成它；</li>
<li>目标.o文件存在，目标.o文件比它的任何一个依赖文件更新（它的依赖文件在上一次make之后没有被修改）。则什么都不做。</li>
</ol>
<p>&emsp;&emsp;这些.o文件所在的规则之所以会被执行，是因为这些.o文件出现在“终极目标”的依赖列表中。在Makefile中一个规则的目标如果不是“终极目标”所依赖的（或者不是“终极目标”的依赖文件所依赖的），那么这个规则将不会被执行，除非明确指定执行这个规则（例如“make clean”）。</p>
<p>&emsp;&emsp;完成了对.o文件的创建或者更新之后，make程序将处理终极目标“sample”所在的规则，分为以下三种情况：</p>
<ol>
<li>目标“sample”文件不存在，则执行规则以创建目标“sample”；</li>
<li>目标“sample”文件存在，其依赖文件中有一个或者多个文件比它更新，则根据规则重新链接生成“sample”；</li>
<li>目标“sample”文件存在，它比它的任何一个依赖文件都更新，则什么也不做。</li>
</ol>
<h3 id="指定变量"><a href="#指定变量" class="headerlink" title="指定变量"></a>指定变量</h3><p>&emsp;&emsp;对于上述示例中的终极目标“sample”所在的规则中，.o文件列表出现了两次，并且当遇到大量.o文件时，这就会给维护以及修改带来很大的不便。</p>
<p>&emsp;&emsp;为了避免这个问题，在实际工作中，大家普遍比较认可的做法是，使用一个变量（比如“OBJECT”或者“object”或者其他名称）来作为所有.o文件列表的替代。在使用这些文件列表的地方，使用此变量来代替。在上述Makefile中我们可以添加这样一行：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o func1.o func2.o func3.o</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;“objects”作为一个变量，它代表所有的.o文件列表。在定义了此变量后，我们就可以在需要使用这些.o文件列表的地方使用“$(objects)”来表示它，而不需要罗列所有的.o文件。因此上述示例的规则可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o func1.o func2.o func3.o</span><br><span class="line"><span class="section">sample: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o sample <span class="variable">$(objects)</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<h3 id="自动推导规则"><a href="#自动推导规则" class="headerlink" title="自动推导规则"></a>自动推导规则</h3><p>&emsp;&emsp;在使用make编译.c源文件时，编译.c源文件规则的命令可以不用明确给出，这是因为make本身存在一个默认规则，能够自动完成对.c文件的编译并生成对应的.o文件。在Makefile中我们只需要给出需要重建的目标文件名（一个.o文件），make会自动为这个.o文件寻找适合的依赖文件（对应的.c文件。对应指的是：文件名除后缀外，其余都相同的两个文件），而且使用正确的命令来重建这个目标文件。</p>
<p>&emsp;&emsp;这样，在编写Makefile时，我们就可以省略掉描述.c和.o文件依赖关系的规则，而只需要给出那些特定的规则描述（.o目标需要的.h文件）。因此上述示例可以写成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample Makefile</span></span><br><span class="line">objects = main.o func1.o func2.o func3.o</span><br><span class="line"></span><br><span class="line"><span class="section">sample: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o sample <span class="variable">$(objects)</span></span><br><span class="line">		</span><br><span class="line"><span class="section">main.o: header1.h </span></span><br><span class="line"><span class="section">func1.o: header1.h header2.h</span></span><br><span class="line"><span class="section">func2.o: header1.h header2.h</span></span><br><span class="line"><span class="section">func3.o: header1.h header2.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line">    rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<h3 id="清除工作目录过程文件"><a href="#清除工作目录过程文件" class="headerlink" title="清除工作目录过程文件"></a>清除工作目录过程文件</h3><p>&emsp;&emsp;之前提到的清除当前目录下编译过程中产生的临时文件的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在实际应用中，我们将上述规则写成如下形式：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这两个实现有两点不同：1.通过“.PHONY”特殊目标将“clean”目标声明为伪目标。避免当磁盘上存在一个名为“clean”文件时，目标“clean”所在规则的命令无法执行（具体原理见后续blog）。2.在命令行之前使用“-”，意思是忽略命令“rm”的执行错误。</p>
<p>&emsp;&emsp;因为目标“clean”没有出现在终极目标“sample”依赖关系中，所以我们执行make时，目标“clean”所在规则不会被处理。当需要执行此规则时，要在make的命令行选项中明确指定这个目标（执行“make clean”）。</p>
<p>&emsp;&emsp;以上就是关于Makefile的大致描述，关于Makefile的语法以及更加详尽的用法将在后续blog中进行描述。此blog目的仅仅是使读者对于Makefile有一个大致的印象，看完此内容并不足以使你成为一个Makefile高手，甚至不会是一个入门级选手。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GNU make工具的汇总（2）</title>
    <url>/2020/09/12/%E5%85%B3%E4%BA%8EGNU%20make%E5%B7%A5%E5%85%B7%E7%9A%84%E6%B1%87%E6%80%BB%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="Makefile总述"><a href="#Makefile总述" class="headerlink" title="Makefile总述"></a>Makefile总述</h1><h2 id="Makefile的内容"><a href="#Makefile的内容" class="headerlink" title="Makefile的内容"></a>Makefile的内容</h2><p>&emsp;&emsp;在一个完整的Makefile中，包含了5个东西：显式规则、隐式规则、变量定义、指示符和注释。</p>
<ul>
<li>显式规则：它描述了在何种情况下如何更新一个或者多个被称为目标的文件（Makefile的目标文件）。书写Makefile时，需要明确地给出目标文件、目标依赖文件列表以及更新目标文件所需要的命令。</li>
<li>隐式规则：它是make根据一类目标文件（典型的是根据文件名的后缀）而自动推导出来的规则。make根据目标文件名，自动产生目标的依赖文件并使用默认的命令来对目标进行更新。</li>
<li>变量定义：使用一个字符或一个字符串代表一段文本串，当定义了一个变量以后，Makefile后续在需要使用此文本串的地方，就会通过引用这个变量来实现对文本串的使用。</li>
<li>指示符：也就是命令</li>
<li>注释：Makefile中“#”字符后的内容被作为是注释内容（和shell脚本一样）处理。注释行的结尾如果存在反斜线（\），那么下一行也被作为注释行。</li>
</ul>
<h2 id="包含其它Makefile文件"><a href="#包含其它Makefile文件" class="headerlink" title="包含其它Makefile文件"></a>包含其它Makefile文件</h2><p>&emsp;&emsp;“include”指示符告诉make暂停读取当前的Makefile，而转去读取“include”指定的一个或多个文件，完成以后再继续当前的Makefile的读取。Makefile中指示符“include”书写在独立的一行，其形式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> FILENAMES...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;FILENAMES是shell所支持的文件名（可以使用通配符）。</p>
<p>&emsp;&emsp;指示符“include”和文件名之间、多个文件之间使用空格或者“TAB”键隔开。</p>
<p>&emsp;&emsp;如果指示符“include”指定的文件不是以斜线开始（绝对路径，如/usr/src/Makefile…），而且当前目录下也不存在此文件；make将根据文件名试图在以下几个目录查找：首先，查找使用命令行选项“-l”或者“–include-dir”指定的目录，如果找到指定的文件，则使用这个文件；否则继续依次搜索以下几个目录（如果存在）：“/usr/gun/include”、“/usr/local/include”和“/usr/include”。</p>
<p>&emsp;&emsp;当这些目录下都没有找到“include”指定的文件时，make将会提示一个包含文件未找到的警告提示，但是不会立即退出。而是继续处理Makefile后续内容。当完成读取整个Makefile后，make将试图使用规则来创建通过指示符“include”指定的但未找到的文件，当不能创建它时（没有创建这个文件的规则），make将提示致命错误并退出。</p>
<p>&emsp;&emsp;通常我们在Makefile中使用“-include”来代替“include”，来忽略由于包含文件不存在或者无法创建时的错误提示。</p>
<h2 id="变量MAKEFILES"><a href="#变量MAKEFILES" class="headerlink" title="变量MAKEFILES"></a>变量MAKEFILES</h2><p>&emsp;&emsp;如果在当前环境定义了一个“MAKEFILES”环境变量，make执行时首先将此变量的值作为需要读入的Makefile文件，多个文件之间使用空格隔开。类似使用指示符“include”包含其他Makefile文件一样，如果文件名非绝对路径而且当前目录也不存在此文件，make就会在一些默认的目录去寻找，它和“include”的区别：</p>
<ol>
<li>环境变量指定的makefile文件中的目标不会作为make执行的“终极目标”；而在make的工作目录下存在这样一个文件（“makefile”、“Makefile”等），那么make执行时的“终极目标”就是当前目录下这个文件中所定义的“终极目标”。</li>
<li>环境变量所定义的文件列表，在执行make时，如果不能找到其中一个文件。make不会提示错误，也不退出。也就是说环境变量“MAKEFILES”定义的包含文件是否存在不会导致make错误。</li>
<li>make在执行时，首先读取的是环境变量“MAKEFILES”所指定的文件列表，之后才是工作目录下的makefile文件，“include”指定的文件是在make发现此关键字时，暂停正在读取的文件而转去读取“include”所指定的文件。</li>
</ol>
<h2 id="变量MAKEFILE-LIST"><a href="#变量MAKEFILE-LIST" class="headerlink" title="变量MAKEFILE_LIST"></a>变量MAKEFILE_LIST</h2><p>&emsp;&emsp;make程序在读取多个makefile文件时，包括由环境变量“MAKEFILES”指定的、命令行指定的、当前工作目录下的默认的以及使用指示符“include”指定包含的，在对这些文件进行解析执行之前make读取的文件名将会被自动依次追加到变量“MAKEFILE_LIST”的定义域中。</p>
<h2 id="其他特殊变量"><a href="#其他特殊变量" class="headerlink" title="其他特殊变量"></a>其他特殊变量</h2><p>&emsp;&emsp;GNU make支持一个特殊的变量，此变量不能通过任何途径给它赋值。它被展开为一个特定的值。一个重要的特殊变量是“.VARIABLES”。它被展开以后是此引用点之前、makefile文件中所定义的所有全局变量列表。包括：空变量（未赋值的变量）和make的内嵌变量，但不包括目标指定的变量。</p>
<h2 id="makefile文件的重建"><a href="#makefile文件的重建" class="headerlink" title="makefile文件的重建"></a>makefile文件的重建</h2><p>&emsp;&emsp;Makefile可由其他文件生成，例如RCS或SCCS文件。如果makefile由其他文件重建，那么在make开始解析这个makefile时需要重新读取更新后的makefile，而不是之前的makefile。make的处理过程是这样的：</p>
<p>&emsp;&emsp;make在读取所有makefile文件后，首先将所读取的每个makefile作为一个目标，寻找更新它们的规则。如果存在一个更新某一个makefile文件的明确规则或者隐含规则，就去更新对应的makefile文件。完成对所有的makefile文件的更新之后，如果之前所读取任何一个makefile文件被更新，那么make就清除本次执行的状态重新读取一遍所有的makefile文件（此过程中，同样在读取完成以后也会去试图更新所有的已经读取的makefile文件，但是一般这些文件不会再次被重建，因为它们在时间戳上已经是最新的了）。读取完成以后再开始解析已经读取的makefile文件并开始执行必要的动作。</p>
<p>&emsp;&emsp;实际应用中，我们会明确给出makefile文件，而并不需要来由make自动重建它们。但是make在每一次执行时总会自动地试图重建那些已经存在的makefile文件，如果需要处于效率考虑，可以采用一些办法来避免make在执行过程中查找重建makefile的隐含规则。例如我们可以书写一个明确的规则，以makefile文件作为目标，规则的命令定义为空。</p>
<p>&emsp;&emsp;makefile规则中，如果使用一个没有依赖只有命令行的双冒号规则去更新一个文件，那么每次执行make时，此规则的目标文件将会被无条件更新（此规则定义的命令会被无条件执行）。如果这样一个规则的目标是makefile文件，那么执行make时，这个makefile文件就会被无条件更新，而使得make的执行陷入到一个死循环（此makefile文件被不断的更新、重新读取、更新再重新读取的过程）。为了防止这种情况的发生，make在遇到一个目标是makefile文件的双冒号规则时，将忽略这个规则的执行</p>
<h2 id="make如何解析makefile文件"><a href="#make如何解析makefile文件" class="headerlink" title="make如何解析makefile文件"></a>make如何解析makefile文件</h2><p>&emsp;&emsp;GNU make的执行过程分为两个阶段：</p>
<ol>
<li>第一阶段：读取所有的makefile文件（包括“MAKEFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f（–file）”指定的makefile文件），内建所有的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。</li>
<li>第二阶段：根据第一阶段已经建立好的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</li>
</ol>
<h1 id="make的执行过程如下"><a href="#make的执行过程如下" class="headerlink" title="make的执行过程如下"></a>make的执行过程如下</h1><ol>
<li>依次读取变量“MAKEFILES”定义的makefile文件列表</li>
<li>读取工作目录下的makefile文件</li>
<li>依次读取工作目录makefile文件中使用指示符“include”包含的文件</li>
<li>查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile，完成以后从第一步重新开始执行）</li>
<li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li>
<li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</li>
<li>执行除“终极目标”以外其他目标的依赖关系建立依赖关系链表</li>
<li>执行“终极目标”所在的规则</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>别让异常逃离析构函数</title>
    <url>/2020/07/23/%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h1><p>&emsp;&emsp;C++并不禁止析构函数吐出异常，但它不鼓励我们这样做。这是有理由的。考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~Widget() &#123; ... &#125;  <span class="comment">//假设这个可能吐出一个异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;                      <span class="comment">//v在这里被自动销毁</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当vector v被销毁，它有责任销毁其内含的所有Widgets。假设v内含十个Widgets，而在析构第一个元素期间，有个异常被抛出。其他九个Widgets还是应该被销毁（否则它们保存的任何资源都会发生泄漏），因此v应该调用它们各个析构函数。但假设在那些调用期间，第二个Widget析构函数又抛出异常。现在有两个同时作用的异常，这对C++而言太多了。在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确的行为。本例中它会导致不明确的行为。使用标准程序库的任何其他容器或TR1的任何容器或甚至array，也会出现相同情况。只要析构函数吐出异常，即使并非使用容器或array，程序也可能过早结束或出现不明确行为。没错，C++不喜欢析构函数吐出异常！</p>
<p>&emsp;&emsp;这很容易理解，但如果我们的析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，该怎么办？举个例子，假设我们使用一个class负责数据库连接：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;  <span class="comment">//这个函数返回DBConnection对象；</span></span><br><span class="line">                                   <span class="comment">//为求简化暂略参数。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;                  <span class="comment">//关闭联机；失败则抛出异常。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为确保客户不忘记在DBConnection对象身上调用close()，一个合理的想法是创建一个用来管理DBConnection资源的class，并在其析构函数中调用close：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span>    <span class="comment">//这个class用来管理DBConnection对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~DBConn() &#123;   <span class="comment">//确保数据库连接总是会被关闭</span></span><br><span class="line">      db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnetion db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这便允许客户写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;                                    <span class="comment">//开启一个区块</span></span><br><span class="line"><span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;  <span class="comment">//建立DBConnection对象</span></span><br><span class="line">                                     <span class="comment">//  并交给DBConn对象以便管理。</span></span><br><span class="line">...                                  <span class="comment">//通过DBConn的接口</span></span><br><span class="line">                                     <span class="comment">//  使用DBConnection对象。</span></span><br><span class="line">&#125;                                    <span class="comment">//在区块结束点，DBConn对象被销毁，</span></span><br><span class="line">                                     <span class="comment">//因而自动为DBConnection对象调用close。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只要调用close成功，一切都美好。但是如果该调用导致异常，DBConn析构函数会传播该异常，也就是允许它离开这个析构函数。这会造成问题，因为这就是抛出了难以驾驭的麻烦。</p>
<p>&emsp;&emsp;两个办法可以避免这一问题。DBConn的析构函数可以：</p>
<ul>
<li>如果close抛出异常就结束程序。通常通过调用abort完成：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败；</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果程序遭遇一个“于析构期间发生的错误”后无法继续执行，“强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数传播出去。也就是说调用abort可以抢先置“不明确行为”于死地。</p>
<ul>
<li>吞下因调用close而发生的异常：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125; </span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般而言，将异常吞掉是个坏主意，因为它压制了“某些动作失败”的重要信息！然而有时候吞下异常也比负担“草率结束程序”或“不明确行为带来的风险”好。为了让这成为一个可行方案，程序必须能够继续可靠地执行，即使在遭遇并忽略一个错误之后。</p>
<p>&emsp;&emsp;这些办法都没什么吸引力。问题在于两者都无法对“导致close抛出异常”的情况做出反应。</p>
<p>&emsp;&emsp;一个较佳策略是重新设计DBConn接口，使其客户有机会对可能出现的问题做出反应。例如DBConn自己可以提供一个close函数，因而赋予客户一个机会得以处理“因该操作而发生的异常”。DBConn也可以追踪其所管理的DBConnection是否已被关闭，并在答案为否的情况下由其析构函数关闭之。这可防止遗失数据库连接。然而如果DBConnection析构函数调用close失败，我们将又退回“强迫结束程序”或“吞下异常”的老路：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;  <span class="comment">//供客户使用的新函数</span></span><br><span class="line">       db.<span class="built_in">close</span>();</span><br><span class="line">       closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn() &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  <span class="comment">//关闭连接（如果客户不那么做的话）</span></span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">                <span class="comment">//制作运转记录，记下对close的调用失败；</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;把调用close的责任从DBConn析构函数手上移到DBConn客户手上（但DBConn析构函数内仍内含一个“双保险”调用）可能会给我们“肆无忌惮转移负担”的印象。实际上在这里并无大碍。如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。本例要说的是，由客户自己调用close并不会对他们带来负担，而是给他们一个处理错误的机会，否则他们没机会响应。如果他们不认为这个机会有用（或许他们坚信不会有错误发生），可以忽略它，依赖DBConn析构函数去调用close。</p>
<blockquote>
<p>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p>
<p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>在operator=中处理“自我赋值”</title>
    <url>/2020/07/25/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D/</url>
    <content><![CDATA[<hr>
<h1 id="在operator-中处理“自我赋值”"><a href="#在operator-中处理“自我赋值”" class="headerlink" title="在operator=中处理“自我赋值”"></a>在operator=中处理“自我赋值”</h1><p>&emsp;&emsp;“自我赋值”发生在对象被赋值给自己时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;  <span class="comment">//赋值给自己</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这看起来有点愚蠢，但它合法，所以不要认定客户绝不会那么做。此外赋值动作并不总是那么可被一眼识别出来，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[i] = a[j];  <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果i和j有相同的值，这便是个自我赋值。再看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*px = *py;  <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果px和py恰巧指向同一个东西，这也是自我赋值。这些并不明显的自我赋值，是“别名”带来的结果：所谓“别名”就是“有一个以上的方法指涉某对象”。一般而言如果某段代码操作pointer或reference而它们被用来“指向多个相同类型的对象”，就需要考虑这些对象是否为同一个。实际上两个对象只要来自同一个继承体系，它们甚至不需声明为相同类型就可能造成“别名”，因为一个base class的reference或pointer可以指向一个derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> Base&amp; rb, Derived* pd)</span></span>;  <span class="comment">//rb和*pd有可能其实是同一对象</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果我们尝试自行管理资源（如果我们打算写一个勇于资源管理的class就得这样做），可能会在停止使用资源之前就意外释放了它。假设我们建立一个class用来保存一个指针指向动态分配的位图（bitmap）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;  <span class="comment">//指针，指向一个从heap分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面是operator=实现代码，表面上看起来合理，但自我赋值出现时并不安全（它也不具备异常安全性）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//一份不安全的operator=实现版本</span></span><br><span class="line">    <span class="keyword">delete</span> pb;                          <span class="comment">//停止使用当前的Bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);           <span class="comment">//使用rhs的bitmap的副本</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的自我赋值问题是，operator=函数内的*this（赋值的目的端）和rhs有可能是同一个对象。果真如此delete就不只是销毁当前对象的bitmap，它也销毁rhs的bitmap。在函数末尾，Widget——它原本不该被自我赋值动作改变的——发现自己持有一个指针指向一个已被删除的对象！</p>
<p>&emsp;&emsp;欲阻止这种错误，传统做法是藉由operator=最前面的一个“证同测试”达到“自我赋值”的检测目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//证同测试：如果是自我赋值，就不做任何事</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样做行得通。前一版本的operator=不仅不具备“自我赋值安全性”，也不具备“异常安全性”，这个新版本仍然存在异常方面的麻烦。更明确地说，如果“new Bitmap”导致异常，Widget最终会持有一个指针指向一块被删除的Bitmap。这样的指针有害。我们无法安全地删除它们，甚至无法安全地读取它们。</p>
<p>&emsp;&emsp;令人高兴的是，让operator=具备“异常安全性”往往自动获得“自我赋值安全”的回报。因此越来越多的人对“自我赋值”的处理态度是倾向于不去管它，把焦点放在实现“异常安全性”上。例如以下代码，我们只需注意在复制pb所指东西之前别删除pb：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap* pOrig = pb;        <span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);  <span class="comment">//令pb指向*pb的一个副本</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;              <span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，如果“new Bitmap”抛出异常，pb（及其栖身的那个Widget）保持原状。即使没有证同测试，这段代码还是能够处理自我赋值，因为我们对原bitmap做了一份复件、删除原bitmap、然后指向新制造的那个复件。它或许不是处理“自我赋值”的最高效办法，但它行得通。</p>
<p>&emsp;&emsp;如果你很关心效率，可以把“证同测试”再次放回函数起始处。然而这样做，我们得先问问自己，“自我赋值”的发生概率有多高？因为这项测试也需要成本。它会使代码变大一些并导入一个新的控制流分支，而两者都会降低执行速度。Prefetching、caching和pipelining等指令的效率都会因此降低。</p>
<p>&emsp;&emsp;在operator=函数内手工排列语句（确保代码不但“异常安全”而且“自我赋值安全“）的一个替代方案是，使用所谓的copy and swap技术。这个技术和“异常安全性”有密切关系。然而由于它是一个常见而够好的operator=撰写办法，所以值得看看其实现手法像什么样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;  <span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Widget temp(rhs);        <span class="comment">//为rhs数据制作一份复件</span></span><br><span class="line">    swap(temp);              <span class="comment">//将*this数据和上述复件的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以下代码是上述代码的变奏曲：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs) &#123;  <span class="comment">//rhs是被传对象的一份复件</span></span><br><span class="line">    swap(rhs);                           <span class="comment">//将*this的数据和复件的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我个人比较担忧这个做法，它为了“巧妙性”而牺牲了“清晰性”。然而将“copying动作”从函数本体内移至“函数参数构造阶段”却可令编译器有时生成更高效的代码。</p>
<blockquote>
<p>确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</p>
<p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>在资源管理类中小心copying行为</title>
    <url>/2020/07/28/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<hr>
<h1 id="在资源管理类中小心copying行为"><a href="#在资源管理类中小心copying行为" class="headerlink" title="在资源管理类中小心copying行为"></a>在资源管理类中小心copying行为</h1><p>&emsp;&emsp;并非所有资源都是heap-based，对这种资源而言，像shared_ptr这样的智能指针往往不适合作为资源管理者。既然如此，有可能偶尔我们会发现，我们需要建立自己的资源管理类。</p>
<p>&emsp;&emsp;例如，假设我们使用C API函数处理类型为Mutex的互斥器对象，共有lock和unlock两函数可用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;  <span class="comment">//锁定pm所指的互斥器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;  <span class="comment">//将互斥器解除锁定</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为确保绝不会忘记将一个被锁住的Mutex解锁，我们可能会希望建立一个class用来管理机锁。这样的class的基本结构由RAII（Resource Acquisition Is Initialization）“资源取得时机便是初始化时机”守则支配，也就是“资源在构造期间获得，在析构期间释放”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span>: <span class="title">mutexPtr</span><span class="params">(pm)</span> </span>&#123;  <span class="comment">//获得资源</span></span><br><span class="line">       lock(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Lock() &#123; unlock(mutexPtr); &#125;  <span class="comment">//释放资源</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex* mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;客户对Lock的用法符合RAII方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;      <span class="comment">//定义我们需要的互斥器</span></span><br><span class="line">...</span><br><span class="line">&#123;             <span class="comment">//建立一个区块用来定义critiacl section</span></span><br><span class="line"><span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;  <span class="comment">//锁定互斥器</span></span><br><span class="line">...           <span class="comment">//执行critical section内的操作</span></span><br><span class="line">&#125;             <span class="comment">//在区块最末尾，自动解除互斥器锁定</span></span><br></pre></td></tr></table></figure>

<p>&emsp;这很好，但如果Lock对象被复制，会发生什么事？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;   <span class="comment">//锁定m</span></span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>;  <span class="comment">//将ml1复制到ml2身上，这会发生什么事？</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是某个一般化问题的特定例子。那个一般化问题是每一个RAII class作者一定需要面对的：“当一个RAII对象被复制，会发生什么事？”大多数时候我们会选择以下两种可能：</p>
<ul>
<li><p><strong>禁止复制</strong>。许多时候允许RAII对象被复制并不合理。对一个像Lock这样的class这是有可能的，因为很少能够合理拥有“同步化基础器物”的副本。如果复制动作对RAII class并不合理，我们便应该禁止它。将copyin操作声明为private。对Lock而言看起来是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>:</span> <span class="keyword">private</span> Uncopyable &#123;  <span class="comment">//禁止复制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对底层资源祭出“引用计数法”</strong>。有时候我们希望保有资源，直到它对最后一个使用者（某对象）被销毁。这种情况下复制RAII对象时，应该将资源的“被引用数”递增。shared_ptr便是如此。</p>
<p>&emsp;&emsp;通常只要内含一个shared_ptr成员变量，RAII class便可实现出上述行为。它可以改变mutexPtr的类型，将它从Mutex*改为shared_ptr&lt;Mutex&gt;。然而很不幸shared_ptr的缺省行为是“当引用次数为0时删除其所指物”，这不是我们想要的行为。当我们用上一个Mutex，我们想要做的释放动作是解除锁定而非删除。</p>
<p>&emsp;&emsp;幸运的是shared_ptr允许指定所谓的“删除器”，这是一个函数或函数对象，当引用次数为0时便可被调用。删除器对shared_ptr构造函数而言是可有可无的第二参数，所以代码看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span>: <span class="title">mutexPtr</span><span class="params">(pm, unlock)</span> </span>&#123;</span><br><span class="line">        lock(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;  <span class="comment">//以某个Mutex初始化shared_ptr并以unlock函数为删除器</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;  <span class="comment">//使用shared_ptr替换raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本例的Lock class不再声明析构函数。因为没有必要。class析构函数（无论是编译器生成的，或用户自定的）会自动调用其non-static成员变量（本例为mutexPtr）的析构函数。而mutexPtr的析构函数会在互斥器的引用次数为0时自动调用shared_ptr的删除器（本例为unlock）。</p>
</li>
<li><p><strong>复制底部数据</strong>。有时候，只要我们喜欢，可以针对一份资源拥有其任意数量的副本。而我们需要“资源管理类”的唯一理由是，当我们不再需要某个复件时确保它被释放。在此情况下复制资源管理对象，应该同时也复制其所包含的资源。也就是说，复制资源管理对象时，进行的是“深度拷贝”。</p>
<p>&emsp;&emsp;某些标准字符串类型是由“指向heap内存”的指针构成。这种字符串对象内含一个指针指向一块heap内存。当这样一个字符串对象被复制，不论指针或其所指内存都会被制作出一个复件，这样的字符串展现出深度复制行为。</p>
</li>
<li><p><strong>转移底部资源的拥有权</strong>。某些罕见场合下我们可能希望确保永远只有一个RAII对象指向一个未加工资源，即使RAII对象被复制依然如此。此时资源的拥有权会从被复制物转移到目标物。</p>
</li>
</ul>
<blockquote>
<p>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p>
<p>普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法。不过其他行为也都可能被实现。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>在资源管理类中提供对原始资源的访问</title>
    <url>/2020/07/29/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<hr>
<h1 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h1><p>&emsp;&emsp;资源管理类很棒。它们是你对抗资源泄漏的堡垒。排除此等泄漏是良好设计系统的根本性质。在一个完美世界中我们将依赖这样的class来处理和资源之间的所有互动，而不是玷污双手直接处理原始资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//使用智能指针保存factory函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;                    <span class="comment">//返回投资天数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days = daysHeld(pInv);                             <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;dayHelds需要的是Investment*指针，我们传给它的却是个类型为std::shared_ptr&lt;Investment&gt;的对象。</p>
<p>&emsp;&emsp;这时候我们需要一个函数可将RAII class对象转换为其所内含的原始资源。有两个做法可以达成目标：显式转换和隐式转换。</p>
<p>&emsp;&emsp;shared_ptr提供一个get成员函数，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> days = daysHeld(pInv.<span class="built_in">get</span>());  <span class="comment">//将pInv内的原始指针传给daysHeld</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;shared_ptr重载了指针取值操作符（operator-&gt;和operator*），它们允许隐式转换至底部原始指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;                       <span class="comment">//factory函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pi</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//令指针指针管理一笔资源</span></span><br><span class="line"><span class="keyword">bool</span> taxable1 = !(pi-&gt;isTaxFree());                  <span class="comment">//经由operator-&gt;访问资源</span></span><br><span class="line"><span class="keyword">bool</span> taxable2 = !((*pi).isTaxFree());                <span class="comment">//经由operator*访问资源</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;再考虑下面这个用语字体的RAII class（对C API而言字体是一种原生数据结构）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;  <span class="comment">//这是个C API，为求简化省略参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>;  <span class="comment">//来自同一组C API</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span>: <span class="title">f</span><span class="params">(fh)</span> </span>&#123;&#125;</span><br><span class="line">    ~Font() &#123; releaseFont(f); &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;假设有大量与字体相关的C API，它们处理的是FontHandle，那么“将Font对象转换为FontHandle”会是一种很频繁的需求。Font class可为此提供一个显式转换函数，像get那样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;  <span class="comment">//显式转换函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不幸的是这使得客户每当想要使用API时就必须调用get：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeFontSize</span><span class="params">(FontHandle f, <span class="keyword">int</span> newSize)</span></span>;  <span class="comment">//C API</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="keyword">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line">changeFontSize(f.<span class="built_in">get</span>(), newFontSize);  <span class="comment">//显式地将Font转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;某些程序员可能会认为，如此这般地到处要求显式转换，足以使人们倒尽胃口，不再愿意使用这个class，从而增加了泄漏字体的可能性，而Font class的主要设计目的就是为了防止资源（字体）泄漏。</p>
<p>&emsp;&emsp;另一个办法是令Font提供隐式转换函数，转型为FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">//隐式转换函数</span></span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//另外一种构造转换函数，与隐式转换函数相反，</span></span><br><span class="line">    <span class="comment">//是将其他类型转换为本类型，其也是构造函数的一种。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这使得客户调用C API时比较轻松且自然：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="keyword">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line">changeFontSize(f, newFontSize);  <span class="comment">//将Font隐式转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是这个隐式转换会增加错误发生机会。例如客户可能会在需要Font时意外创建一个FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f1</span><span class="params">(getFont())</span></span>;</span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1;</span><br><span class="line"><span class="comment">//原意是要拷贝一个Font对象，</span></span><br><span class="line"><span class="comment">//却反而将f1隐式转换为其底部的FontHandle</span></span><br><span class="line"><span class="comment">//然后才复制它。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;是否该提供一个显式转换函数（例如get成员函数）将RAII class转换为其底部资源，或是应该提供隐式转换，答案主要取决于RAII class被设计执行的特性工作，以及它被使用的情况。</p>
<p>&emsp;&emsp;RAII class并不是为了封装某物而存在的；它们的存在是为了确保一个特殊行为——资源释放——会发生。此外也有某些RAII class结合十分松散的底层资源封装，借以获得真正的封装实现。例如shared_ptr将它的所有引用计数机构封装了起来，但还是让外界很容易访问其所内含的原始指针。就像多数设计良好的class一样，它隐藏了客户不需要看的部分，但备妥客户需要的所有东西。</p>
<blockquote>
<p>API往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理的资源”的办法。</p>
<p>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>将文件间的编译依存关系降至最低</title>
    <url>/2020/08/13/%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E/</url>
    <content><![CDATA[<hr>
<h1 id="将文件间的编译依存关系降至最低"><a href="#将文件间的编译依存关系降至最低" class="headerlink" title="将文件间的编译依存关系降至最低"></a>将文件间的编译依存关系降至最低</h1><p>&emsp;&emsp;假设你对C++程序的某个class实现文件做了些轻微修改。注意，修改的不是class接口，而是实现，而且只改private成分。然后重新建置这个程序，并预计只花数秒就好。毕竟只有一个class被修改。你按下“Build”按钮或键入make（或其它类似命令），然后大吃一惊，然后感到困惑，因为你意识到整个世界都被重新编译和连接了！当这种事情发生，难道你不气恼吗？</p>
<p>&emsp;&emsp;问题出在C++并没有把“将接口从实现中分离”这事做得很好。class的定义式不只详细描述了class接口，还包括十足的实现细目。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">           <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> cosnt</span>;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的class Person无法通过编译——如果编译器没有取得其实现代码所用到的class string，Date和Address的定义式。这样的定义式通常由#include指示符提供，所以Person定义式的最上方很可能存在这样的东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不幸的是，这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其它头文件有任何改变，那么每一个含入Person class的文件就得重新编译，任何使用Person class的文件也必须重新编译。这样的连串编译依存关系会对许多项目造成难以形容的灾难。</p>
<p>&emsp;&emsp;你或许会奇怪，为什么C++坚持将class的实现细目置于class定义式中？为什么不这样定义Person，将实现细目分开叙述？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span>;</span>   <span class="comment">//前置声明（不正确，详下）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>     <span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span>  <span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">           <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果可以那么做，Person的客户就只需要在Person接口被修改过时才重新编译。</p>
<p>&emsp;&emsp;这个想法存在两个问题。第一，string不是个class，它是个typedef（定义为basic_string&lt;char&gt;）。因此上述针对string而做的前置声明并不正确；正确的前置声明比较复杂，因为涉及额外的template。然而那并不要紧，因为你本来就不该尝试手工声明一部分标准程序库。你应该仅仅使用适当的#include完成目的。标准头文件不太可能成为编译器瓶颈，特别是如果你的建置环境允许你使用预编译头文件。如果解析标准头文件真的是个问题，你可能需要改变你的接口设计，避免使用标准程序库中“引发不受欢迎之#include”那一部分。</p>
<p>&emsp;&emsp;关于“前置声明每一件东西”的第二个（同时也是比较重要的）困难是，编译器必须在编译期间知道对象的大小。考虑这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;               <span class="comment">//定义一个int</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">( params )</span></span>;  <span class="comment">//定义一个Person</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译器看到x的定义式，它知道必须分配多少内存（通常位于stack内）才够持有一个int。没问题，每个编译器都知道一个int有多大。当编译器看到p的定义式，它也知道必须分配足够空间以放置一个Person，但它如何知道一个Person对象有多大呢？编译器获得这项信息的唯一办法就是询问class定义式。然而如果class定义式可以合法地不列出实现细目，编译器如何知道该分配多少空间？</p>
<p>&emsp;&emsp;此问题在Java等语言上并不存在，因为当我们以那种语言定义对象时，编译器只分配足够空间给一个指针（用以指向该对象）使用。也就是说它们将上述代码视同这样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;      <span class="comment">//定义一个int</span></span><br><span class="line">    Person* p;  <span class="comment">//定义一个指针指向Person对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这当然也是合法的C++代码，所以你也可以自己玩玩“将对象实现细目隐藏于一个指针背后”的游戏。针对Person我们可以这样做：把Person分割为两个class，一个只提供接口，另一个负责实现该接口。如果负责实现的那个所谓implementation class取名为PersonImpl，Person将定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  //标准程序库组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span>  <span class="comment">//Person实现类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>        <span class="comment">//Person接口用到的class的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">           <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;  <span class="comment">//指针，指向实现物</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这里，main class（Person）只内含一个指针成员（这里使用shared_ptr），指向其实现类。这般设计常被称为pimpl idiom。这种class内的指针名称往往就是pImpl，就像上面代码那样。</p>
<p>&emsp;&emsp;这样的设计之下，Person的客户就完全与Date，Address以及Person的实现细目分离了。那些class的任何实现修改都不需要Person客户端重新编译。此外由于客户无法看到Person的实现细目，也就不可能写出什么“取决于那些细目”的代码。这真正是“接口与实现分离”！</p>
<p>&emsp;&emsp;这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其它文件内的声明式（而非定义式）相依。其它每一件事都源自于这个简单的设计策略：</p>
<ul>
<li><p><strong>如果使用object reference或object pointer可以完成任务，就不要使用object</strong>。你可以只靠一个类型声明式就 定义出指向该类型的reference和pointer；但如果定义某类型的object，就需要用到该类型的定义式。</p>
</li>
<li><p><strong>如果能够，尽量以class声明式替换class定义式</strong>。注意，当你声明一个函数而它用到某个class时，你并不需要该class的定义式；纵使函数以by value方式传递该类型的参数（或返回值）亦然：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，pass-by-value一般而言是个糟糕的注意（见“<a href="/2020/08/01/%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/" title="宁以pass-by-reference-to-const替换pass-by-value">宁以pass-by-reference-to-const替换pass-by-value</a>”），但如果你发现因为某些因素被迫使用它，并不能够就此为“非必要之编译依存关系”导入正当性。</p>
<p>&emsp;&emsp;声明today函数和clearAppointments函数而无需定义Date，这种能力可能会令你惊讶，但它并不是真的那么神奇。一旦任何人调用那些函数，调用之前Date定义式一定得先曝光才行。那么或许你会纳闷，何必费心声明一个没人调用的函数呢？嗯，并非没人调用，而是并非每个人都调用。假设你有一个函数库内含数百个函数声明，不太可能每个客户叫遍每一个函数。如果能够将“提供class定义式”的义务从“函数声明所在”之头文件转移到“内含函数调用”之客户文件，便可将“并非真正必要之类型定义”与客户端之间的编译依存性去除掉。</p>
</li>
<li><p><strong>为声明式和定义式提供不同的头文件</strong>。为了促进严守上述准则，需要两个头文件，一个用于声明式，一个用于定义式。当然，这些文件必须保持一致性，如果有个声明式被改变了，两个文件都得改变。因此程序库客户应该总是#include一个声明文件而非前置声明若干函数，程序库作者也应该提供这两个头文件。举个例子，Date的客户如果希望声明today和clearAppointments，他们不该像先前那样以手工方式前置声明Date，而是应该#include适当的、内含声明式的头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"datefwd.h"</span>  <span class="comment">//这个头文件内声明（但未定义）class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;         <span class="comment">//同前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只含声明式的那个头文件名为“datefwd.h”，命名方式取法C++标准程序库头文件的&lt;iosfwd&gt;。&lt;iosfwd&gt;内含iostream各组件的声明式，其对应定义则分布在若干不同的头文件内，包括&lt;sstream&gt;，&lt;streambuf&gt;，&lt;fstream&gt;和&lt;iostream&gt;。</p>
<p>&emsp;&emsp;&lt;iosfwd&gt;深具启发意义的另一个原因是，它分外彰显“本条款适用于template也适用于non-template”。虽然“<a href="/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/" title="透彻了解inlining的里里外外">透彻了解inlining的里里外外</a>”说过，在许多建置环境中template定义式通常被置于头文件内，但也有些建置环境允许template定义式放在“非头文件”内，这么一来就可以将“只含声明式”的头文件提供给template。&lt;iosfwd&gt;就是这样一份头文件。</p>
<p>&emsp;&emsp;C++也提供关键字export，允许将template声明式和template定义式分割于不同的头文件内。不幸的是支持这个关键字的编译器目前非常少，因此现实中使用这个关键字的经验也非常少。目前若要评论export在高效C++编程中扮演什么角色，恐怕言之过早。</p>
</li>
</ul>
<p>&emsp;&emsp;像Person这样使用pimpl idiom的class，往往被称为Handle class。也许你会纳闷，这样的class如何真正做点事情。办法之一是将它们的所有函数转交给相应的实现类并由后者完成实际工作。例如下面是Person两个成员函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span>  <span class="comment">//我们正在实现Person class，</span></span></span><br><span class="line">                     <span class="comment">//所以必须#include其class定义式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PersonImpl.h"</span>  <span class="comment">//我们也必须#include PersonImpl的</span></span></span><br><span class="line">                         <span class="comment">//class定义式，否则无法调用其成员函数；</span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr)</span><br><span class="line">  : pImpl(<span class="keyword">new</span> PersonImpl(name, birhday, addr)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Person::name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;请注意，Person构造函数以new调用PersonImpl构造函数，以及Person::name函数内调用PersonImpl::name。这是很重要的，让Person变成一个Handle class并不会改变它做的事，只会改变它做事的方法。</p>
<p>&emsp;&emsp;另一个制作Handle class的办法是，令Person成为一种特殊的abstract base class（抽象基类），称为interface class。这种class的目的是详细一一描述derived class的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口。</p>
<p>&emsp;&emsp;interface class类似Java的interface，但C++的interface class并不需要负担Java的interface所需负担的责任。举个例子，Java不允许在interface内实现成员变量或成员函数，但C++不禁止这两样东西。C++这种更巨大的弹性有其用途，“non-virtual函数的实现”对继承体系内的所有class都应该相同，所以将此等函数实现为interface class的一部分也是合理的。</p>
<p>&emsp;&emsp;一个针对Person而写的interface class或许看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个class的客户必须以Person的pointer和reference来撰写应用程序，因为它不可能针对“内含pure virtual函数”的Person class具现出实体。（然而却有可能对派生自Person的class具现出实体）就像Handle class的客户一样，除非interface class的接口被修改否则其客户不需重新编译。</p>
<p>&emsp;&emsp;interface class的客户必须有办法为这种class创建对象。他们通常调用一个特殊函数，此函数扮演“真正将被具现化”的那个derived class的构造函数角色。这样的函数通称为factory函数或virtual构造函数。它们返回指针（或更为可取的智能指针），指向动态分配所得对象，而该对象支持interface class的接口。这样的函数又往往在interface class内被声明为static：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt;</span><br><span class="line">      create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">             <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">             <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>客户会这样使用它们：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//创建一个对象，支持Person接口</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pp-&gt;name  <span class="comment">//通过Person的接口使用这个对象</span></span><br><span class="line">          &lt;&lt; <span class="string">" was born on "</span></span><br><span class="line">          &lt;&lt; pp-&gt;birthDate()</span><br><span class="line">          &lt;&lt; <span class="string">" and now lives at"</span></span><br><span class="line">          &lt;&lt; pp-&gt;address();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，支持interface class接口的那个具象类必须被定义出来，而且真正的构造函数必须被调用。一切都在virtual构造函数实现码所在的文件内秘密发生。假设interface class Person有个具象的derived class RealPerson，后者提供继承而来的virtual函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr)</span><br><span class="line">      : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了RealPerson之后，写出Person::create就真的一点也不稀奇了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> Address&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一个更现实的Person::create实现代码会创建不同类型的derived class对象，取决于诸如额外参数值、读自文件或数据库的数据、环境变量等等。</p>
<p>&emsp;&emsp;RealPerson示范实现interface class的两个最常见机制之一：从interface class（Person）继承接口规格，然后实现出接口所覆盖的函数。interface class的第二个实现算法涉及多重继承。</p>
<p>&emsp;&emsp;handle class和interface class解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性。</p>
<p>&emsp;&emsp;在handle class身上，成员函数必须通过implementation pointer取得对象数据。那会为每一次访问增加一层间接性。而每一个对象消耗掉的内存数量必须增加implementation pointer的大小。最后，implementation pointer必须初始化（在handle class构造函数内），指向一个动态分配得来的implementation object，所以你将蒙受因动态内存分配（及其后的释放动作）而来的额外开销，以及遭遇bad_alloc异常（内存不足）的可能性。</p>
<p>&emsp;&emsp;至于interface class，由于每个函数都是virtual，所以你必须为每次函数调用付出一个间接跳跃成本（见“<a href="/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" title="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</a>”）。此外interface class派生的对象必须内含一个vptr（再次见“<a href="/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" title="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</a>”），这个指针可能会增加存放对象所需的内存数量——实际取决于这个对象除了interface class之外是否还有其他virtual函数来源。</p>
<p>&emsp;&emsp;最后，不论handle class或interface class，一旦脱离inline函数都无法有太大作为。“<a href="/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/" title="透彻了解inlining的里里外外">透彻了解inlining的里里外外</a>”解释过为什么函数本体为了被inlined必须（很典型地）置于头文件内，但handle class和interface class正是特别被设计用来隐藏实现细节如函数本体。</p>
<p>&emsp;&emsp;然而，如果只因为若干额外成本便不考虑handle class和interface class，将是严重的错误。virtual函数不也带来成本吗？你并不会想要弃绝它们对不对？你应该考虑以渐近方式使用这些技术。在程序开发过程中使用handle class和interface class以求实现码有所变化时对客户带来最小冲击。而当它们导致速度和大小差异过于重大以至于class之间的耦合相形之下不成为关键时，就以具象类替换handle class和interface class。</p>
<blockquote>
<ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是handle class和interface class。</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及template都适用。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>复制对象时勿忘其每一个成分</title>
    <url>/2020/07/26/%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86/</url>
    <content><![CDATA[<hr>
<h1 id="复制对象时勿忘其每一个成分"><a href="#复制对象时勿忘其每一个成分" class="headerlink" title="复制对象时勿忘其每一个成分"></a>复制对象时勿忘其每一个成分</h1><p>&emsp;&emsp;设计良好的面向对象系统会将对象的内部封装起来，只留两个函数负责对象拷贝，这便是copy构造函数和copy assignment操作符，称它们为copying函数。</p>
<p>&emsp;&emsp;如果我们声明自己的copying函数，意思就是告诉编译器我们并不喜欢缺省实现中的某些行为，编译器仿佛被冒犯似得，会以一种奇怪的方式回敬：当我们的实现代码几乎必然出错时却不告诉我们。</p>
<p>&emsp;&emsp;考虑一个class用来表现顾客，其中手工写出copying函数，使得外界对它们的调用会被志记（logged）下来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logCall</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; funcName)</span></span>;  <span class="comment">//制造一个log entry</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; rhs): name(rhs.name) &#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy assignment operator"</span>);</span><br><span class="line">    name = rhs.name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的每一件事情都看起来很好，而实际上每件事情也的确都好，直到另一个成员变量加入战局：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span> ... &#125;;  <span class="comment">//日期</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...              <span class="comment">//同前</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Date lastTrasaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时候现有的copying函数执行的是局部拷贝，并没有复制新添加的lastTransaction。大多数编译器对此不会发出任何怨言——即使在最高警告级别中。这是编译器对“我们自己写出copying函数”的报复行为。结论很明显：如果我们为class添加一个成员变量，我们必须同时修改copying函数。如果我们忘记，编译器不太可能提醒我们。</p>
<p>&emsp;&emsp;一旦发生继承，可能会出现一个隐患：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer &#123;  <span class="comment">//一个derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PriorityCustomer（<span class="keyword">const</span> PriorityCustomer&amp; rhs）;</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=（<span class="keyword">const</span> PriorityCustomer&amp; rhs）;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line">PriorityCustomer::PriorityCustomer（<span class="keyword">const</span> PriorityCustomer&amp; rhs）</span><br><span class="line">: priority(rhs.priority) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy assignment operator"</span>);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来PriorityCustomer的copying函数好像复制了其内的每一样东西，但是它所继承的Customer成员变量却并未被复制。PriorityCustomer的copy构造函数并没有指定实参传给其base class构造函数（也就是说它在它的成员初值列中没有提到Customer），因此PriorityCustomer对象的Customer成分会被不带实参的Customer构造函数（即default构造函数）初始化。default构造函数将针对name和lastTransaction执行缺省的初始化动作。</p>
<p>&emsp;&emsp;以上情况在PriorityCustomer的copy assignment操作符身上只有轻微不同。它不曾试图修改其base class的成员变量，所以那些成员变量保持不变。</p>
<p>&emsp;&emsp;任何时候只要我们承担起“为derived class撰写copying函数”的重任，必须很小心地也复制其base class成分。那些成分往往是private，所以无法直接访问它们，我们应该让derived class的copying函数调用相应的base class函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PriorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">: Customer(rhs), priority(rhs.priority) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy assignment operator"</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们编写一个copying函数，请确保（1）复制所有local成员变量，（2）调用所有base class内的适当copying函数。</p>
<p>&emsp;&emsp;如果你发现你的copy构造函数和copy assignment操作符有着相近的代码，消除重复代码的做法是，建立一个新成员函数给两者调用。这样的函数往往是private而且常被命名为init。这个策略可以安全地消除copy构造函数和copy assignment操作符之间的代码重复。</p>
<blockquote>
<p>Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。</p>
<p>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>宁以non-member、non-friend替换member函数</title>
    <url>/2020/08/03/%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="宁以non-member、non-friend替换member函数"><a href="#宁以non-member、non-friend替换member函数" class="headerlink" title="宁以non-member、non-friend替换member函数"></a>宁以non-member、non-friend替换member函数</h1><p>&emsp;&emsp;想象有个class用来表示网页浏览器。这样的class可能提供的众多函数中，有一些用来清除下载元素高速缓存区、清除访问过的URL的历史记录、以及移除系统中的所有cookies：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多用户会想一整个执行所有这些动作，因此WebBrowser也提供这样一个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，这一机能也可由一个non-member函数调用适当的member函数而提供出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.removeCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;那么，哪一个比较好呢？是member函数clearEverything还是non-member函数clearBrowser？</p>
<p>&emsp;&emsp;面向对象守则要求，数据以及操作数据的那些函数应该被捆绑在一块，这意味它建议member函数是好的选择。不幸的是这个建议不正确。这是基于面向对象真实意义的一个误解。面向对象守则要求数据应该尽可能被封装，然而与直观相反地，member函数clearEverything带来的封装性比non-member函数clearBrowser低。此外，提供non-member函数可允许对WebBrowser相关机能有较大的包裹弹性，而那最终导致较低的编译相依度，增加WebBrowser的可延伸性。因此在许多方面non-member做法比member做法好。重要的是，我们必须了解其原因。</p>
<p>&emsp;&emsp;让我们从封装开始讨论。如果某些东西被封装，它就不再可见。越多东西被封装，越少人可以看到它。而越少人看到它，我们就有越大的弹性去改变它，因为我们的改变仅仅直接影响看到改变的那些人事物。因此，越多东西被封装，我们改变那些东西的能力也就越大。这就是我们首先推崇封装的原因：它使我们能够改变事物而只影响有限客户。</p>
<p>&emsp;&emsp;成员变量应该是private，因为如果它们不是，就有无限量的函数可以访问它，它们也就毫无封装性。能够访问private成员变量的函数只有class的member函数加上friend函数而已。如果要你在一个member函数和一个non-member，non-friend函数之间做抉择，而且两者提供相同机能，那么，导致较大封装性的是non-member non-friend函数，因为它并不增加“能够访问class内的private成分”的函数变量。这就解释了为什么clearBrowser比clearEverything更受欢迎的原因：它导致WebBrowser class有较大的封装性。</p>
<p>&emsp;&emsp;在这一点上有两件事情值得注意。第一，这个论述只适用于non-member non-friend函数。friend函数对class private成员的访问权力和member函数相同，因此两者对封装的冲击力道也相同。从封装的角度看，这里的选择关键并不在member和non member函数之间，而是在member和non-member non-friend函数之间。</p>
<p>&emsp;&emsp;第二件值得注意的事情是，只因在意封装性而让函数“成为class的non-member”，并不意味它“不可以是另一个class的member”。这对那些习惯于“所有函数都必须定义于class内”的语言（如Java，C#）的程序员而言，可能是个温暖的慰藉。例如我们可以令clearBrowser成为某工具类的一个static member函数。只要它不是WebBrowser的一部分（或成为其friend），就不会影响WebBrowser的private成员封装性。</p>
<p>&emsp;&emsp;在C++内，比较自然的做法是让clearBrowser成为一个non-member函数并且位于WebBrowser所在的同一个namespace内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然而这不只是为了看起来自然而已。要知道namespace和class不同，前者可跨越多个源码文件而后者不能。这很重要。</p>
<p>&emsp;&emsp;一个像WebBrowser这样的class可能拥有大量便利函数。某些与书签有关，某些与打印有关，还有一些与cookie的管理有关…… 通常大多数客户只对其中某些感兴趣。分离它们的最直接做法就是将书签相关便利函数声明于一个头文件，将cookie相关便利函数声明于另一个头文件，再将打印相关便利函数声明于第三个头文件，以此类推：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件“webbrowser.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span> ... &#125;;</span><br><span class="line">...  <span class="comment">//核心机能，例如几乎所有客户都需要的non-member函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件“webbrowserbookmarks.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">...  <span class="comment">//与书签相关的便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件“webbrowsercookies.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">...  <span class="comment">//与cookie相关的便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这正是C++标准程序库的组织方式。标准程序库并不是拥有单一、整体、庞大的&lt;C++StandardLibrary&gt;头文件并在其中内含std命名空间的每一样东西，而是有数十个头文件，每个头文件声明std的某些机能。如果客户只想使用vector相关机能，他不需要#include &lt;memory&gt;；如果客户不想使用list，也不需要#include&lt;list&gt;。这允许客户只对他们所用的那一小部分系统形成编译相依。以此种方式切割机能并不适用于class成员函数，因为一个class必须整体定义，不能被分割为片片段段。</p>
<p>&emsp;&emsp;将所有便利函数放在多个头文件内但隶属同一个命名空间，意味着客户可以轻松扩展这一组便利函数。他们需要做的就是添加更多non-member non-friend函数到此命名空间内。举个例子，如果某个WebBrowser客户决定写些与影像下载相关的便利函数，他只需在WebBrowserStuff命名空间内建立一个头文件，内含那些函数的声明即可。新函数就像其它旧有的便利函数那样可用且整合为一体。这是class无法提供的另一个性质，因为class定义式对客户而言是不能扩展的。当然啦，客户可以派生出新的class，但derived class无法访问base class中被封装的成员，于是如此的“扩展机能”拥有的只是次级身份。此外，并非所有class都被设计用来作为base class。</p>
<blockquote>
<p>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充行。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>宁以pass-by-reference-to-const替换pass-by-value</title>
    <url>/2020/08/01/%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/</url>
    <content><![CDATA[<hr>
<h1 id="宁以pass-by-reference-to-const替换pass-by-value"><a href="#宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="宁以pass-by-reference-to-const替换pass-by-value"></a>宁以pass-by-reference-to-const替换pass-by-value</h1><p>&emsp;&emsp;缺省情况下C++以by value方式（继承自C的方式）传递对象至（或来自）函数，除非我们另外指定，否则函数参数都是以实际实参的副本为初值，而调用端所获得的亦是函数返回值的一个副本。这些副本是由对象 copy构造函数产出，这可能使得pass-by-value成为昂贵的操作。考虑一下继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person();</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student();</span><br><span class="line">    ~Student();</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> schoolName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> schoolAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑一下代码，其中调用函数validateStudent，后者需要一个Student实参（by value）并返回它是否有效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;  <span class="comment">//以by value方式接受学生</span></span><br><span class="line">Student plato;</span><br><span class="line"><span class="keyword">bool</span> platoIsOk = validateStudent(plato);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当上述函数被调用时，发生什么事？</p>
<p>&emsp;&emsp;无疑地Student的copy构造函数会被调用，以plato为蓝本将s初始化。同样明显地，当validateStudent返回s会被销毁。因此，对此函数而言，参数的传递成本是“一次Student copy构造函数被调用，加上一次Student析构函数被调用”。</p>
<p>&emsp;&emsp;但那还不是整个故事哦。Student对象内有两个string对象，所以每次构造一个Student对象也就构造了两个string对象。此外Student对象继承自Person对象，所以每次构造Student对象也必须构造出一个Person对象。一个Person对象又有两个string对象在其中，因此每一次Person构造动作又需承担两个string构造动作。最终总体成本是“六次构造函数和六次析构函数”！</p>
<p>&emsp;&emsp;要是有什么方法可以回避所有那些构造和析构就太好了。有的！这就是pass by reference-to-const：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种传递方式的效率高得多：没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。修订后的这个参数声明中的const是重要的。原先的validateStudent以by value方式接受一个Student参数，因此调用者知道他们受到保护，函数内绝不会对传入的Student做任何改变；validateStudent只能够对其副本做修改。现在Student以by reference方式传递，将它声明为const是必要的，因为不这样做的话调用者会忧虑validateStudent会不会改变他们传入的那个Student。</p>
<p>&emsp;&emsp;以by reference方式传递参数也可以避免slicing（对象切割）问题。当一个derived class对象以by value方式传递并被视为一个base class对象，base class的copy构造函数会被调用，而“造成此对象的行为像个derived class对象”的那些特化性质全被切割掉了，仅仅留下一个base class对象。这实在不怎么让人惊讶，因为正是base class构造函数建立了它。但这几乎绝不会是我们想要的。假设我们在一组class上工作，用来实现一个图形窗口系统：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//返回窗口名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//显示窗口和其内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowWithScrollBars</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所有Window对象都带有一个名称，你可以通过name函数取得它。所有窗口都可显示，你可以通过display函数完成它。display是个virtual函数，这意味着简单朴素的base class Window对象的显示方式和华丽高贵的WindowWithScrollBars对象的显示方式不同。</p>
<p>&emsp;&emsp;现在假设你希望写个函数打印窗口名称，然后显示该窗口。下面是错误示范：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span> </span>&#123;  <span class="comment">//不正确！参数可能被切割</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; w.name;</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当你调用上述函数并交给它一个WindowWithScrollBars对象，会发生什么事呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WindowWithScrollBars wwsb；</span><br><span class="line">printNameAndDisplay(wwsb);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;参数w会被构造成为一个Window对象；它是passed by value。在printNameAndDisplay函数内不论传递过来的对象原本是什么类型，参数w就像一个Window对象（因为其类型是Window）。因此在printNameAndDisplay内调用display调用的总是Window::display，绝不会是WindowWithScrollBars::display。</p>
<p>&emsp;&emsp;解决切割问题的办法，就是以by reference-to-const的方式传递w：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="keyword">const</span> Window&amp; w)</span> </span>&#123;  <span class="comment">//很好，参数不会被切割</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; w.name();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，传进来的窗口是什么类型，w就表现出那种类型。</p>
<p>&emsp;&emsp;如果窥视C++编译器的底层，我们会发现，reference往往以指针实现出来，因此pass by reference通常意味真正传递的是指针。因此如果我们有个对象属于内置类型（例如int），pass by value往往比pass by reference的效率高些。对内置类型而言，当我们有机会选择采用pass-by-value或pass-by-reference-to-const时，选择pass-by-value并非没有道理。这个忠告也适用于STL对迭代器和函数对象，因为习惯上它们都被设计为passed by value。迭代器和函数对象的实践者有责任看看它们是否高效且不受切割问题的影响。</p>
<p>&emsp;&emsp;一般而言，你可以合理假设“pass-by-value并不昂贵”的唯一对象就是内置类型和STL的迭代器和函数对象。至于其它任何东西都请遵守本条款的忠告，尽量以pass-by-reference-to-const替换pass-by-value。</p>
<blockquote>
<p>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。</p>
<p>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽可能使用const</title>
    <url>/2020/07/18/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</url>
    <content><![CDATA[<hr>
<h1 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h1><p>&emsp;&emsp;关键字const多才多艺。我们可以用它在classes外部修饰global或namespace作用域中的常量，或修饰文件、函数、或区块作用域中被声明为static的对象。我们也可以用它修饰classes内部的static和non-static成员变量。面对指针，我们也可以指出指针自身、指针所指物，或者两者都（或都不）是const：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span>* p = greeting;              <span class="comment">//non-const pointer,non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;        <span class="comment">//non-const pointer,const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;        <span class="comment">//const pointer,non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;  <span class="comment">//const pointer,const data</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;STL迭代器是以指针为根据塑模出来的，所以迭代器的作用就像个T*指针。声明迭代器为const就像声明指针为const一样（即声明一个T&#42;const指针），表示这个迭代器不得指向不同的东西，但它所指的东西的值是可以改动的。如果我们希望迭代器所指的东西不可被改动，我们需要的是const_iterator：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">10</span>;  <span class="comment">//没问题，改变iter所指物</span></span><br><span class="line">++iter;  <span class="comment">//错误！iter是const</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();</span><br><span class="line">*cIter = <span class="number">10</span>;  <span class="comment">//错误！*cIter是const</span></span><br><span class="line">++cIter;  <span class="comment">//没问题，改变cIter</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;const最具威力的用法是面对函数声明时的应用。在一个函数声明式内，const可以和函数返回值、各参数、函数自身（如果是成员函数）产生关联。</p>
<p>&emsp;&emsp;令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。举个例子，考虑有理数的operator&#42;声明式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多程序员第一次看到这个声明时不免斜着眼睛说，为什么返回一个const对象？原因是如果不这样客户就能实现这样的暴行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line">(a * b) = c;  <span class="comment">//在a * b的结果上调用operator=</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我不知道为什么会有人想对两个数值的乘积再做一次赋值，也许只是因为单纯的打字错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a * b = c) ...  <span class="comment">//其实是想做一个比较动作</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果a和b都是内置类型，这样的代码直截了当就是不合法。而一个良好的用户自定义类型的特征是它们避免无端地与内置类型不兼容，因此允许对两值乘积做赋值动作也就没什么意思了。将operator&#42;的回传值声明为const可以预防这个“没意思的赋值动作”，这就是该那么做的原因。</p>
<p>​    &emsp;&emsp;至于const参数，没有什么特别的解释，它们不过就像是local const对象一样，我们应该在必要的时候使用它们。除非我们有改动参数或local对象，否则应该声明为const。只不过多打6个字符，却可以省下烦人的错误，像是“想要键入‘==’却意外键入‘=’”的错误。</p>
<h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><p>&emsp;&emsp;将const用于成员函数的目的，是为了确认该成员函数可作用于const对象身上，这一类成员函数之所以重要，基于两个理由。第一，它们使class接口比较容易被理解。这是因为，得知哪个函数可以改动对象内容而哪个函数不行，非常重要。第二，它们使“操作const对象”成为可能。这是编写高效代码的关键所在，改善C++程序效率的一个根本办法是以pass by reference-to-const方式传递对象，而此技术可行的前提是，我们有const成员函数可用来处理取得（并经修饰而成）的const对象。</p>
<p>&emsp;&emsp;许多人漠视一个事实：两个成员函数如果只是常量性不同，可以被重载。这是一个重要的C++特性。考虑以下class，用来表现大一块文字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>:<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TextBlock的operator[]s可被这么使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"World"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>顺带一提，真实程序中const对象大多用于passed by pointer-to-const或passed by reference-to-const的传递效果。上述的ctb例子太过造作，下面这个比较真实：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> TextBlock&amp; ctb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要注意的是，non-const operator[]的返回类型是个reference to char，不是char。如果operator[]只是返回一个char，下面这样的句子就无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tb[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是因为，如果函数的返回类型是个内置类型，那么改动函数返回值从来就不合法。纵使合法，C++以by value返回对象这一事实意味着被改动的其实是tb.text[0]的一个副本，不是tb.text[0]自身，我们也不会想要这样愚蠢的行为。</p>
<p>&emsp;&emsp;成员函数如果是const意味着什么？这里有两个流行的概念：bitwise constness（又称physical constness）和logical constness。</p>
<p>&emsp;&emsp;bitwise const阵营的人相信，成员函数只有在不更改对象的任何成员变量（static除外）时才可以说是const。也就是说它不更改对象内的任何一个bit。这种论点的好处是很容易侦测违反点：编译器只需寻找成员变量的赋值动作即可。bitwise constess正是C++对常量性的定义，因此const成员函数不可以更改对象内任何non-static成员变量。</p>
<p>&emsp;&emsp;不幸的是许多成员函数虽然不完全具备const性质却能通过bitwise测试。更具体地说，一个更改了“指针所指物”的成员函数虽然不能算是const，但如果只有指针（而非其所指物）隶属于对象，那么可以说此函数为bitwise const不会引起编译器的抗议。这导致反直观结果。假设我们有一个TextBlock-like class，它将数据存储为char&#42;而不是string，因为它需要和一个不认识string对象的C API沟通：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;  <span class="comment">//bitwise const声明</span></span><br><span class="line">        <span class="keyword">return</span> pText[<span class="built_in">position</span>];                     <span class="comment">//但其实不恰当。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个class不适当地将其operator[]声明为const成员函数，而该函数却返回一个reference指向对象内部值。假设暂时不管这个事实，注意，operator[]实现代码并不更改pText。于是编译器很开心地为operator[]产出目标码。它是bitwise const，所有编译器都这么认定。但是我们来看下它会允许发生些什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;  <span class="comment">//现在cctb有了“Jello”这样的内容</span></span><br></pre></td></tr></table></figure>

<p>这其中当然不该有任何错误：我们创建一个常量对象并设置某值，而且只对它调用const成员函数。但我们终究还是改变了它的值。</p>
<p>&emsp;&emsp;这种情况引出了所谓的logical constness。这一派拥护者主张，一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。例如我们的CTextBlock class有可能高速缓存文本区块的长度以便应付询问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);  <span class="comment">//错误！在const成员函数内不能赋值给</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;             <span class="comment">//textLength和lengthIsValid。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;length的实现当然不是bitwise const，因为textLength和lengthIsValid都可能被修改。这两个数据被修改对const CTextBlock对象而言虽然可接受，但编译器不同意。它们坚持bitwise constness。怎么办？</p>
<p>&emsp;&emsp;解决办法很简单：利用C++的一个与const相关的关键字：mutable。mutable释放掉non-static成员变量的bitwise constness约束：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);  <span class="comment">//现在，可以这样</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;             <span class="comment">//这样也可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h2><p>&emsp;&emsp;对于“bitwise-constness非所我欲”的问题，mutable是个解决办法，但它不能解决所有的const相关难题。举个例子，假设TextBlock（和CTextBlock）内的operator[]不单只是返回一个reference指向字符，也执行边界检验、日志访问信息、甚至可能进行数据完善性检验。把所有这些同时放进const和non-const operator[]中，导致这样的怪物：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ...  <span class="comment">//边界检验</span></span><br><span class="line">        ...  <span class="comment">//日志数据访问</span></span><br><span class="line">        ...  <span class="comment">//检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        ...  <span class="comment">//边界检验</span></span><br><span class="line">        ...  <span class="comment">//日志数据访问</span></span><br><span class="line">        ...  <span class="comment">//检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们真正该做的是实现operator[]的功能一次并使用它两次。也就是说，我们必须令其中一个调用另一个。这促使我们将常量性消除。</p>
<p>&emsp;&emsp;就一般守则而言，转型是一个糟糕的想法。然而代码重复也一样使我们恼火。这面是避免代码重复的安全做法的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[<span class="built_in">position</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码有两个转型动作。我们打算让non-const operator[]调用其const兄弟，但non-const operator[]内部若只是单纯调用operator[]，会递归调用自己。那大概会……唔……进行一百万次。为了避免无穷递归，我们必须明确指出调用的是const operator[]，但C++缺乏直接的语法可以那么做。因此这里将&#42;this从其原始类型TextBlock&amp;转型为const TextBlock&amp;。这里的两次转型，第一次使用来为&#42;this添加const（这使接下来调用operator[]时得以调用const版本），第二次则是从const operator[]的返回值中移除const。</p>
<p>&emsp;&emsp;至于其他动作，由于本例调用的是操作符，所以语法有一点奇特，恐怕无法赢得选美大赛，但却有我们渴望的“避免代码重复”的效果，因为它运用const operator[]实现出non-const版本。为了达到这个目标而写出如此难看的语法是否值得，只能由自己来决定了。但“运用const成员函数实现出non-const孪生兄弟”的技术是值得了解到。</p>
<p>&emsp;&emsp;更值得了解的是，反向做法——令const版本调用non-const版本以避免重复——这并不是我们该做的事。记住，const成员函数决不允许改变其对象的逻辑状态，non-const成员函数却没有这样的强制要求。如果在const函数内调用non-const函数，就会冒这样的风险：我们不想改变的那个对象被改动了。这就是为什么“const成员函数调用non-const成员函数”是一个错误行为：因为对象有可能因此被改动。实际上若要这样的代码通过编译，我们必须使用一个const_cast将&#42;this身上的const性质解放掉，这是乌云罩顶掉前兆。之前的调用才是安全的：non-const成员函数本来就可以对其对象做任何操作，所以在其中调用一个const成员函数并不会带来风险。</p>
<blockquote>
<p>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p>
<p>编译器强制实施bitwise constness，但我们编写程序时应该使用“概念上的常量性”。</p>
<p>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽量以const,enum,inline替换define</title>
    <url>/2020/07/17/%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%E6%9B%BF%E6%8D%A2define/</url>
    <content><![CDATA[<h1 id="尽量以const-enum-inline替换-define"><a href="#尽量以const-enum-inline替换-define" class="headerlink" title="尽量以const,enum,inline替换#define"></a>尽量以const,enum,inline替换#define</h1><p>&emsp;&emsp;宁可以编译器替换预处理器，因为或许#define不被视为语言的一部分。这正是问题的所在，当我们做出这样的事情：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;记号名称ASPECT_RATIO也许从未被编译器看见；也许在编译器开始处理源代码之前它就被预处理器移走了。于是记号名称ASPECT_RATIO有可能没进入记号表内。于是当我们运行此常量但获得一个编译错误信息时，可能会带来困惑，因为这个错误信息也许会提到1.653而不是ASPECT_RATIO。如果ASPECT_RATIO被定义在一个非我们所写的头文件内，我们肯定对1.653以及它来自何处毫无概念，于是我们将因为追踪它而浪费时间。这个问题也可能出现在记号式调试器中，原因相同：我们所使用的名称可能并未进入记号表。</p>
<p>&emsp;&emsp;解决之道是以一个常量替换上述的宏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;  <span class="comment">//大写名称通常用于宏</span></span><br><span class="line">                                   <span class="comment">//因此这里改变名称写法</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;作为一个语言常量，AspectRatio肯定会被编译器看到，当然就会进入记号表内。此外对浮点常量而言，使用常量可能比使用#define导致较小量的码，因为预处理器“盲目地将宏名称ASPECT_RATIO替换为1.653”可能导致目标码出现多份1.653，若改用常量AspectRatio绝不会出现相同情况。</p>
<p>&emsp;&emsp;当我们以常量替换#define，有两种特殊情况值得说说。第一是定义常量指针。由于常量定义式通常被放在头文件内（以便被不同的源码含入），因此有必要将指针声明为const。例如若要在头文件内定义一个常量char*-based字符串，我们必须写const两次：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"Guan Zhe"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于const的意义和使用（特别是当它与指针结合时），之后有完整的讨论。这里这里值得提醒的是，string对象通常比其前辈char*-based合宜，所以上述的authorName往往定义成这样更好些：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>:<span class="function"><span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">"Guan Zhe"</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第二个值得注意的是class专属常量。为了将常量的作用域限制于class内，你必须让它成为class的一个成员；而为确保此常量至多只有一份实体，我们必须让它成为一个static成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">//常量声明式  </span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];           <span class="comment">//使用该常量</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然而我们所看到的是NumTurns的声明式而非定义式。通常C++要求我们对我们所使用的任何东西提供一个定义式，但如果它是个class专属常量又是static且为整数类型，则需特殊处理。只要不取它们的地址，我们可以声明并使用它们而无须提供定义式。但如果我们取某个class专属常量的地址，或纵使我们不取其地址而我们的编译器却（不正确地）坚持要看到一个定义式，我们就必须另外提供定义式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;  <span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;请把这个式子放进一个实现文件而非头文件。由于class常量已在声明时获得初值，因此定义时不可以再设初值。</p>
<p>&emsp;&emsp;顺带一提，请注意，我们无法利用#define创建一个class专属常量，因为#define并不重视作用域。一旦宏被定义，它就在其后的编译过程中有效（除非在某处被#undef）。这意味着#defines不仅不能够用来定义class专属常量，也不能够提供任何封装性，也就是说没有所谓private #define这样的东西。而当然const成员变量是可以被封装的，NumTurns就是。</p>
<p>&emsp;&emsp;旧式编译器也许不支持上述语法，它们不允许static成员在其声明式上获得初值。此外所谓的“in-class初值设定“也只允许对整数常量进行。如果我们的编译器不支持上述语法，则可以将初值放在定义时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor;  <span class="comment">//static class常量声明，位于头文件</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>;  <span class="comment">//static class常量定义，位于实现文件内</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这几乎是我们在任何时候唯一需要做的事。唯一例外是当我们在class编译期间需要一个class常量值，例如在上述的GamePlayer::scores的数组声明式中（编译器坚持必须在编译期间之道数组的大小）。这时候万一我们的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的“the enum hack”补偿做法。其理论基础是：“一个属于枚举类型的数值可当ints被使用，于是GamePlayer可定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;  <span class="comment">//"the enum hack"令NumTurns成为5的一个记号名称</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;基于数个理由enum hack值得我们认识。第一，enum hack的行为某方面说比较像#define而不像const，有时候这正是我们想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法。如果我们不想让别人获得一个pointer或reference指向我们的某个整数常量，enum可以帮助我们实现这个约束。此外虽然优秀的编译器不会为“整数型const对象”设定另外的存储空间（除非我们创建一个pointer或reference指向该对象），不够优秀的编译器却可能如此，而这可能不是我们想要的。Enum和#define一样绝不会导致非必要的内存分配。</p>
<p>&emsp;&emsp;认识enum hack的第二个理由纯粹是为了实用主义。许多代码用了它。事实上“enum hack”是template metaprogramming的基础技术。</p>
<p>&emsp;&emsp;把焦点拉回预处理器。另一个常见的#define误用情况是以它实现宏（macros）。宏看起来像函数，但不会导致函数调用带来的额外开销。下面这个宏家呆着宏实参，调用函数f：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以a和b的较大值调用f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这般长相的宏有着太多缺点，光是想到它们就让人痛苦不堪。</p>
<p>&emsp;&emsp;无论何时当我们写出这种宏，我们必须记住为宏中的所有实参加上小括号，否则某些人在表达式中调用这个宏时可能会遭遇麻烦。但纵使我们为所有实参加上小括号，看看下面不可思议的事情：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a,b);     <span class="comment">//a被累加两次</span></span><br><span class="line">CALL_WITH_MAX(++a,b+<span class="number">10</span>);  <span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;幸运的是我们可以避免这种无聊的事情发生。我们可以获得宏带来的效率以及一般函数的所有可预料行为和类型安全——只要我们写出template inline函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个template产出一个组函数，每个函数都接受两个同型对象，并以其中较大者调用f。此外这里的callWithMax是个真正的函数，它遵循作用域和访问规则。例如我们绝对可以写出一个“class内的private inline函数”。一般而言宏无法完成此事。</p>
<p>&emsp;&emsp;有了consts、enums和inlines，我们对于预处理器的需求降低了，但并非完全消除。#include仍然是必需品，而#ifdef／#ifndef也继续扮演着控制编译的重要角色。</p>
<blockquote>
<p>对于单纯变量，最好以const对象或enum替换#define。</p>
<p>对于形似函数的宏，最好改用inline函数替换#define。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽量少做转型动作</title>
    <url>/2020/08/08/%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h1 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h1><p>&emsp;&emsp;C++规则的设计目标之一是，保证“类型错误”绝不可能发生。理论上如果你的程序很“干净地”通过编译，就表示它并不企图在任何对象身上执行任何不安全、无意义、愚蠢荒谬的操作。这是个极具价值的保证，可别草率地放弃它。</p>
<p>&emsp;&emsp;不幸的是，转型破坏了类型系统。那可能导致任何种类的麻烦，有些容易辨识，有些非常隐晦。如果你来自C，Java或C#阵营，请特别注意，因为那些语言中的转型比较必要而无法避免，也比较不危险（与C++相较）。但C++不是C，也不是Java或C#。在C++中转型是一个你会想带着极大尊重去亲近的一个特性。</p>
<p>&emsp;&emsp;让我们首先回顾转型语法，因为通常有三种不同的形式，可写出相同的转型动作。C风格的转型动作看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(T)expression  <span class="comment">//将expression转型为T</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;函数风格的转型动作看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T(expression)  <span class="comment">//将expression转型为T</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;两种形式并无差别，纯粹只是小括号的摆放位置不同而已。为称此二种形式为“旧式转型”。</p>
<p>&emsp;&emsp;C++还提供四种新式转型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;各有不同的目的：</p>
<ul>
<li>const_cast通常被用将对象的常量性转除。它也是唯一有此能力的C++-style转型操作符。</li>
<li>dynamic_cast主要用来执行“安全向下转型”，也就是用来决定对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能消耗重大运行成本低转型动作。</li>
<li>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。例如将一个pointer to int转型为一个int。这一类转型在低级代码以外很少见。</li>
<li>static_cast用来强迫隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它也可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-derived转为pointer-to-base。但它无法将const转为non-const——这个只有const_cast才办得到。</li>
</ul>
<p>&emsp;&emsp;旧式转型仍然合法，但新式转型较受欢迎。原因是：第一，它们很容易在代码中被辨识出来，因而得以简化“找出类型系统在哪个地点被破坏”的过程。第二，各种转型动作的目标愈窄化，编译器愈可能诊断出错误的运用。举个例子，如果你打算将常量性去掉，除非使用新式转型中的const_cast否则无法通过编译。</p>
<p>&emsp;&emsp;我唯一使用旧式转型的时机是，当为要调用一个explicit构造函数将一个对象传递给一个函数时。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"></span><br><span class="line">doSomeWork(Widget(<span class="number">15</span>));               <span class="comment">//以一个int加上“函数风格”的转型动作创建一个Widget</span></span><br><span class="line"></span><br><span class="line">doSomeWork(<span class="keyword">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));  <span class="comment">//以一个int加上“C++风格”的转型动作创建一个Widget</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从某个角度来说，蓄意的“对象生成”动作感觉不怎么像“转型”，所以我很可能使用函数风格的转型而不适用static_cast。但我要再说一次，当我我们写下一段日后出错导致“core dump”的代码时，撰写之时我们往往“觉得”通情达理，所以或许最好是忽略你的感觉，始终理智地使用新式转型。</p>
<p>&emsp;&emsp;许多程序员相信，转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型。这是错误的概念。任何一个类型转换往往真的令编译器编译出运行期间执行的码。例如在这段程序中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;将int x转型为double几乎肯定会产生一些代码，因为在大部分计算器体系结构中，int的底层表述不同于double的底层表述。这或许不会让你惊讶，但下面这个例子就有可能让你稍微睁大眼睛了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;  <span class="comment">//隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里我们不过是建立一个base class指针指向一个derived class对象，但有时候上述的两个指针值并不相同。这种情况下会有个偏移量在运行期被施行于Derived*指针身上，用以取得正确的Base*指针值。</p>
<p>&emsp;&emsp;上个例子表明，单一对象（例如一个类型为Derived的对象）可能拥有一个以上的地址（例如“以Base*指向它”时的地址和“以Derived*指向它”时的地址。）。C不可能发生这种事，Java不可能发生这种事，C#也不可能发生这种事。但C++可能！实际上一旦使用多重继承，这事几乎一直发生着。即使在单一继承中也可能发生。虽然这还有其它涵义但至少意味你通常应该避免做出“对象在C++中如何如何布局”的假设。当然更不该以此假设为基础执行任何转型动作。例如，将对象地址转型为char*指针然后在它们身上进行指针算术。几乎总是会导致无定义行为。</p>
<p>&emsp;&emsp;但请注意，我说的是有时候需要一个偏移量。对象的布局方式和它们的地址计算方式随编译器的不同而不同，那意味着“由于知道对象如何布局”而设计的转型，在某一平台行得通，在其它平台不一定行得通。这个世界有许多悲惨的程序员，他们历尽千辛万苦才学到这个教训。</p>
<p>&emsp;&emsp;另一件关于转型的有趣事情是：我们很容易写出某些似是而非的代码。例如许多应用框架都要求derived class内的virtual函数代码的第一个动作就先调用base class的对应函数。假设我们有个Window base class和一个SpecialWindow derived class，两者都定义了virtual函数onResize。进一步假设SpecialWindow的onResize函数被要求首先调用Window的onResize。下面是实现方式之一，它看起来对，但实际上错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Windwo&gt;(*<span class="keyword">this</span>).onResize();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我在代码中强调了转型动作。一如你所预期，这段程序将*this转型为Window，对函数onResize的调用也因此调用了Window::onResize。但恐怕你没想到，它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“*this对象之base class成分”的暂时副本身上的onResize！再说一次，上述代码并非在当前对象身上调用Window::onResize之后又在该对象身上执行SpecialWindow专属动作。如果Window::onResize修改了对象内容（不能说没有可能性，因为onResize是个non-const成员函数），当前对象其实没被改动，改动的是副本。然而SpecialWindow::onResize内如果也修改对象，当前对象真的会被改动，这使当前对象进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分倒是落实。</p>
<p>&emsp;&emsp;解决之道是拿掉转型动作，代之以你真正想说的话。你并不想哄编译器将*this视为一个base class对象，你只是想调用base class版本的onResize函数，令它作用于当前对象身上，所以请这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Window::onResize();  <span class="comment">//调用Window::onResize作用于*this身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个例子也说明，如果你发现你自己打算转型，那活脱是个警告信号：你可能正将局面发展至错误的方向上。如果你用的是dynamic_cast更是如此。</p>
<p>&emsp;&emsp;在探究dynamic_cast设计意涵之前，值得注意的是，dynamic_cast的许多实现版本执行速度相当慢。例如至少有一个很普遍的实现版本基于“class名称之字符串比较”，如果你在四层深的单继承体系内的某个对象身上执行dynamic_cast，刚才说的那个实现版本所提供的每一次dynamic_cast可能会耗用多达四次的strcmp调用，用以比较class名称。深度继承或多重继承的成本更高！某些实现版本这样做是有其原因（它们必须支持动态连接）。然而我还是要强调，除了对一般转型保持机敏与猜疑，更应该在注重效率的代码中对dynamic_cast保持机敏与猜疑。</p>
<p>&emsp;&emsp;之所以需要dynamic_cast，通常是因为你想在一个你认定为derived class对象身上执行derived class操作函数，但你手上却只有一个“指向base”的pointer或reference，你只能靠它们来处理对象。有两个一般性做法可以避免这个问题。</p>
<p>&emsp;&emsp;第一，使用容器并在其中存储直接指向derived class对象的指针（通常是智能指针），如此便消除了“通过base class接口处理对象”的需要。假设先前的Window/SpecialWindow继承体系中只有SpecialWindow才支持闪烁效果，试着不要这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span>(VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();</span><br><span class="line">      iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">      <span class="keyword">if</span>(SpecialWindow* psw = <span class="keyword">dynamic_cast</span>&lt;SpecialWindow*&gt;(iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">          psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>应该改而这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>();  <span class="comment">//这样写比较好</span></span><br><span class="line">    iter != winPtrs.<span class="built_in">end</span>(); ++iter)          <span class="comment">//不使用dynamic_cast</span></span><br><span class="line">(*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然啦，这种做法使你无法在同一个容器内存储指针“指向所有可能之多种Window派生类”。如果真要处理多种窗口类型，你可能需要多个容器，它们都必须具备类型安全性。</p>
<p>&emsp;&emsp;另一种做法可让你通过base class接口处理“所有可能之各种window派生类”，那就是在base class内提供virtual函数做你想对各个Window派生类做的事。举个例子，虽然只有SpecialWindow可以闪烁，但或许将闪烁函数声明于base class内并提供一份“什么也没做”的缺省实现代码是有意义的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//缺省实现代码“什么也没做”</span></span><br><span class="line">    ...                      <span class="comment">//缺省实现代码可能是个馊主意</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::share_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();</span><br><span class="line">    iter != winPtrs.<span class="built_in">end</span>();</span><br><span class="line">    ++iter)</span><br><span class="line">(*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不论哪种写法——“使用类型安全容器”或“将virtual函数往继承体系上方移动”——都并非放之四海而皆准，但在许多情况下它们都提供一个可行的dynamic_cast替代方案。当它们有此功效时，你应该欣然拥抱它们。</p>
<p>&emsp;&emsp;绝对必须避免的一件事是所谓的“连串dynamic_cast”，也就是看起来像这样的东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span> ... &#125;;</span><br><span class="line">...  <span class="comment">//derived class定义在这里</span></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();</span><br><span class="line">    iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    <span class="keyword">if</span>(SpecialWindow1* psw1 =</span><br><span class="line">       <span class="keyword">dynamic_cast</span>&lt;SpecialWindow1*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(SpecialWindow2* psw2 =</span><br><span class="line">            <span class="keyword">dynamic_cast</span>&lt;SpecialWindow2*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(SpecialWindow3* psw3 =</span><br><span class="line">            <span class="keyword">dynamic_cast</span>&lt;SpecialWindow3*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样生产出来的代码又大又慢，而且基础不稳，因为每次Window class继承体系一有改变，所有这一类代码都必须再次检阅看看是否需要修改。例如一旦加入新的derived class，或许上述连串判断中需要加入新的条件分支。这样的代码应该总是以某些“基于virtual函数调用”的东西取而代之。</p>
<p>&emsp;&emsp;优良的C++代码很少使用转型，但若说要完全摆脱它们又太过不切实际。例如之前的例子从int转型为double就是转型的一个通情达理的使用，虽然它并非绝对必要（那段代码可以重新写过，声明一个类型为double的新变量并以x值初始化）。就像面对众多蹊跷可疑的构造函数一样，我们应该尽可能隔离转型动作，通常是把它隐藏在某个函数内，函数的接口会保护调用者不受函数内部任何肮脏龌龊的动作影响。</p>
<blockquote>
<p>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。</p>
<p>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进它们自己的代码内。</p>
<p>宁可使用C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较又着分门别类的职掌。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽量延后变量定义式的出现时间</title>
    <url>/2020/08/07/%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<hr>
<h1 id="尽量延后变量定义式的出现时间"><a href="#尽量延后变量定义式的出现时间" class="headerlink" title="尽量延后变量定义式的出现时间"></a>尽量延后变量定义式的出现时间</h1><p>&emsp;&emsp;只要你定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。即使这个变量最终并未被使用，仍需耗费这些成本，所以你应该尽可能避免这种情形。</p>
<p>&emsp;&emsp;或许你会认为，你不可能定义一个不使用的变量，但话不要说得太早！考虑下面这个函数，它计算通行密码的加密版本而后返回，前提是密码够长。如果密码太短，函数会丢出一个异常，类型为logic_error：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数过早定义变量“encrypted”</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">string</span> encrypted;</span><br><span class="line">    <span class="keyword">if</span>(password.length() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">"Password is too short"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...  <span class="comment">//必要动作，将一个加密后的密码置入变量encrypted内</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对象encrypted在此函数中并非完全未被使用，但如果有个异常被丢出，它就真的没被使用。也就是说如果函数encryptPassword丢出异常，你仍得付出encrypted的析构成本和构造成本。所以最好延后encrypted的定义式，直到确实需要它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数延后“encrypted”的定义，直到真正需要它</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span>(password.length() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">"Password is too shrot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> encrypted;</span><br><span class="line">    ...  <span class="comment">//必要动作，将一个加密后的密码置入变量encrypted内</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是这段代码仍然不够秾纤合度，因为encrypted虽获定义却无任何实参作为初值。这意味调用的是其default构造函数。许多时候你该对对象做的第一件事就是给它个值，通常是通过一个赋值动作达成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//终于，这是定义并初始化encrypted的最佳做法</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; password)</span> </span>&#123;</span><br><span class="line">    ...                               <span class="comment">//检查长度</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encrypted</span><span class="params">(password)</span></span>;  <span class="comment">//通过copy构造函数定义并初始化</span></span><br><span class="line">    encrypt(encrypted);               <span class="comment">//在encrypt函数内对其加密</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这让我们联想起所谓“尽可能延后”的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</p>
<p>&emsp;&emsp;“但循环怎么办？”你可能会感到疑惑。如果变量只在循环内使用，那么把它定义于循环外并在每次循环迭代时赋值给它比较好，还是该把它定义于循环内？也就是说下面两个一般性结构，哪一个比较好？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法A</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法B</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(i)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在Widget函数内部，以上两种写法的成本如下：</p>
<ul>
<li>做法A：1个构造函数 + 1个析构函数 + n个赋值操作</li>
<li>做法B：n个构造函数 + n个析构函数</li>
</ul>
<p>&emsp;&emsp;如果class的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n值很大时。否则做法B或许较好。此外做法A造成名称w的作用域（覆盖整个循环）比做法B更大，有时那对程序的可理解性和易维护性造成冲突。因此除非（1）你知道赋值成本比“构造+析构”成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法B。</p>
<blockquote>
<p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>成对使用new和delete时要采取相同形式</title>
    <url>/2020/07/30/%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h1 id="成对使用new和delete时要采取相同形式"><a href="#成对使用new和delete时要采取相同形式" class="headerlink" title="成对使用new和delete时要采取相同形式"></a>成对使用new和delete时要采取相同形式</h1><p>&emsp;&emsp;以下动作有什么错？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringArray = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringArray;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每件事看起来都井然有序。使用了new，也搭配了对应的delete。但还是有某样东西完全错误：我们的程序未定义。stringArray所含的100个string对象中的99个不太可能被适当删除，因为它们的析构函数很可能没被调用。</p>
<p>&emsp;&emsp;当我们使用new（也就是通过new动态生成一个对象），有两件事发生。第一，内存被分配出来（通过名为operator new的函数）。第二，针对此内存会有一个（或更多）构造函数被调用。当我们使用delete，也会有两件事发生：针对此内存会有一个（或更多）析构函数被调用，然后内存才被释放（通过名为operator delete的函数）。delete的最大问题在于：即将被删除的内存之内究竟存有多少对象？这个问题的答案决定了有多少个析构函数必须被调用起来。</p>
<p>&emsp;&emsp;实际上这个问题可以更简单些：即将被删除的那个指针，所指的是单一对象或对象数组？这是个必不可缺的问题，因为单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括“数组大小”的纪录，以便delete知道需要调用多少次析构函数。单一对象的内存则没有这笔纪录。</p>
<p>&emsp;&emsp;当我们对着一个指针使用delete，唯一能够让delete知道内存中是否存在一个“数组大小纪录”的办法就是：由我们来告诉它。如果我们使用delete时加上方括号，delete便认定指针指向一个数组，否则它便认定指针指向单一对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr1 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;</span><br><span class="line"><span class="keyword">delete</span>[] stringPtr2;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个规则对于喜欢使用typedef的人也很重要，因为它意味着typedef的作者必须说清楚，当程序员以new创建该种typedef类型对象时，该以哪一种delete形式删除之，考虑下面这个typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> AddressLines[<span class="number">4</span>];  <span class="comment">//每个人的地址有4行</span></span><br><span class="line">                                      <span class="comment">//每一行是一个string</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于AddressLines是个数组，如果这样使用new：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* pal = <span class="keyword">new</span> AddressLines;  <span class="comment">//注意，"new AddressLines"返回一个string*</span></span><br><span class="line">                                      <span class="comment">//就像"new string[4]"一样</span></span><br></pre></td></tr></table></figure>

<p>这就必须匹配“数组形式”的delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pal;    <span class="comment">//未定义</span></span><br><span class="line"><span class="keyword">delete</span>[] pal;  <span class="comment">//很好</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为避免诸如此类的错误，最好尽量不要对数组形式做typedef动作。例如我们可以将本例的AddressLines定义为“由string组成的一个vector”，也就是其类型为vector&lt;string&gt;。</p>
<blockquote>
<p>如果我们在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果我们在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>必须返回对象时，别妄想返回其reference</title>
    <url>/2020/08/02/%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/</url>
    <content><![CDATA[<hr>
<h1 id="必须返回对象时，别妄想返回其reference"><a href="#必须返回对象时，别妄想返回其reference" class="headerlink" title="必须返回对象时，别妄想返回其reference"></a>必须返回对象时，别妄想返回其reference</h1><p>&emsp;&emsp;一旦程序员领悟了pass-by-value的效率牵连层面，往往变成十字军战士，一心一意根除pass-by-value带来的种种邪恶。在坚定追求pass-by-reference的纯度中，他们一定会犯下一个致命错误：开始传递一些reference指向并不存在的对象。这可不是件好事。</p>
<p>&emsp;&emsp;考虑一个用以表现有理数的class，内含一个函数用来计算两个有理数的乘积：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>,</span><br><span class="line">             <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, d;  <span class="comment">//分子和分母</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                                    <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个版本的operator*是以by value方式返回其计算结果（一个对象）。如果我们完全不担心该对象的构造和析构成本，我们其实是明显逃避了我们的专业责任。若非必要，没有人会想要为这样的对象付出太多代价，问题是需要付出任何代价吗？</p>
<p>&emsp;&emsp;如果可以改而传递reference，就不需付出代价。但是记住，所谓reference只是个名称，代表某个既有对象。任何时候看到一个reference声明式，我们都应该立刻问自己，它的另一个名称是什么？因为它一定是某物的另一个名称。以上述operator*为例，如果它返回一个reference，后者一定指向某个既有的Rational对象，内含两个Rational对象的乘积。</p>
<p>&emsp;&emsp;我们当然不可能期望这样一个（内含乘积的）Rational对象在调用operator*之前就存在，也即是说，如果有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Rational c = a * b;</span><br></pre></td></tr></table></figure>

<p>期望“原本就存在一个其值为3/10点Rational对象”并不合理。如果operator*要返回一个reference指向此数值，它必须自己创建那个对象。</p>
<p>&emsp;&emsp;函数创建对象的途径有二：在stack空间或在heap空间创建之。如果定义一个local变量，就是在stack空间创建对象。根据这个策略写operator*如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                           <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;  <span class="comment">//警告！糟糕的代码</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以拒绝这种做法，因为我们的目标是避免调用构造函数，而result却必须像任何对象一样地由构造函数构造起来。更严重的是：这个函数返回一个reference指向result，但result是个local对象，而local对象在函数退出前被销毁了。因此，这个版本的operator*并未返回reference指向某个Rational，它返回的reference指向一个“从前的”Rational：一个曾经被当作Rational但如今已经成空、发臭、败坏的残骸，因为它已经被销毁了。任何调用者甚至只是对此函数的返回值做任何一点点运用，都将立刻坠入“无定义行为”的恶地。事情的真相是，任何函数如果返回一个reference指向某个local对象，都将一败涂地。（如果函数返回指针指向一个local对象，也是一样）。</p>
<p>&emsp;&emsp;于是，让我们考虑在heap内构造一个对象，并返回reference指向它。Heap-base对象由new创建，所以我们得写出一个heap-based operator*如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                          <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    Rational* result = <span class="keyword">new</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们还是必须付出一个“构造函数调用”代价，因为分配所得的内存将以一个适当的构造函数完成初始化动作。但此外你现在又有了另一个问题：谁该对着被你new出来的对象实施delete？</p>
<p>&emsp;&emsp;即使调用者诚实谨慎，并且出于良好意识，他们还是不太能够在这样合情合理的用法下阻止内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里，同一语句内调用了两次operator*，因而两次使用new，也就需要两次delete。但却没有合理的办法让operator*使用者进行那些delete调用，因为没有合理的办法让他们取得operator*返回的reference背后隐藏的那个指针。这绝对导致资源泄漏。</p>
<p>&emsp;&emsp;但或许你注意到了，上述不论on-the-stack或on-the-heap做法，都因为对operator*返回的结果调用构造函数而受惩罚。或许你心里出现下面这样的实现代码，此法基于“让operator*返回的reference指向一个被定义于函数内部的static Rational对象”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                          <span class="keyword">const</span> Rational&amp; rhs) &#123;  <span class="comment">//警告！又一堆烂代码</span></span><br><span class="line">    <span class="keyword">static</span> Rational result;                       <span class="comment">//static对象，此函数返回其reference</span></span><br><span class="line">    result = ...;                                 <span class="comment">//将lhs乘以rhs，并将结果置于result内</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就像所有用上static对象的设计一样，这一个也立刻造成我们对多线程安全性的疑虑。不过那还只是它显而易见的弱点。如果想看看更深层的瑕疵，考虑下面这些完全合理的客户代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">Rational a, b, c, d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>((a * b) == (c * d)) &#123;</span><br><span class="line">    <span class="comment">//当乘积相等时，做适当的相应动作；</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//当乘积不等时，做适当的相应动作；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;猜想怎么着？表达式（（a * b）==（c * d））总是被核算为true，不论a，b，c，d的值是什么！</p>
<p>&emsp;&emsp;一旦将代码重新写为等价的函数形式，很容易就可以了解了出什么意外：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="keyword">operator</span>*(a, b), <span class="keyword">operator</span>*(c, d)))</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在operator==被调用前，已有两个operator*调用式起作用，每一个都返回reference指向operator*内部定义的static Rational对象。因此operator==被要求将“operator*内的static Rational对象值”拿来和“operator*内的static Rational对象值”比较，如果比较结果不相等，那才奇怪呢。（两次operator*调用的确各自改变了static Rational对象值，但由于它们返回的都是reference，因此调用端看到的永远是static Rational对象的“现值”）</p>
<p>&emsp;&emsp;这应该足够说服你，欲令诸如operator*这样的函数返回reference，只是浪费时间而已，但现在或许又有些人这样想：“如果一个static不够，或许一个static array可以得分……”。</p>
<p>&emsp;&emsp;我不打算再次写出示例来驳斥这个想法以彰显自己多么厉害，但我可以简单描述为什么你该为了提出这个念头而脸红。首先你必须选择array大小n。如果n太小，你可能会耗尽“用以存储函数返回值”的空间，那么情况就回到了我们刚才讨论过的单一static设计。但如果n太小，会因此降低程序效率，因为array内的每一个对象都会在函数第一次被调用时构造完成。那么将消耗n个构造函数和n个析构函数——即使我们所讨论的函数只被调用一次。如果所谓“最优化”是改善软件效率的过程，我们现在所谈的这些应该成为“恶劣化”。最后，想一想如何将你需要的值放进array内，而那么做的成本又是多少。在对象之间搬移数值的最直接办法是通过赋值操作，但赋值的成本几何？对许多type而言它相当于调用一个析构函数（用以销毁旧值）加上一个构造函数（用以复制新值）。但你的目标是避免构造和析构成本耶！面对现实吧，这个做法不会成功的。就算以vector替换array也不会让情况更好些。</p>
<p>&emsp;&emsp;一个“必须返回新对象”的函数的正确写法是：就让那个函数返回一个新对象呗。对Rational的operator*而言意味以下写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，我们需要承受operator*返回值的构造成本和析构成本，然而长远来看那只是为了获得准确行为而付出的一个小小代价。但万一账单很恐怖，我们承受不起，别忘了C++和所有编程语言一样，允许编译器实现者施行最优化，用以改善产出码的效率却不改变其可观察的行为。因此某些情况下operator*返回值的构造和析构可被安全地消除。如果编译器运用这一事实（它们也往往如此），我们的程序将继续保持它们该有的行为，而执行起来又比预期的更快。</p>
<p>&emsp;&emsp;当必须在“返回一个reference和返回一个object”之间抉择时，我们的工作就是挑出行为正确的那个。就让编译器厂商为“尽可能降低成本”鞠躬尽瘁吧，我们可以享受我们的生活。</p>
<blockquote>
<p>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>确定你的public继承塑模出is-a关系</title>
    <url>/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<hr>
<h1 id="确定你的public继承塑模出is-a关系"><a href="#确定你的public继承塑模出is-a关系" class="headerlink" title="确定你的public继承塑模出is-a关系"></a>确定你的public继承塑模出is-a关系</h1><p>&emsp;&emsp;在《Some Must Watch While Some Must Sleep》这本书中，作者William Dement说了一个故事，谈到他曾经试图让学生记下课程中最重要的一些教导。书上说，他告诉他的班级，一般英国学生对于发生在1066年的黑斯廷斯战役所知不多。如果有学生记得多一些，Dement强调，无非也只是记得1066这个数字而已。然后Dement继续其课程，其中只有少数重要信息，包括“安眠药反而造成失眠症”这类有趣的事情。他一再要求学生，纵使忘记了课程中的其他每一件事，也要记住这些数量不多的重要事件。Dement在整个学期中不断耳提面命这样的话。</p>
<p>&emsp;&emsp;课程结束后，期末考的最后一道题是：“写下你从本课程获得的一件永生不忘的事”。当Dement批改试卷，他目瞪口呆。几乎每一个人都写下“1066”。</p>
<p>&emsp;&emsp;以C++进行面向对象编程，最主要的一个规则是：public inheritance（公开继承）意味“is-a”（是一种）的关系。把这个规则牢牢地烙印在你的心中吧！</p>
<p>&emsp;&emsp;如果你令class D（“derived”）以public形式继承class B（“base”），你便是告诉C++编译器（以及你的代码读者）说，每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。也就是说你的本意是令B比D表现出更为一般化的概念，而D便是特殊化的体现。“任何B对象可派上用场的任何地方，D对象一样可以派上用场”这是C++对于“public继承”的解释。而需要D对象的场合，B对象则不一定会起到作用。</p>
<p>&emsp;&emsp;考虑以下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;根据生活经验我们知道，每个学生都是人，但并非每个人都是学生。这就是一个public继承体系。我们预期，对人可以成立的每一件事——例如每个人都有生日——对学生也都成立。但我们并不预期对学生可成立的每一件事——例如他注册于某学校——对人也成立。人的概念比学生更一般化，学生是人的一种特殊形式。</p>
<p>&emsp;&emsp;于是，在C++领域中，任何函数如果期望获得一个类型为Person（或point-to-Person或reference-to-Person）的实参，都也愿意接受一个Student对象（或point-to-Student或reference-to-Student）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"></span><br><span class="line">eat(p);  <span class="comment">//没问题</span></span><br><span class="line">eat(s);  <span class="comment">//没问题</span></span><br><span class="line">study(p);  <span class="comment">//错误！</span></span><br><span class="line">study(s);  <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个论点只对public继承才成立。只有当Student以public形式继承Person，C++的行为才会如我所描述。private继承的意义与此完全不同，至于protected继承，那是一种其意义至今仍然困惑我的东西。</p>
<p>&emsp;&emsp;public继承和is-a之间的等价关系听起来颇为简单，但有时候你的直觉可能会误导你。举个例子，企鹅是一种鸟，这是事实。鸟可以飞，这也是事实。如果我们天真地以C++描述这层关系，结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;突然间我们感到了困惑，因为这个继承体系说企鹅可以飞，而我们知道那不是真的，怎么回事？</p>
<p>&emsp;&emsp;在这个例子中。当我们说鸟会飞的时候，我们真正的意思并不是说所有的鸟都会飞，我们要说的只是一般的鸟都有飞行能力。如果谨慎一点，我们应该承认一个事实：有数种鸟不会飞。看看以下代码，其构造出一种较为真实的继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyingBird</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的继承体系比原先的设计更能忠实反映出我们真正的意思。</p>
<p>&emsp;&emsp;即便如此，此刻我们仍然未能完全处理好这些鸟事，因为对某些软件系统而言，可能不需要区分会飞的鸟和不会飞的鸟。如果你的程序忙着处理鸟喙和鸟翅，完全不在乎飞行，原先的“双class继承体系”或许就相当令人满足了。这反映出一个事实，世界上并不存在一个“适用于所有软件”的完美设计。所谓最佳设计，取决于系统希望做什么事，包括现在与未来。如果你的程序对飞行一无所知，而且也不打算对飞行“有所知”，那么不去区分会飞的鸟和不会飞的鸟，不失为一个完美而有效的设计。实际上它可能比“对两者作出区隔”更受欢迎，因为这样的区隔在你企图塑模的世界中并不存在。</p>
<p>&emsp;&emsp;另有一种思想派别处理我所谓“所有的鸟都会飞，企鹅是鸟，但是企鹅不会飞”的问题，就是为企鹅重新定义fly函数，令它产生一个运行期错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;  <span class="comment">//定义于另外某处</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; error(<span class="string">"Attempt to make a penguin fly!"</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;很重要的是，你必须认知这里所说的某些东西可能和你所想的不同。这里并不是说“企鹅不会飞”，而是说“企鹅会飞，但尝试那么做是一种错误”。</p>
<p>&emsp;&emsp;如何描述其间的差异？从错误被侦测出来的时间点观之，“企鹅不会飞”这一限制可由编译器强制实施，但若违反“企鹅尝试飞行，是一种错误”这一条规则，只有运行期才能检测出来。</p>
<p>&emsp;&emsp;为了表现“企鹅不会飞，就这样”的限制，你不可以为Penguin定义fly函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，如果你试图让企鹅飞，编译器会对你的背信加以谴责：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Penguin p;</span><br><span class="line">p.fly();  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>“public继承”意味着is-a。适用于base class身上的每一件事情一定也适用于derived class身上，因为每一个derived class对象也都是一个base class对象。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>确定对象被使用前已先被初始化</title>
    <url>/2020/07/19/%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<hr>
<h1 id="确定对象被使用前已先被初始化"><a href="#确定对象被使用前已先被初始化" class="headerlink" title="确定对象被使用前已先被初始化"></a>确定对象被使用前已先被初始化</h1><p>&emsp;&emsp;关于“将对象初始化”这一点，C++似乎反复无常。如果我们这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure>

<p>在某些语境下x保证被初始化（为0），但在其他语境中却不保证。如果我们这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Point p;</span><br></pre></td></tr></table></figure>

<p>p的成员变量有时候被初始化（为0），有时候不会。</p>
<p>&emsp;&emsp;通常如果我们使用C part of C++而且初始化可能导致运行期成本，那么就不保证发生初始化。一旦进入了non-C parts of C++，规则就会有些改变。这就很好的解释了为什么array（来自C part of C++）不保证其内容被初始化，而vector（来自STL parts of C++）却有此保证。</p>
<p>&emsp;&emsp;表面上这似乎是个无法决定的状态，而最佳处理办法就是：永远在使用对象之前先讲它初始化。对于物任何成员的内置类型，我们必须手工完成此事。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">text</span> = <span class="string">"A C-style string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至于内置类型以外的任何其他东西，初始化责任落在了构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p>
<p>&emsp;&emsp;这个规则很容易遵循，重要的事别混淆了赋值和初始化。考虑一个用来表现通讯簿的class，其构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theAddress;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="keyword">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones) &#123;</span><br><span class="line">    theName = name;  <span class="comment">//这些都是赋值而非初始化</span></span><br><span class="line">    theAddress = address;</span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这会导致ABEntry对象带有我们期望的值，但不是最佳做法。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。在ABEntry构造函数内，theName，theAddress和thePhones都不是被初始化，而是被赋值。初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之时。但这对numTimesConsulted却并非如此，因为它属于内置类型，不保证一定在我们所看到的那个赋值动作的时间点之前获得初值。</p>
<p>&emsp;&emsp;ABEntry构造函数的一个较佳写法是，使用所谓的member initialization list（成员初值列）替换赋值动作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones) </span><br><span class="line">    : theName(name),</span><br><span class="line">      theAddress(address),</span><br><span class="line">      thePhones(phones),</span><br><span class="line">      numTimesConsulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个构造函数和上一个的最终结果相同，但通常效率较高。对于大多数类型而言，比起先调用default构造函数然后再调用copy assignment操作符，单只调用一次copy构造函数是比较高效的，有时甚至高效的多。对于内置对象如numTimesConsulted，其初始化和赋值的成本相同，但为了一致性最好也通过成员初值列来初始化。同样的道理，甚至当我们想要default构造一个成员变量，我们都可以用成员初值列，只要指定nothing作为初始化实参即可，假设ABEntry有一个无参数构造函数，我们可以将其实现为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry() </span><br><span class="line">    : theName(),  <span class="comment">//调用theName的default构造函数</span></span><br><span class="line">      theAddress(),</span><br><span class="line">      thePhones(),</span><br><span class="line">      numTimesConsulted(<span class="number">0</span>)  <span class="comment">//记得将numTimesConsulted显式初始化为0</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>由于编译器会为用户自定义类型的成员变量自动调用default构造函数——如果那些成员变量在“成员初值列”中没有被指定初值的话，因而引发某些程序员过度夸张地采用以上写法，这是可以理解的，但请立下一个规定，总是在初值列中列出所有成员变量，以免还得记住哪些成员变量可以无需初值。举个例子，由于numTimesConsulted属于内置类型，如果成员初值列遗漏了它，它就没有初值，因而可能造成严重的后果。</p>
<p>&emsp;&emsp;有些情况下即使面对的成员变量属于内置类型（那么其初始化与赋值成本相同），也一定得使用初值列。没错，如果成员变量是const或reference，它们就一定需要初值，不能被赋值。为了避免需要记住成员变量何时必须在成员初值列中初始化，何时不需要，最简单的做法就是：总是使用成员初值列。这样做有时候绝对有必要，且往往比赋值更高效。</p>
<p>&emsp;&emsp;许多classes拥有多个构造函数，每个构造函数有自己的成员初值列；如果这种clasees存在许多成员变量和／或base classes，多份成员初值列的存在就会导致不受欢迎的重复（在初值列内）和无聊的工作。这种情况下可以合理地在初值列中遗漏哪些“赋值表现像初始化一样好”的成员变量，改用它们的赋值操作，并将哪些赋值动作移往某个函数（通常是private），供所有构造函数调用。这种做法在“成员变量的初值是由文件或数据库读入”时特别有用。然而，比起经由赋值操作完成的“伪初始化”，通过成员初值列完成的“真正初始化”通常更加可取。</p>
<p>&emsp;&emsp;C++有着十分固定的“成员初始化次序”。次序总是相同的：base classes更早于其derived classes被初始化，而class的成员变量总是以其声明次序被初始化。回头看看ABEntry，其theName成员永远最先被初始化，然后是theAddress，再来是thePhones，最后是numTimesConsulted。即使它们在成员初值列中以不同的次序出现（很不幸，这是合法的），也不会有任何影响。为避免我们或观看我们代码的人迷惑，当我们在编写成员初值列各个成员时，最好总是以其声明次序为次序。</p>
<p>&emsp;&emsp;一旦我们已经很小心地将“内置型成员变量”明确地加以初始化，而且也确保我们的构造函数运用“成员初值列”初始化base classes和成员变量，那就只剩唯一一件事需要操心，那就是……呃……深呼吸……“不同编译单元内定义的non-local static对象”的初始化次序。</p>
<p>&emsp;&emsp;让我们一点一点地深钻这一长串词组。</p>
<p>&emsp;&emsp;所谓static对象，其寿命从被构造出来直到程序结束为止，因此stack和heap-base对象都被排除。这种对象包括global对象、定义于namespace作用域内的对象、在class内、在函数内、以及在file作用域内被声明为static的对象。函数内的static对象称为local static对象，其它static对象称为non-local static对象。程序结束时static对象会被自动销毁，也就是它们的析构函数会在main()结束时被自动调用。</p>
<p>&emsp;&emsp;所谓编译单元是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含入的头文件。</p>
<p>&emsp;&emsp;现在，我们关心的问题涉及至少两个源码文件，每一个内含至少一个non-local static对象。真正的问题是：如果某编译单元内的某个non-local static对象的初始化动作使用了另一编译单元的某个non-local static对象，它所用到的这个对象可能尚未被初始化，因为C++对“定义于不同编译单元内的non-local static对象”的初始化次序并无明确定义。</p>
<p>&emsp;&emsp;幸运的是一个小小的设计便可以完全消除这个问题。唯一需要做的是：将每个non-local static对象搬到自己的专属函数内（该对象在此函数内被声明为static）。这些函数返回一个reference指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static对象被local static对象替换了。Design Patterns迷哥迷妹们想必认出来了，这是Singleton模式的一个常见实现手法。</p>
<p>&emsp;&emsp;这个手法的基础在于：C++保证，函数内的local static对象会在“该函数被调用期间”“首次遇上该对象的定义式”时被初始化。所以如果我们以“函数调用”（返回一个reference指向local static对象）替换“直接访问non-local static对象”，我们就获得了保证，保证我们所获的的那个reference将指向一个经历过初始化的对象。更棒的是，如果我们从未调用non-local static对象的“仿真函数”，就绝不会引发构造和析构成本：真正的non-local static对象可没这等便宜。</p>
<blockquote>
<p>为内置型对象进行手工初始化，因为C++不保证初始化它们。</p>
<p>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</p>
<p>为免除“跨编译单元的初始化次序”问题，以local static对象替换non-local static对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>考虑写出一个不抛出异常的swap函数</title>
    <url>/2020/08/05/%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="考虑写出一个不抛出异常的swap函数"><a href="#考虑写出一个不抛出异常的swap函数" class="headerlink" title="考虑写出一个不抛出异常的swap函数"></a>考虑写出一个不抛出异常的swap函数</h1><p>&emsp;&emsp;swap是个有趣的函数。原本它只是STL的一部分，而后成为异常安全性编程的脊柱，以及用来处理自我赋值可能性的一个常见机制。由于swap如此有用，适当的实现很重要。然而在非凡的重要性之外它也带来了非凡的复杂性。</p>
<p>&emsp;&emsp;所谓swap两对象值，意思是将两对象的值彼此赋予对方。缺省情况下swap动作可由标准程序库提供的swap算法完成。其典型实现完全如你所预期：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只要类型T支持copying（通过copy构造函数和copy assignment操作符完成），缺省的swap实现代码就会帮你置换类型为T的对象，你不需要为此另外再做任何工作。</p>
<p>&emsp;&emsp;这缺省的swap实现版本十分平淡，无法刺激你的肾上腺。它涉及三个对象的复制：a复制到temp，b复制到a，以及temp复制到b。但是对某些类型而言，这些复制动作无一必要；对它们而言swap缺省行为等于是把高速公路铺设在慢速小巷内。</p>
<p>&emsp;&emsp;其中最主要的就是“以指针指向一个对象，内含真正数据”那种类型。这种设计的常见表现形式是所谓“pimpl手法”。如果是以这种手法设计Widget class，看起来会像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span>          <span class="comment">//针对Widget数据而设计的class</span></span><br><span class="line"><span class="keyword">public</span>:                     <span class="comment">//细节不重要</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;            <span class="comment">//可能有很多数据，</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;  <span class="comment">//意味复制时间很长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>       </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//复制Widget时，令它复制其WidgetImpl对象</span></span><br><span class="line">        ...                                 <span class="comment">//关于operator=的一般性实现细节</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一旦要置换两个Widget对象值，我们唯一需要做的就是置换其pImpl指针，但缺省的swap算法不知道这一点。它不只复制三个Widget，还复制三个WidgetImpl对象，非常缺乏效率！一点也不令人兴奋。</p>
<p>&emsp;&emsp;我们希望能够告诉std::swap：当Widget被置换时真正该做的是置换其内部的pImpl指针。确切实践这个思路的一个做法是：将std::swap针对Widget特化。下面是基本构想，但目前这个形式无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;  <span class="comment">//目前还不能通过编译。</span></span><br><span class="line">    swap(a.pImpl, b.pImpl);                <span class="comment">//只要置换其pImpl指针就好了。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个函数一开始的“template&lt;&gt;”表示它是std::swap的一个全特化版本，函数名称之后的“&lt;Widget&gt;”表示这一特化版本是针对“T是Widget”而设计。换句话说当一般性的swap template施行于Widget身上便会启用这个版本。通常我们不能够（不被允许）改变std命名空间内的任何东西，但可以为标准template制造特化版本，使它专属于我们自己的class。以上作为正是如此。</p>
<p>&emsp;&emsp;但是，这个函数无法通过编译。因为它企图访问a和b内的pImpl指针，而那却是private。我们可以将这个特化版本说明为friend，但和以往的规矩不太一样：我们令Widget声明一个名为swap的public成员函数做真正的置换工作，然后将std::swap特化，令它调用该成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(pImpl, other.pImpl);  <span class="comment">//若要置换Widget就置换其pImpl指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">    a.swap(b);  <span class="comment">//若要置换Widget，调用其swap成员函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种做法不只能够通过编译，还与STL容器有一致性，因为所有STL容器也都提供有public swap成员函数和std::swap特化版本（用以调用前者）。</p>
<p>&emsp;&emsp;然而假设Widget和WidgetImpl都是class template而非class，也许我们可以试试将WidgetImpl内的数据加以参数化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在Widget内（以及WidgetImpl内，如果需要的话）放个swap成员函数就像以往一样简单，但我们却在特化std::swap时遇上乱流。我们想写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt; Widget&lt;T&gt; &gt; (Widget&lt;T&gt;&amp; a, Widget&lt;T&gt; b) &#123;  <span class="comment">//错误！不合法！</span></span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来合情合理，却不合法。是这样的，我们企图偏特化一个function template（std::swap），但C++只允许对class template偏特化，在function template身上偏特化是行不通的。这段代码不该通过编译（虽然有些编译器错误地接受了它）。</p>
<p>&emsp;&emsp;当你打算偏特化一个function template时，习惯做法是简单地为它添加一个重载版本，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;  <span class="comment">//这也不合法</span></span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般而言，重载functon template没有问题，但std是个特殊的命名空间，其管理规则也比较特殊。客户可以全特化std内的template，但不可以添加新的template（或class或function或其它任何东西）到std里头。std的内容完全由C++标准委员会决定，标准委员会禁止我们膨胀那些已经声明好的东西。所谓“禁止”可能会使我们沮丧，其实跨越红线的程序几乎仍可以编译和执行，但它们的行为没有明确定义，如果你希望你的软件有可预期的行为，请不要添加任何新东西到std里头。</p>
<p>&emsp;&emsp;那该如何是好？毕竟我们总是需要一个办法让其它人调用swap时能够取得我们提供的高效的template特定版本。答案很简单，我们还是声明一个non-member swap让它调用member swap，但不再将那个non-member swap声明为std::swap的特化版本或重载版本。为求简化起见，假设Widget的所有相关机能都被置于命名空间WidgetStuff内，整个结果看起来便像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">...                   <span class="comment">//模版化的WidgetImpl等等</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//同前，内含swap成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，任何地点的任何代码如果打算置换两个Widget对象，因而调用swap，C++的名称查找法则会找到WidgetStuff内的Widget专属版本。那正是我们所要的。</p>
<p>&emsp;&emsp;这个做法对class和class template都行得通，所以似乎我们应该在任何时候都使用它，不幸的是有一个理由使你应该为class特化std::swap，所以如果你想让你的“class专属版”swap在尽可能多的语境下被调用，你需得同时在该class所在命名空间内写一个non-member版本以及一个std::swap特化版本。</p>
<p>&emsp;&emsp;顺带一提，如果没有像上面那样额外使用某个命名空间，上述每件事仍然适用（也就是说你还是需要一个non-member swap来调用member swap）。但，何必在global命名空间内塞满各式各样的class，template，functioin，enum，enumerant以及typedef名称呢？难道你对所谓“得体与适度”失去判断力了吗？</p>
<p>&emsp;&emsp;目前为止我所写的每一样东西都和swap编写者有关。换位思考，从客户观点看看事情也有必要。假设你正在写一个function template，其内需要置换两个对象值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;应该调用哪个swap？是std既有的那个一般化版本？还是某个可能存在的特化版本？抑或是一个可能存在的T专属版本而且可能栖身于某个命名空间（但当然不可能是std）内？你希望的应该是调用T专属版本，并在该版本不存在的情况下调用std内的一般化版本。下面是你希望发生的事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;   <span class="comment">//令std::swap在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2);  <span class="comment">//为T型对象调用最佳swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一旦编译器看到对swap的调用，它们便查找适当的swap并调用之。C++的名称查找法则确保将找到global作用域或T所在之命名空间内的任何T专属的swap。如果T是Widget并位于命名空间WidgetStuff内，编译器会使用“实参取决之查找范围”找出WidgetStuff内的swap。如果没有T专属之swap存在，编译器就使用std内的swap，只得感谢using声明式让std::swap在函数内曝光。然而即便如此编译器还是比较喜欢std::swap的T专属特化版，而非一般化的那个template，所以如果你已针对T将std::swap特化，特化版会被编译器挑中。</p>
<p>&emsp;&emsp;因此，令适当的swap被调用是很容易的。需要小心的是，别为这一调用添加额外修饰符，因为那会影响C++挑选适当函数。假设你以这种方式调用swap：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::swap(obj1, obj2);  <span class="comment">//这是错误的swap调用方式</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这便迫使编译器只认std内的swap（包括其任何template特化），因而不再可能调用一个定义于它处的较适当T专属版本。某些迷途程序员的确以此方式修饰swap调用式，而那正是“你的class对std::swap进行全特化”的重要原因：它使得类型专属之swap实现版本也可被这些“迷途代码”所用（这样的代码出现在某些标准程序库实现版中，如果你有兴趣不妨帮助这些代码尽可能高效运作）。</p>
<p>&emsp;&emsp;此刻，我们已经讨论过default swap、member swap、non-member swap、std::swap特化版本、以及对swap的调用，现在让我把整个形势做个总结。</p>
<p>&emsp;&emsp;首先，如果swap的缺省实现版的效率不足（那几乎总是意味你的class或template使用了某种pimpl手法），试着做以下事情：</p>
<ol>
<li>提供一个public swap成员函数，让它高效地置换你的类型的两个对象值。这个函数绝不该抛出异常。</li>
<li>在你的class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数。</li>
<li>如果你正编写一个class（而非class template），为你的class特化std::swap。并令它调用你的swap成员函数。</li>
</ol>
<p>&emsp;&emsp;最后，如果你调用swap，请确定包含一个using声明式，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符，赤裸裸地调用swap。</p>
<p>&emsp;&emsp;唯一还未明确的是我的劝告：成员版swap绝不可抛出异常。那是因为swap的一个最好的应用是帮助class（和class template）提供强烈的异常安全性保障。但此技术基于一个假设：成员版的swap绝不抛出异常。这一约束只施行于成员版！不可施行于非成员版，因为swap缺省版本是以copy构造函数和copy assignment操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定版本的swap，往往提供的不只是高效置换对象值的办法，而且不抛出异常。一般而言这两个swap特性是连在一起的，因为高效率的swap几乎总是基于对内置类型的操作（例如pimpl手法的底层指针），而内置类型上的操作绝不会抛出异常。</p>
<blockquote>
<p>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数部抛出异常。</p>
<p>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于class（而非template），也请特化std::swap。</p>
<p>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</p>
<p>为“用户定义类型”进行std template全特化是好的，但千万不要尝试在std内加入某些队std而言全新的对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>绝不在构造和析构过程中调用virtual函数</title>
    <url>/2020/07/24/%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h1><p>&emsp;&emsp;我们不该在构造函数和析构函数期间调用virtual函数，因为这样的调用不会带来我们预想的结果，就算有我们也不会高兴。如果你同时也是一位Java或C#程序员，那么就更加要注意了，因为这是C++与它们不同的一个地方。</p>
<p>&emsp;&emsp;假设我们有个class继承体系，用来塑模股市交易如买进、卖出的订单等等。这样的交易一定要经过审计，所以每当创建一个交易对象，在审计日志中也需要创建一笔适当记录。下面是一个看起来颇为合理的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span>                           <span class="comment">//所有交易的base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">//做出一份因类型不同而不同</span></span><br><span class="line">                                              <span class="comment">//的日志记录（log entry）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;；</span><br><span class="line">Transaction::Transactionn() &#123;                 <span class="comment">//base class构造函数的实现</span></span><br><span class="line">    ...</span><br><span class="line">    logTransaction();                         <span class="comment">//最后动作是记录这笔交易</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;    <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//记录此类交易</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;   <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//记录此类交易</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，当执行一下这行时，会发生什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;无疑会有一个BuyTransaction构造函数被调用，但首先Transaction构造函数一定会更早被调用；没错，derived class对象内的base class成分会在derived class自身成分被构造之前先构造妥当。Transaction构造函数的最后一行调用virtual函数logTransaction，这正是奇怪的地方。这时候被调用的logTransaction是Transaction内的版本，不是buyTransaction内的版本——即使目前即将建立的对象类型是buyTransaction。没错，base class构造期间virtual函数绝不会下降到derived classs阶层。取而代之的是，对象的作为就像隶属base类型一样。非正式的说法或许比较传神：在base class构造期间，virtual函数不是virtual函数。</p>
<p>&emsp;&emsp;这一似乎反直觉的行为有个好的解释。由于base class构造函数的执行更早于derived class构造函数，当base class构造函数执行时derived class的成员变量尚未初始化。如果此期间调用的virtual函数下降至derived class阶层，要知道derived class的函数几乎必然取用local成员变量，而那些成员变量尚未初始化。这将是一张通往不明确行为和彻夜调试大会的直达车票。“使用对象内部尚未初始化的成分”是及其危险的，所以C++允许我们这样做。</p>
<p>&emsp;&emsp;其实还有比上述理由更根本的原因：在derived class对象的base class构造期间，对象的类型是base class而不是derived class。不只virtual函数会被编译器解析至base class，若使用运行期类型信息（例如dynamic_cast和typeid），也会把对象视为base class类型。本例之中，当Transaction构造函数正执行起来打算初始化“BuyTransaction对象内的base class成分”时，该对象的类型时Transaction。这个对象内的“BuyTransaction专属成分”尚未被初始化，所以面对它们，最安全的做法就是视它们不存在。对象在derived class构造函数开始执行前不会成为一个derive的对象。</p>
<p>&emsp;&emsp;相同的道理也适用于析构函数。一旦derived class析构函数开始执行，对象内的derived class成员变量便呈现未定义值，所以C++视它们仿佛不再存在。进入base class析构函数后对象就成为一个base class对象，而C++的任何部分包括virtual函数、dynamic_cast等等也就会那么看待它。</p>
<p>&emsp;&emsp;在上述示例中，Transaction构造函数直接调用一个virtual函数，这很明显而且容易看出来，某些编译器会为此发出一个警告信息。即使没有这些警告信息，这个问题在执行前也几乎肯定会变得显而易见，因为logTransaction函数在Transaction内是个pure virtual。除非它被定义（不太有可能）否则程序无法连接，因为连接器找不到必要的Transaction::logTransaction实现代码。</p>
<p>&emsp;&emsp;但是侦测“构造函数或析构函数运行期是否调用virtual函数”并不总是这样轻松。如果Transaction有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复的一个优秀做法是把共同的初始化代码（其中包括对logTransaction的调用）放进一个初始化函数如init内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction() &#123; init(); &#125;  <span class="comment">//调用non-virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        logTransaction();  <span class="comment">//这里调用virtual！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码概念上和之前版本相同，但它比较隐蔽，因为它通常不会引发任何编译器和连接器的抱怨。此时由于logTransaction是Transaction内的一个pure virtual函数，当pure virtual函数被调用，大多数执行系统会中止程序（通常会对此结果发出一个信息）。然而如果logTransaction是个正常的virtual函数并在Transaction内带有一份实现代码，该版本就会被调用，而程序也就会兴高采烈地继续向前执行，之后我们便会百思不得其解：为什么建立一个derived class对象时会调用错误版本的logTransaction。唯一能够避免此问题的做法就是：确定我们的构造函数和析构函数都没有（在对象被创建和被销毁期间）调用virtual函数，而它们调用的所有函数也都服从同一个约束。</p>
<p>&emsp;&emsp;但我们如何确保每次一有Transaction继承体系上的对象被创建，就会有适当版本的logTransaction被调用呢？很显然，在Transaction构造函数内对对象调用virtual函数是一种错误做法。</p>
<p>&emsp;&emsp;有其他方案可以解决这个问题，一种做法是在class Transaction内将logTransaction函数改为non-virtual，然后要求derived class构造函数传递必要信息给Transaction构造函数，而后那个构造函数便可安全地调用non-virtual logTransaction。像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(cosnt <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span> cosnt</span>;  <span class="comment">//如今是个non-virtual函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo) &#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo);  <span class="comment">//如今是个non-virtual调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction(parameters)</span><br><span class="line">        : Transaction(createLogString(parameters)) &#123;  <span class="comment">//将log信息传给base class构造函数</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;换句话说由于我们无法使用virtual函数从base class向下调用，在构造期间，我们可以藉由“令derived class将必要的构造信息向上传递至base class构造函数”替换之而加以弥补。</p>
<p>&emsp;&emsp;在本例中BuyTransaction内的private static函数createLogString的作用：比起在成员初值列内给予base class所需数据，利用辅助函数创建一个值传给base class构造函数往往比较方便（也比较可读）。令此函数为static，也就不可能意外指向“初期未成熟的BuyTransaction对象内尚未初始化的成员变量”。这很重要，正是因为“那些成员变量处于未定义状态”，所以“在base class构造和析构期间调用的virtual函数不可下降至derived class”。</p>
<blockquote>
<p>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>若不想使用编译器自动生成的函数就该明确拒绝</title>
    <url>/2020/07/21/%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/</url>
    <content><![CDATA[<hr>
<h1 id="若不想使用编译器自动生成的函数就该明确拒绝"><a href="#若不想使用编译器自动生成的函数就该明确拒绝" class="headerlink" title="若不想使用编译器自动生成的函数就该明确拒绝"></a>若不想使用编译器自动生成的函数就该明确拒绝</h1><p>&emsp;&emsp;地产中介商卖的是房子，一个中介软件系统自然而然想必有个class用来描述待售房屋：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每一位真正的地产中介商都会说，任何一笔资产都是独一无二的，没有两笔完全相像。因此我们也认为，为HomeForSale对象做一份副本有点没道理。我们怎么可以复制某些先天独一无二的东西呢？因此，我们应该乐意看到HomeForSale的对象拷贝动作以失败收场：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HomeForSale h1;</span><br><span class="line">HomeForSale h2;</span><br><span class="line"><span class="function">HomeForSale <span class="title">h3</span><span class="params">(h1)</span></span>;  <span class="comment">//企图拷贝h1，不该通过编译</span></span><br><span class="line">h1 = h2;             <span class="comment">//企图拷贝h2，也不该通过编译</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通常如果我们不希望class支持某一个特定功能，只要不声明对应函数就是了。但这个策略对copy构造函数和copy assignment操作符却不起作用，因为如果我们不声明它们，而某些人尝试调用它们，编译器会为我们声明它们。</p>
<p>&emsp;&emsp;这使我们陷入了两难的境况。答案的关键是，所有编译器产出的函数都是public。为阻止这些函数被创建出来。我们得自行声明它们，但这里并没有什么需求使我们必须将它们声明为public。因此我们可以将copy构造函数或copy assignment操作符声明为private。明确声明一个成员函数，我们阻止了编译器暗自创建其专属版本；而令这些函数为private，使我们得以成功阻止人们调用它。</p>
<p>&emsp;&emsp;一般而言这个做法并不绝对安全，因为member函数和friend函数还是可以调用我们的private函数。除非我们足够聪明，不去定义它们，那么如果某些人不慎调用任何一个，会获得一个连接错误（Linkage error）。“将成员函数声明为private而且故意不实现它们”这一技术是广受欢迎的，因而被用在C++ iostream程序库中阻止copy行为。没错，当我们看看手上的标准程序库实现代码中的ios_base，basic_ios和sentry。我们会发现无论哪一个，其copy构造函数和copy assignment操作符都被声明为private而且没有定义。</p>
<p>&emsp;&emsp;将这个技巧用于HomeForSale也很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    HomeForSale(<span class="keyword">const</span> HomeForSale);  <span class="comment">//只有声明</span></span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale)&amp;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;或许你注意到了，我没有写函数参数的名称。其实，参数名称并非必要，只不过大家总是习惯写出来。这个函数毕竟不会被实现出来，也很少被使用，指定参数名称又有何用？</p>
<p>&emsp;&emsp;有了上述class定义，当客户企图拷贝HomeForSale对象，编译器会阻挠他，如果我们不慎在member函数或friend函数之内那么做，就轮到连接器发出抱怨了。</p>
<p>&emsp;&emsp;将连接期错误移至编译期是可能的（而且这是好事，毕竟越早侦测出错误越好），只要将copy构造函数和copy assignment操作符声明为private就可以办到，但不是在HomeForSale自身，而是在一个专门为了阻止copy动作而设计的base class内。这个base class非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:          <span class="comment">//允许derived对象构造和析构             </span></span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);  <span class="comment">//但阻止copy</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为求阻止HomeForSale对象被拷贝，我们唯一需要做的就是继承Uncopyable：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span> <span class="keyword">private</span> Uncopyable &#123;  <span class="comment">//不再声明</span></span><br><span class="line">    ...                                  <span class="comment">//copy构造函数或</span></span><br><span class="line">&#125;;                                       <span class="comment">//copy assignment操作符</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是可行的，因为只要任何人——甚至是member函数或friend函数——尝试拷贝HomeForSale对象，编译器便试着生成一个copy构造函数和一个copy assignment操作符，这些函数的“编译器生成版”会尝试调用其base class的对应兄弟，那些调用会被编译器拒绝，因为其base class的拷贝函数是private。</p>
<blockquote>
<p>为驳回编译器自动提供的功能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>视C++为一个语言联邦</title>
    <url>/2020/07/17/%E8%A7%86C++%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/</url>
    <content><![CDATA[<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><p>&emsp;&emsp;一开始，C++只是C加上一些面向对象特性。C++最初的名称C with Classes也反映了这个血缘关系。</p>
<p>&emsp;&emsp;但是当这个语言逐渐成熟，它变得更活跃更无拘束，更大胆更冒险，开始接受不同于C with Classes的各种观念、特性和编程战略。Exception（异常）对函数的结构化带来不同的做法，templates（模板）将带来新的设计思考方式，STL则定义了一个全新的伸展性做法。</p>
<p>&emsp;&emsp;今天的C++已经是一个多重范型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。那么该如何理解这样的一个语言呢?</p>
<p>&emsp;&emsp;最简单的方法是将C++视为一个由相关语言组成的联邦而非单一语言。在其某个次语言中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而从一个次语言移往另一个次语言，守则可能改变。所幸的是C++的次语言总共只有四个：</p>
<ul>
<li>C。说到底C++仍是以C为基础。区块、语句、预处理器、内置数据类型、数组、指针等统统来自C。许多时候C++对问题的解法其实不过就是较高级的C解法。</li>
<li>Object-Oriented C++。这部分也就是C with Classes所诉求的：classes（包括构造函数和析构函数），封装、继承、多态、virtual函数（动态绑定）……等等。这一部分是面向对象设计之古典守则在C++上的最直接实施。</li>
<li>Template C++。这是C++的泛型编程部分，也是大多数程序员经验最少的部分（C++程序员）。实际上由于templates威力强大，它带来了崭新的编程范式，也就是所谓的templates metaprogramming（TMP，模板元编程）。</li>
<li>STL。STL是个tamplate程序库。它对容器、迭代器、算法以及函数对象的规约有极佳的紧密配合与协调。</li>
</ul>
<p>&emsp;&emsp;当我们从一个次语言切换到另一个，需要改变策略。例如对内置（也就是C-like）类型而言pass-by-value通常比pass-by-reference高效，但当我们从C part of C++移往Object-Oriented C++，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好。然而一旦跨入STL就会了解，迭代器和函数对象都是在C指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的C pass-by-value守则在此之前适用。</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>若所有参数皆需类型转换，请为此采用non-member函数</title>
    <url>/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="若所有参数皆需类型转换，请为此采用non-member函数"><a href="#若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数皆需类型转换，请为此采用non-member函数"></a>若所有参数皆需类型转换，请为此采用non-member函数</h1><p>&emsp;&emsp;令class支持隐式类型转换通常是个糟糕的主意。当然这条规则有其例外，最常见的例外是在建立数据类型时。假设我们这样开始我们的Rational class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你想支持算术运算诸如加法、乘法等等，但你不确定是否该由member函数、non-member函数，或可能的话由non-member friend函数来实现它们。你的直觉告诉你，当你犹豫就该保持面向对象精神。你知道有理数相乘和Rational class有关，因此很自然地似乎该在Rational class内为有理数实现operator*。先研究一下将operator*写成Rational成员函数的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个设计使你能够将两个有理数以最轻松自在的方式相乘：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEight;  <span class="comment">//很好</span></span><br><span class="line">result = result * oneEight;            <span class="comment">//很好</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但我们还不满足。我们希望支持混合运算，也就是拿Rational和例如int相乘。毕竟很少有什么东西会比两个数值相乘更自然的来——即使是两个不同类型的数值。</p>
<p>&emsp;&emsp;然而当我们尝试混合式算术，我们发现只有一半行得通：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;  <span class="comment">//很好！</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这不是好兆头，乘法应该满足交换律，不是吗？</p>
<p>&emsp;&emsp;当我们以对应的函数形式重写上述两个式子，问题所在便一目了然：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);  <span class="comment">//很好！</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;没错，oneHalf是一个内含operator*函数的class的对象，所以编译器调用该函数。然而整数2并没有相应的class，也就没有operator*成员函数。编译器也会尝试寻找可被以下这般调用的non-member operator*（也就是在命名空间内或在global作用域内）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = <span class="keyword">operator</span>*(<span class="number">2</span>, oneHalf);  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但本例根本并不存在这样一个接受int和Rational作为参数的non-member operator*，因此查找失败。</p>
<p>&emsp;&emsp;再看看先前成功的那个调用，注意其第二参数是整数2，但Rational::operator*需要的实参却是个Rational对象。这里发生了什么事？为什么2在这里可被接受，在另一个调用中却不被接受？</p>
<p>&emsp;&emsp;因为这里发生了所谓隐式转换。编译器知道你正在传递一个int，而函数需要的是Rational；但它也知道只要调用Rational构造函数并赋予你所提供的int，就可以变出一个适当的Rational来。于是它就那样做了。换句话说此调用动作在编译器眼中有点像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;   <span class="comment">//根据2建立一个暂时性的Rational对象</span></span><br><span class="line">result = oneHalf * temp;  <span class="comment">//等同于oneHalf.operator*(temp)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，只因为涉及non-explicit构造函数，编译器才会这样做。如果Rational构造函数是explicit，以下语句没有一个可通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;  <span class="comment">//错误！</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这就很难让Rational class支持混合式算术运算了，不过至少上述两个句子的行为从此一致。</p>
<p>&emsp;&emsp;然而我们的目标不仅在一致性，也要支持混合式运算。为什么即使Rational构造函数不是explicit，仍然只有一个可通过编译，另一个不可以：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;  <span class="comment">//没问题（在non-explicit构造函数的情况下）</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">//错误（甚至在non-explicit构造函数的情况下）</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结论是，只有当参数被列于参数列内，这个参数才是隐式类型转换的合格参与者。地位相当于“被调用的成员函数所隶属的那个对象”——即this对象——的那个隐喻参数，绝不是隐式转换的合格参与者。这就是为什么上述第一次调用可通过编译，第二次调用则否，因为第一次调用伴随一个放在参数列内的参数，第二次则否。</p>
<p>&emsp;&emsp;然而我们一定也会想要支持混合式算术运算。让operator*成为一个non-member函数，允许编译器在每一个实参身上执行隐式类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    ...  <span class="comment">//不包括operator*</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lsh, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>;</span><br><span class="line">result = <span class="number">2</span> * oneFourth;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这当然是个快乐的结局，不过还有一点必须操心：operator*是否应该成为Rational class的一个friend函数呢？</p>
<p>&emsp;&emsp;就本例而言答案是否定的，因为operator*可以完全藉由Rational的public接口完成任务，这导出一个重要的观察：member函数的反面是non-member，不是friend函数。太多C++程序员假设，如果一个“与某class相关”的函数不该成为一个member，就该是个friend。本例表明这样的理由过于牵强。无论何时如果我们可以避免friend函数就该避免，因为就像真实世界一样，朋友带来的麻烦往往多过其价值。当然有时候friend有其正当性，但这个事实依然存在：不能够只因函数不该成为member，就自动让它成为friend。</p>
<blockquote>
<p>如果你需要为某个函数的所有参数（包括this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>让接口容易被正确使用，不易被误用</title>
    <url>/2020/07/31/%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h1 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h1><p>&emsp;&emsp;C++在接口之海漂浮。function接口、class接口、template接口……每一种接口都是客户与我们的代码互动的手段。理想上，如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码不该通过编译；如果代码通过了编译，它的作为就是客户所想要的。</p>
<p>&emsp;&emsp;欲开发一个“容易被正确使用，不容易被误用”的接口，首先必须考虑客户可能做出什么样的错误。假设我们为一个用来表现日期的class设计构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> month, <span class="keyword">int</span> day, <span class="keyword">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;乍看之下这个接口通情达理（至少在美国如此），但它的客户很容易犯下两个错误，第一，他们也许会以错误的次序传递参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>, <span class="number">2020</span>)</span></span>;  <span class="comment">//应该是“2，20”而不是“20，2”</span></span><br></pre></td></tr></table></figure>

<p>第二，他们可能传递一个无效的月份或天数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">3</span>, <span class="number">20</span>, <span class="number">2020</span>)</span>  <span class="comment">//应该是“2，20”而不是“3，20”</span></span></span><br></pre></td></tr></table></figure>

<p>（上面一个例子也许看起来很蠢，但别忘了，键盘上的2就在3旁边。打岔一个键的情况并不是太罕见。）</p>
<p>&emsp;&emsp;许多客户端错误可以因为导入新类型而获得预防。在防范“不值得拥有的代码”上，类型系统是我们的主要同盟国。既然这样，就让我们导入简单的外覆类型来区别天数、月份和年份，然后于Date构造函数中使用这些类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="keyword">int</span> d)</span>: <span class="title">val</span><span class="params">(d)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span>: <span class="title">val</span><span class="params">(m)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">year</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="keyword">int</span> y)</span>: <span class="title">val</span><span class="params">(y)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">const</span> Month&amp; m, <span class="keyword">const</span> Day&amp; d, <span class="keyword">const</span> Year&amp; y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>, <span class="number">2020</span>)</span></span>;                    <span class="comment">//错误！不正确的类型</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">20</span>), Month(<span class="number">2</span>), Year(<span class="number">2020</span>))</span></span>;  <span class="comment">//错误！不正确的类型</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">2</span>), Day(<span class="number">20</span>), Year(<span class="number">2020</span>))</span></span>;  <span class="comment">//正确！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;令Day，Month和Year成为成熟且经过充分锻炼的class并封装其内部数据，比简单使用上述的struct好。但即使struct也已经足够示范：明智而谨慎地导入新类型对预防“接口被误用”有神奇疗效。</p>
<p>&emsp;&emsp;一旦正确的类型就位，限制其值有时候是通情达理的。例如一年只有12个月份，所以Month应该反映这一事实。办法之一是利用enum表现月份，但enums不具备我们希望拥有的类型安全性，例如enums可被拿来当一个int使用，比较安全的解法是预先定义所有有效的Month：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">1</span>); &#125;  <span class="comment">//函数，返回有效月份</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">2</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">12</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span></span>;  <span class="comment">//阻止生成新的月份</span></span><br><span class="line">    ...                     <span class="comment">//这是月份专属数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Feb(), Day(<span class="number">20</span>), Year(<span class="number">2020</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;“以函数替代对象，表现某个特定月份”这并不像你所想象的那样诡异，这是因为non-local static对象的初始化次序有可能出现问题。</p>
<p>&emsp;&emsp;预防客户错误的另一个办法是，限制类型内什么事可做，什么事不能做。常见的限制是加上const。</p>
<p>&emsp;&emsp;避免无端与内置类型不兼容，真正的理由是为了提供行为一致的接口。很少有其它性质比得上“一致性”更能导致“接口容易被正确使用”，也很少有其它性质比得上“不一致性”更加剧接口的恶化。STL容器的接口十分一致（虽然不是完美地一致），这使它们非常容易被使用。例如每个STL容器都有一个名为size的成员函数，它会告诉调用者目前容器内有多少对象。与此对比的是Java，它允许我们针对数组使用length property，对String使用length method，而对List使用size method；.Net也一样混乱。有些开发人员会以为整合开发环境（IDE）能使这样的不一致性变得不重要，但他们错了。不一致性对开发人员造成的心理和精神上的摩擦与争执，没有任何一个IDE可以完全抹除。</p>
<p>&emsp;&emsp;任何接口如果要求客户必须记得做某些事情，就是有着“不正确使用”的倾向，因为客户有可能会忘记做那件事。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;  ／／factory函数</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为避免资源泄漏，createInvestment返回的指针最终必须被删除，但这至少给了客户两个犯错的机会：没有删除指针，或删除同一个指针超过一次。</p>
<p>&emsp;&emsp;许多时候较佳接口的设计原则是先发制人，就令factory函数返回一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这便实质上强迫客户将返回值存储于一个shared_ptr内，几乎消除了忘记删除底部Investment对象的可能性。</p>
<p>&emsp;&emsp;shared_ptr允许当智能指针被建立起来时指定一个资源释放函数（所谓删除器，“deleter”）绑定于智能指针身上。</p>
<p>&emsp;&emsp;假设class设计者期许那些“从createInvestment取得Investment*指针”的客户将该指针传递给一个名为getRidOfInvestment的函数，而不是直接在它身上动刀子（使用delete）。这样一个接口又开启通往另一个客户错误的大门，该错误是“企图使用错误的资源析构机制”（也就是拿delete替换getRidOfInvestment）。createInvestment的设计者可以针对此问题先发制人：返回一个“将getRidOfInvestment绑定为删除器（deleter）”的shared_ptr。</p>
<p>&emsp;&emsp;shared_ptr提供的某个构造函数接受两个实参：一个是被管理的指针，另一个是引用次数变成0时将被调用的“删除器”。这启发我们创建一个null shared_ptr并以getRidOfInvestment作为其删除器，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="number">0</span>, getRidOfInvestment)</span></span>; </span><br><span class="line"><span class="comment">//此式无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这并不是有效的C++。shared_ptr构造函数坚持其第一参数必须是个指针，而0不是指针，是个int。没错，它可被转换为指针，但在此情况下并不够好，因为shared_ptr坚持要一个不折不扣的指针。转型可以解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt;</span><br><span class="line">    pInv(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>),</span><br><span class="line">        getRidOfInvestment);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因此，如果我们要实现createInvestment使它返回一个shared_ptr并夹带getRidOfInvestment函数作为删除器，代码看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                                       getRidOfInvestment)</span></span>;</span><br><span class="line">    retVal = ...;  <span class="comment">//令retVal指向正确对象</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然啦，如果被pInv管理的原始指针可以在建立pInv之前先确定下来，那么“将原始指针传给pInv构造函数”会比“先将pInv初始化为null再对它做一次赋值操作”为佳。</p>
<p>&emsp;&emsp;shared_ptr有一个特别好的性质是：它会自动使用它的“每个指针专属的删除器”，因而消除另一个潜在的客户错误：所谓的“cross-DLL problem”。这个问题发生于“对象在动态链接程序库（DLL）中被new创建，却在另一个DLL内被delete销毁”。在许多平台上，这一类“跨DLL之new／delete成对运用”会导致运行期错误。shared_ptr没有这个问题，因为它缺省的删除器是来自“shared_ptr诞生所在的那个DLL”的delete。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt;(<span class="keyword">new</span> Stock);  <span class="comment">//Stock派生自Investment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;返回的那个shared_ptr可被传递给任何其它DLL，无需在意“cross-DLL problem”。这个指向Stock的shared_ptr会追踪记录“当Stock的运用次数变成0时该调用的那个DLL’s delete”。</p>
<p>&emsp;&emsp;shared_ptr是原始指针的两倍大，以动态分配内存作为记录用途和“删除器的专属数据”，并以virtual形式调用删除器，并在多线程程序修改运用次数时承受线程同步化的额外开销。（只要定义一个预处理器符号就可以关闭多线程支持）。总之，它比原始指针大且慢，而且使用辅助动态内存。在许多运用程序中这些额外的执行成本并不显著。然而其“降低客户错误”的成效却是每个人都看得到的。</p>
<blockquote>
<p>好的接口很容易被正确使用，不容易被误用。我们应该在所有的接口中努力达成这些性质</p>
<p>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</p>
<p>“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。</p>
<p>shared_ptr支持定制删除器。这可防范DLL问题，可被用来自动解除互斥锁等等。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计class犹如设计type</title>
    <url>/2020/08/01/%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/</url>
    <content><![CDATA[<hr>
<h1 id="设计class犹如设计type"><a href="#设计class犹如设计type" class="headerlink" title="设计class犹如设计type"></a>设计class犹如设计type</h1><p>&emsp;&emsp;C++就像在其它OOP语言一样，当我们定义一个新class，也就定义了一个新type。身为C++程序员，我们的许多时间主要用来扩张我们的类型系统。这意味着我们并不只是class设计者，还是type设计者。</p>
<p>&emsp;&emsp;设计优秀的class是一项艰巨的工作，因为设计好的type是一项艰巨的工作。好的type有自然的语法，直观的语义，以及一或多个高效实现品。在C++中，一个不良规划下的class定义恐怕无法达到上述任何一个目标。</p>
<p>&emsp;&esmp;那么，如何设计高效的class呢？几乎每个class都要求我们面对以下提问，而我们的回答往往导致我们的设计规范：</p>
<ul>
<li><strong>新type的对象应该如何被创建和销毁？</strong>这会影响到我们的class的构造函数和析构函数以及内存分配函数和释放函数的设计，当然前提是如果我们打算编写它们。</li>
<li><strong>对象的初始化和对象的赋值该有什么样的差别？</strong>这个答案决定我们的构造函数和赋值操作符的行为，以及其间的差异。重要的是别混淆了“初始化”和赋值“，因为它们对应不同的函数调用。</li>
<li><strong>新type的对象如果被passed by value，意味着什么？</strong>记住，copy构造函数用来定义一个type的pass-by-value该如何实现。</li>
<li><strong>什么是新type的“合法值”？</strong>对class的成员变量而言，通常只有某些数值集是有效的，那些数值集决定了我们的class必须维护的约束条件，也就决定了我们的成员函数（特别是构造函数、赋值操作符和所谓“setter”函数）必须进行的错误检查工作，它也影响函数抛出的异常。</li>
<li><strong>你的新type需要配合某个继承图系吗？</strong>如果我们继承自某些既有的class，我们就受那些class的设计的束缚，特别是受到”它们的函数是virtual或non-virtual“的影响。如果我们允许其它class继承我们的class，这会影响我们所声明的函数——尤其是析构函数——是否为virtual。</li>
<li><strong>你的新type需要什么样的转化？</strong>如果希望允许类型T1之物被隐式转换为类型T2之物，就必须在class T1内写一个类型转换函数（operator T2）或在class T2内写一个non-explicit-one-argument（可被单一实参调用）的构造函数。如果我们只允许explicit构造函数存在，就得写出专门负责执行转换的函数，且不得为类型转换操作符或non-explicit-one-argument构造函数。</li>
<li><strong>什么样的操作符和函数对此新type而言是合理的？</strong>这个问题的答案决定你将为你的class声明哪些函数。其中某些该是member函数，某些则否。</li>
<li><strong>什么样的标准函数应该驳回？</strong>那些正是你必须声明为private者。</li>
<li><strong>谁该取用新type的成员？</strong>这个提问可以帮助你决定哪个成员为public，哪个为protected，哪个为private。它也帮助你决定哪一个class或function应该是friend，以及将它们嵌套于另一个之内是否合理。</li>
<li><strong>什么是新type的“未声明接口”？</strong>它对效率、异常安全性以及资源运用提供何种保证？你在这些方面提供的保证将为你的class实现代码加上相应的约束条件。</li>
<li><strong>你的新type有多么一般化？</strong>或许你其实并非定义一个新type，而是定义一整个type家族。果真如此你就不该定义一个新class，而是定义一个新的class template。</li>
<li><strong>你真的需要一个新type吗？</strong>如果只是定义新的derived class以便为既有的class添加机能，那么说不定单纯定义一个或多个non-member函数或template，更能够达到目标。</li>
</ul>
<p>&emsp;&emsp;这些问题不容易回答，所以定义出高效的class是一种挑战。然而如果能够设计出至少像C++内置类型一样好的用户自定义class，一切汗水便都值得。</p>
<blockquote>
<p>class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款所覆盖的所有讨论主题。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>透彻了解inlining的里里外外</title>
    <url>/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/</url>
    <content><![CDATA[<hr>
<h1 id="透彻了解inlining的里里外外"><a href="#透彻了解inlining的里里外外" class="headerlink" title="透彻了解inlining的里里外外"></a>透彻了解inlining的里里外外</h1><p>&emsp;&emsp;inline函数，多棒的点子！它们看起来像函数，动作像函数，比宏好得多（见“<a href="/2020/07/17/%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%E6%9B%BF%E6%8D%A2define/" title="尽量以const,enum,inline替换define">尽量以const,enum,inline替换define</a>”），可以调用它们又不需要蒙受函数调用所招致的额外开销。你还能要求更多吗？</p>
<p>&emsp;&emsp;你实际获得的比想到的还多，因为“免除函数调用成本”只是故事的一部分而已。编译器最优化机制通常被设计用来浓缩那些“不含函数调用”的代码，所以当你inline某个函数，或许编译器就因此有能力对它（函数本体）执行语境相关最优化。大部分编译器绝不会对着一个“outlined函数调用”动作执行如此之最优化。</p>
<p>&emsp;&emsp;然而编写程序就像现实生活一样，没有白吃的午餐。inline函数也不例外。inline函数背后的整体观念是，将“对此函数的每一个调用”都以函数本体替换之。我想不需要统计学博士来告诉你，这样做可能增加你的目标码大小。在一台内存有限的机器上，过度热衷inlining会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为，降低指令高速缓存装置的击中率，以及伴随这些而来的效率损失。</p>
<p>&emsp;&emsp;换个角度说，如果inline函数的本体很小，编译器针对“函数本体”所产出的码可能比针对“函数调用”所产出的码更小。果真如此，将函数inlining确实可能导致较小的目标码和较高的指令高速缓存装置击中率！</p>
<p>&emsp;&emsp;记住，inline只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出。隐喻方式是将函数定义于class定义式内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125;  <span class="comment">//一个隐喻的inline申请</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的函数通常是成员函数，但friend函数也可被定义于class内，如果真是那样，它们也是被隐喻声明为inline。</p>
<p>&emsp;&emsp;明确声明inline函数的做法则是在其定义式前加上关键字inline。例如标准的max template（来自&lt;algorithm&gt;）往往这样实现出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">std::max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;  <span class="comment">//明确申请inline</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;“max是个template”带出了一项观察结果：我们发现inline函数和template两者通常都是被定义于头文件内。这使得某些程序员以为function template一定必须是inline。这个结论不但无效而且可能有害，值得深入看一看。</p>
<p>&emsp;&emsp;inline函数通常一定被置于头文件内，因为大多数建置环境在编译过程中进行inlining，而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。某些建置环境可以在连接期完成inlining，少量建置环境如基于.NET CLI（Common Language Infrastructure：公共语言基础设施）的托管环境竟可在运行期完成inlining。然而这样的环境毕竟是例外，不是通例。inlining在大多数C++程序中是编译期行为。</p>
<p>&emsp;&emsp;template通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样子。（某些建置环境可以在连接期才执行template具现化。只不过编译期完成具现化动作比较常见。）</p>
<p>&emsp;&emsp;template的具现化与inlining无关。如果你正在写一个template而你认为所有根据此template具现出来的函数都应该inline，请将此template声明为inline：这就是上述std::max代码的作为。但如果你写的template没有理由要求它所具现的每一个函数都是inline，就应该避免将这个template声明为inline（不论显式或隐式）。inlining需要成本，你不会想在没有事先考虑的情况下就招来那些成本吧。我已经提过inlining如何引发代码膨胀，但还存在其它成本，稍后再讨论。</p>
<p>&emsp;&emsp;现在让我们先结束“inline是个申请，编译器可以加以忽略”的观察。大部分编译器拒绝将太过复杂的函数inlining，而所有对virtual函数的调用也都会使inlining落空。这不该令你惊讶，因为virtual意味“等待，知道运行期才确定调用哪个函数”，而inline意味“执行前，先将调用动作替换为被调用函数本体”。如果编译器不知道该调用哪个函数，你就很难责备它们拒绝将函数本体inlining。</p>
<p>&emsp;&emsp;这些整合起来的意思就是：一个表面上看似inline的函数是否真是inline，取决于你的建置环境，主要取决于编译器。幸运的是大多数编译器提供了一个诊断级别：如果它们无法将你要求的函数inline化，会给你一个警告信息。</p>
<p>&emsp;&emsp;有时候虽然编译器有意愿inlining某个函数，还是可能为该函数生成一个函数本体。举个例子，如果程序要取某个inline函数的地址，编译器通常必须为此函数生成一个outline函数本体。毕竟编译器哪有能力提出一个指针指向并不存在的函数呢？与此并提的是，编译器通常不对“通过函数指针而进行的调用”实施inlining，这意味对inline函数的调用有可能被inline，也可能不被inline，取决于对该调用的实施方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> (*pf)() = f;  <span class="comment">//pf指向f</span></span><br><span class="line">...</span><br><span class="line">f();   <span class="comment">//这个调用将被inline，因为它是一个正常调用</span></span><br><span class="line">pf();  <span class="comment">//这个调用或许不被inline，因为它通过函数指针达成</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;即使你从未使用函数指针，“未被成功inline”的inline函数还是有可能缠住你，因为程序员并非唯一要求函数指针的人。有时候编译器会生成构造函数和析构函数的outline副本，如此一来它们就可以获得指针指向那些函数，在array内部元素的构造和析构过程中使用。</p>
<p>&emsp;&emsp;实际上构造函数和析构函数往往是inlining的糟糕候选人——虽然漫不经心的情况下你不会这么认为。考虑以下Derived class构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bm1, bm2;  <span class="comment">//base成员1和2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> dm1, dm2, dm3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个构造函数看起来是inlining的绝佳候选人，因为它根本不含任何代码。但是你的眼睛可能会欺骗你。</p>
<p>&emsp;&emsp;C++对于“对象被创建和被销毁时发生什么事”做了各式各样的保证。当你使用new，动态创建的对象被其构造函数自动初始化；当你使用delete，对应的析构函数会被调用。当你创建一个对象，其每一个base class及每一个成员变量都会被自动构造；当你销毁一个对象，反向程序的析构行为亦会自动发生。如果有个异常在对象构造期间被抛出，该对象已构造好的那一部分会被自动销毁。在这些情况中C++描述了什么一定会发生，但没有说如何发生。“事情如何发生”是编译器实现者的权责，不过至少有一点很清楚，那就是它们不可能凭空发生。你的程序内一定有某些代码让那些事情发生，而那些代码——由编译器于编译期代为产生并安插到你的程序中的代码——肯定存在于某个地方。有时候就放在你的构造函数和析构函数内，所以我们可以想象，编译器为稍早说的那个表面上看起来为空的Derived构造函数所产生的代码，相当于以下所列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived::Derived() &#123;</span><br><span class="line">    Base::Base();                       <span class="comment">//初始化“Base成分”</span></span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.<span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(); &#125;  <span class="comment">//试图构造代码dm1</span></span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;                        <span class="comment">//如果抛出异常就</span></span><br><span class="line">        Base::~Base();                  <span class="comment">//销毁base class成分，并</span></span><br><span class="line">        <span class="keyword">throw</span>;                          <span class="comment">//传播该异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.<span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        dm1.<span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>();</span><br><span class="line">        Base::~Base();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.<span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        dm2.<span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>();</span><br><span class="line">        dm1.<span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>();</span><br><span class="line">        Base::~Base();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码并不能代表编译器真正制造出来的代码，因为真正的编译器会以更精致复杂的做法来处理异常，尽管如此，这已能准确反映Derived的空白构造函数必须提供的行为。不论编译器在其内所做的异常处理多么精致复杂，Derived构造函数至少一定会陆续调用其成员变量和base class两者的构造函数，而那些调用会影响编译器是否对此空白函数inlining。</p>
<p>&emsp;&emsp;相同的道理也适用于Base构造函数，所以如果它被inline，所有替换“Base构造函数调用”而插入的代码也都会被插入到“Derived构造函数调用”内（因为Derived构造函数调用了Base构造函数）。试想下这对于上述代码会带来怎样的灾难。</p>
<p>&emsp;&emsp;程序库设计者必须评估“将函数声明为inline”的冲击：inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个inline函数，客户将“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译。这往往是大家不愿意见到的。然而如果f是non-inline函数，一旦它有任何修改，客户端只需重新连接就好，远比重新编译的负担少很多。如果程序库采取动态连接，升级版函数甚至可以不知不觉地被应用程序吸纳。</p>
<p>&emsp;&emsp;对程序开发而言，将上述所有考虑牢记在心很是重要，但若从纯粹实用观点出发，有一个事实比其它因素更重要：大部分调试器面对inline函数都束手无策。这对你应该不是太大的意外。毕竟你如何在一个并不存在的函数内设立断点呢？虽然某些建置环境勉强支持对inline函数的调试，其它许多建置环境仅仅只能“在调试版程序中禁止发生inlining”。</p>
<blockquote>
<p>将太多inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</p>
<p>不要只因为function template出现在头文件，就将它们声明为inline。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>避免返回handles指向对象内部成分</title>
    <url>/2020/08/10/%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/</url>
    <content><![CDATA[<hr>
<h1 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h1><p>&emsp;&emsp;假设你的程序设计矩形。每个矩形由其左上角和右下角表示。为了让一个Rectangle对象尽可能小，你可能会决定不把定义矩形的这些点存放在Rectangle对象内，而是放在一个辅助的struct内再让Rectangle去指它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span> &#123;</span>  <span class="comment">//这些“点”数据用来表现一个矩形</span></span><br><span class="line">    Point ulhc;    <span class="comment">//左上角</span></span><br><span class="line">    Point lrhc;    <span class="comment">//右下角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Rectangle的客户必须能够计算Rectangle的范围，所以这个class提供upperLeft函数和lowerRight函数。Point是个用户自定义类型，这些函数返回reference，代表底层的Point对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的设计可以通过编译，但却是错误的。实际上它是自我矛盾的。一方面upperLeft和lowerRight被声明为const成员函数，因为它们的目的只是为了提供客户一个得知Rectangle相关坐标点的方法，而不是让客户修改Rectangle。另一方面两个函数都返回reference指向private内部数据，调用者于是可以通过这些reference更改内部数据！例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;  <span class="comment">//rec是个const矩形，从（0，0）到（100，100）</span></span><br><span class="line">rec.upperLeft().setX(<span class="number">50</span>);             <span class="comment">//现在却变成从（50，0）到（100，100）</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里立刻带给我们两个教训。第一，成员变量的封装性最多只等于“返回其reference”的函数的访问级别。本例之中虽然ulhc和lrhc都被声明为private，它们实际上却是public，因为public函数upperLeft和lowerRight传出它们的reference。第二，如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。这正是bitwise constness的一个附带结果。</p>
<p>&emsp;&emsp;我们在这些函数身上遭遇的两个问题可以轻松去除，只要对它们的返回类型加上const即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有了这样的改变，客户可以读取矩形的Point，但不能涂写它们。这意味当初声明upperLeft和upperRight为const不再是个谎言，因为它们不在允许客户更改对象状态。至于封装问题，我们总是愿意让客户看到Rectangle的外围Point，所以这里是蓄意放松封装。更重要的是这是个有限度的放松：这些函数只让渡读取权。涂写权仍然是被禁止的。</p>
<p>&emsp;&emsp;但即使如此，upperLeft和lowerRight还是返回了“代表对象内部”的handle，有可能在其它场合带来问题。更明确地说，它可能导致dangling handle（空悬号码牌）：这种handle所指东西（的所属对象）不复存在。这种“不复存在的对象”最常见的来源就是函数返回值。例如某个函数返回GUI对象的外框，这个外框采用矩形形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIObject</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rectangle</span><br><span class="line">boundingBox(<span class="keyword">const</span> GUIObject&amp; obj);</span><br></pre></td></tr></table></figure>

<p>现在，客户有可能这么使用这个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GUIObject* pgo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> Point* pUpperLeft = &amp;(boundingBox(*pgo).upperLeft());</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对boundingBox的调用获得一个新的、暂时的Rectangle对象。这个对象没有名称，所以我们权且称它为temp。随后upperLeft作用于temp身上，返回一个reference指向temp的一个内部成分，更具体地说是指向一个用以标示temp的Point。于是pUpperLeft指向那个Point对象。目前为止一切还好，但故事尚未结束，因为在那个语句结束之后，boundingBox的返回值，也就是我们所说的temp，将被销毁，而那间接导致temp内的Point析构。最终导致pUpperLeft指向一个不再存在的对象：也就是说一旦产出pUpperLeft的那个语句结束，pUpperLeft也就变成空悬、虚吊！</p>
<p>&emsp;&emsp;这就是为什么函数如果“返回一个handle代表对象内部成分”总是危险的原因。不论这所谓的handle是个指针或迭代器或reference，也不论这个handle是否为const，也不论那个返回handle的成员函数是否为const。这里的唯一关键是，有个handle被传出去了，一旦如此你就是暴露在“handle比其所指对象更长寿”的风险下。</p>
<p>&emsp;&emsp;这并不意味你绝对不可以让成员函数返回handle。有时候你必须那么做。例如operator[]就允许你“摘采”string和vector的个别元素，而这些operator[]就是返回reference指向“容器内的数据”，那些数据会随着容器被销毁而销毁。尽管如此，这样的函数毕竟是少数，不是常态。</p>
<blockquote>
<p>避免返回handle（包括reference、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”的可能性降至最低。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>避免遮掩继承而来的名称</title>
    <url>/2020/10/28/%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<hr>
<h1 id="避免继承而来的名称"><a href="#避免继承而来的名称" class="headerlink" title="避免继承而来的名称"></a>避免继承而来的名称</h1><p>&emsp;&emsp;关于“名称”，莎士比亚说过这样一句话：“名称是什么呢？”他问，“一朵玫瑰叫任何名字还是一样芬芳。</p>
<p>&emsp;&emsp;其实这样的讨论与继承无关，而是和作用域有关。我们都知道再诸如这样的代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;              <span class="comment">//global变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;       <span class="comment">//local变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;  <span class="comment">//读一个新值赋予local变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个读取数据的语句指的是local变量x，而不是global变量x，因为内层作用域的名称会遮掩外围作用域的名称。</p>
<p>&emsp;&emsp;当编译器处于comeFunc的作用域内并遭遇名称x时，它在local作用域内查找是否有什么东西带着这个名称。如果找到就不再找其他作用域。本例到someFunc的x是double类型而global x是int类型，但那不要紧。C++的名称遮掩规则（name-hiding rules）所作的唯一事情就是：遮掩名称。至于名称是否相同或不同的类型，并不重要。本例中一个名为x的double遮掩了一个名为x的int。</p>
<p>&emsp;&emsp;现在导入继承。我们知道，当位于一个derived class成员函数内指涉base class内的某物（也许是个成员函数、typedef、或成员变量）时，编译器可以找出我们所指涉的东西，因为derived class继承了声明于base classes内的所有东西。实际运作方式是，derived class作用域被嵌套在base class作用域内，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此例内含一组混合例public和private名称，以及一组成员变量和成员函数名称。这些成员函数包括pure virtual，impure virtual和non-virtual三种，这是为了强调我们谈的是名称，和其他无关。这个例子也可以加入各种名称类习惯，例如enums，nested classes和typedefs。整个讨论中唯一重要的是这些东西的名称，至于这些东西是什么并不重要。本例使用单一继承，然而一旦了解单一继承下发生的事，很容易就可以推想C++在多重继承下的行为。</p>
<p>&emsp;&emsp;假设derived class内的mf4的实现代码像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::mf4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mf2();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当编译器看到这里使用名称mf2，必须估算它指涉什么东西。编译器的做法是查找各作用域，看看有没有某个名为mf2的声明式。首先查找local作用域（也就是mf4覆盖的作用域），在那儿没找到任何东西名为mf2.于是查找其外围作用域，也就是class Derived覆盖的作用域。还是没找到任何东西名为mf2，于是再往外围移动，本例为base class。在那儿编译器找到一个名为mf2的东西了，于是停止查找。如果Base内还是没有mf2，查找动作继续下去，首先找到内含Base的那个namespace的作用域（如果有的话），最后往global作用域找去。</p>
<p>&emsp;&emsp;再次考虑前一个例子，这次让我们重载mf1和mf3，并且添加一个新版mf3到Derived去。这里发生的事情是：Derived重载了mf3，那是一个继承而来的non-virtual函数。这会使整个设计立刻显得疑雾重重，但为了充分认识继承体系内的“名称可视性”，我们暂时安之若素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> puvlic Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码带来的行为会让每一位第一次面对它的C++程序员大吃一惊。以作用域为基础的“名称遮掩规则”并没有改变，因此base class内所有名为mf1和mf3的函数都被derived class内的mf1和mf3函数遮掩掉了。从名称查找观点来看，Base::mf1和Base::mf3不再被Derived继承！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1();   <span class="comment">//没问题，调用Derived::mf1</span></span><br><span class="line">d.mf1(x);  <span class="comment">//错误！因为Derived::mf1遮掩了Base::mf1</span></span><br><span class="line">d.mf2();   <span class="comment">//没问题，调用Base::mf2</span></span><br><span class="line">d.mf3();   <span class="comment">//没问题，调用Derievd::mf3</span></span><br><span class="line">d.mf3(x);  <span class="comment">//错误！因为Derived::mf3遮掩了Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如你所见，上述规则都适用，即使base class和derived class内的函数有不同的参数类型也适用，而且不论函数是virtual或non-virtual都适用。</p>
<p>&emsp;&emsp;这些行为背后的基本理由是为了防止你在程序库或应用框架内建立新的derived class时附带地从疏远的base class继承重载函数。不幸的是你通常会想继承重载函数。实际上如果你正在使用public继承而又不继承那些重载函数，就是违反base和derived class之间的is-a关系，而“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”说过is-a是public继承的基石。因此你几乎总会想要推翻（override）对“继承而来的名称”的缺省遮掩行为。</p>
<p>&emsp;&emsp;你可以使用using声明式达成目标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> Base::mf1;  <span class="comment">//让Base class内名为mf1和mf3的所有东西</span></span><br><span class="line">        <span class="keyword">using</span> Base::mf3;  <span class="comment">//在Derived作用域内都可见（并且public）</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，继承机制将一如既往地运作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1();   <span class="comment">//仍然没问题，仍然调用Derived::mf1</span></span><br><span class="line">d.mf1(x);  <span class="comment">//现在没问题了，调用Base::mf1</span></span><br><span class="line">d.mf2();   <span class="comment">//仍然没问题，仍然调用Base::mf2</span></span><br><span class="line">d.mf3();   <span class="comment">//没问题，调用Derived::mf3</span></span><br><span class="line">d.mf3(x);  <span class="comment">//现在没问题了，调用Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这意味如果你继承base class并加上重载函数，而你又希望重新定义或覆写其中一部分，那么你必须为那些原本会被遮掩的每个名称引入一个using声明式，否则某些你希望继承的名称会被遮掩。</p>
<p>&emsp;&emsp;有时候你并不想继承base class的所有函数，这是可以理解的。在public继承下，这绝不可能发生，因为它违反了public继承所暗示的“base和derived class之间的is-a关系”。（这也就是为什么上述using声明式被放在derived class的public区域的原因：base class内的public名称在publicly derived class内也应该是public。）然而在private继承之下它却可能是有意义的。例如假设Derived以private形式继承Base，而Derived唯一想继承的mf1是那个无参数版本。using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。不，我们需要不同的技术，即一个简单的转交函数（forwarding function）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        ...  <span class="comment">//同前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>&#123;  <span class="comment">//转交函数；</span></span><br><span class="line">            Base::mf1();      <span class="comment">//暗自成为inline</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">d.mf1();   <span class="comment">//很好，调用的是Derived::mf1</span></span><br><span class="line">d.mf1(x);  <span class="comment">//错误！Base::mf1()被遮掩了</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;inline转交函数的另一个用途是为那些不支持using声明式的老旧编译器另辟一条路，将继承而得的名称汇入derived class作用域内。</p>
<p>&emsp;&emsp;这就是继承和名称遮掩的完整故事。但是当继承结合templates，我们又将面对“继承名称被遮掩”的一个全然不同的形式。</p>
<blockquote>
<ul>
<li>Derived class内的名称会遮掩base class内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>考虑virtual函数以外的其他选择</title>
    <url>/2020/10/31/%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<hr>
<h1 id="考虑virtual函数以外的其他选择"><a href="#考虑virtual函数以外的其他选择" class="headerlink" title="考虑virtual函数以外的其他选择"></a>考虑virtual函数以外的其他选择</h1><p>&emsp;&emsp;假设你正在写一个游戏，你打算为游戏内的人物设计一个继承体系。你的游戏属于砍杀类型，游戏中人物被伤害或因其他因素而降低健康状态的情况并不罕见。你因此决定提供一个成员函数healthValue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将healthValue声明为virtual似乎是再明白不过的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//返回人物的健康指数；</span></span><br><span class="line">        ...                               <span class="comment">//derived class可重新定义它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;healthValue并未被声明为pure virtual，这暗示我们将会有个计算健康指数的缺省算法。</p>
<p>&emsp;&emsp;这的确是再明白不过的设计，但是从某个角度说却反而成为了它的弱点。由于这个设计如此明显，你可能因此没有认真考虑其他替代方案。为了帮助你跳脱面向对象设计上的常轨，让我们考虑其他一些解法。</p>
<h2 id="藉由Non-Virtual-Interface手法实现Template-Method模式"><a href="#藉由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="藉由Non-Virtual Interface手法实现Template Method模式"></a>藉由Non-Virtual Interface手法实现Template Method模式</h2><p>&emsp;&emsp;我们将从一个有趣的思想流派开始，这个流派主张virtual函数应该几乎总是private。这个流派的拥护者建议，较好的设计是保留healthValue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数（例如doHealthValue）进行实际工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;            <span class="comment">//derived class不重新定义它。</span></span><br><span class="line">            ...                              <span class="comment">//做一些事前工作。</span></span><br><span class="line">            <span class="keyword">int</span> retVal = doHealthValue();    <span class="comment">//做真正的工作。</span></span><br><span class="line">            ...                              <span class="comment">//做一些事后工作。</span></span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">//derived class可重新定义它。</span></span><br><span class="line">            ...                              <span class="comment">//缺省算法，计算健康指数。</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这段代码中，我直接在class定义式内呈现成员函数本体。这也就让它们全部暗自成为了inline。但其实我以这种方式呈现代码只是为了让你比较容易阅读。我所描述的设计与inlining其实没有关联，所以请不要认为成员函数在这里被定义于class内有特殊用意。不，它没有。</p>
<p>&emsp;&emsp;这一基本设计，也就是“令客户通过public non-virtual成员函数间接调用private virtual函数”，称为non-virtual interface（NVI）手法。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数（healthValue）称为virtual函数的外覆器（wrapper）。</p>
<p>&emsp;&emsp;NVI手法的一个优点隐身在上述代码注释“做一些事前工作”和“做一些事后工作”之中。那些注释用来告诉你当时的代码保证在“virtual函数进行真正工作之前和之后”被调用。这意味外覆器确保得以在一个virtual函数被调用之前设定好适当场景，并在调用结束之后清理场景。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证class约束条件、验证函数先决条件等等。“事后工作”可以包括互斥器接触锁定、验证函数的事后条件、在此验证class约束条件等等。如果你让客户直接调用virtual函数，就没有任何好办法可以做这些事。</p>
<p>&emsp;&emsp;有件事或许会妨碍你跃跃欲试的心：NVI手法涉及在derived class内重新定义private virtual函数。啊，重新定义若干个derived class并不调用的函数！这里并不存在矛盾。“重新定义virtual函数”表示某些事“如何”被完成，“调用virtual函数”则表示它“何时”被完成。这些事情都是各自独立互不相干的。NVI手法允许derived class重新定义virtual函数，从而赋予它们“如何实现机能”的控制能力，但base class保留诉说“函数何时被调用”的权利。一开始这些听起来似乎诡异，但C++的这种“derived class可重新定义继承而来的private virtual函数”的规则似乎合情合理。</p>
<p>&emsp;&emsp;在NVI手法下其实没有必要让virtual函数一定得是private。某些class继承体系要求derived class在virtual函数的实现内必须调用其base class的对应兄弟，而为了让这样的调用合法，virtual函数必须是protected，不能是private。有时候virtual函数甚至一定得是public（例如具备多态性质的base class的析构函数），这么一来就不能实施NVI手法了。</p>
<h2 id="藉由Function-Pointers实现Strategy模式"><a href="#藉由Function-Pointers实现Strategy模式" class="headerlink" title="藉由Function Pointers实现Strategy模式"></a>藉由Function Pointers实现Strategy模式</h2><p>&emsp;&emsp;NVI手法对public virtual函数而言是一个有趣的替代方案，但从某种设计角度观之，它只比窗饰花样更强一些而已。毕竟我们还是使用virtual函数来计算每个人物的健康指数。另一个更戏剧性的设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>  <span class="comment">//前置声明</span></span><br><span class="line"><span class="comment">//以下函数是计算健康指数的缺省算法。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : <span class="title">healthFunc</span><span class="params">(hcf)</span></span></span><br><span class="line"><span class="function">        </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个做法是常见的Strategy设计模式的简单应用。拿它和“植基于GameCharacter继承体系内之virtual函数”的做法比较，它提供了某些有趣弹性：</p>
<ul>
<li>同一人物类型之不同实体可以有不同的健康计算函数，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : <span class="title">GameCharacter</span><span class="params">(hcf)</span></span></span><br><span class="line"><span class="function">        </span>&#123; ... &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;  <span class="comment">//健康指数计算函数1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;   <span class="comment">//健康指数计算函数2</span></span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;           <span class="comment">//相同类型的人物搭配</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;            <span class="comment">// 不同的健康计算方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>某已知人物之健康指数计算函数可在运行期变更。例如GameCharacter可提供一个成员函数setHealthCalculator，用来替换当前的健康指数计算函数。</li>
</ul>
<p>&emsp;&emsp;换句话说，“健康指数计算函数不再是GameCharacter继承体系内的成员函数”这一事实意味，这些计算函数并未特别访问“即将被计算健康指数”的那个对象的内部成分。例如defaultHealthCalc并未访问EvilBadGuy的non-public成分。</p>
<p>&emsp;&emsp;如果人物的健康可纯粹根据该人物的public接口得来的信息加以计算，这就没有问题，但如果需要non-public信息进行精确计算，就有问题了。实际上任何时候当你将class内的某个机能（也许取道自某个成员函数）替换为class外部的某个等价机能（也许取道自某个non-member non-friend函数或另一个class的non-friend成员函数），这都是潜在争议点。这个争议将持续至本条款其余篇幅，因为我们即将考虑的所有替代设计也都涉及使用GameCharacter继承体系外的函数。</p>
<p>&emsp;&emsp;一般而言，唯一能够解决“需要以non-member函数访问class的non-public成分”的办法就是：弱化class的封装。例如class可声明那个non-member函数为friends，或是为其实现的某一部分提供public访问函数（其他部分则宁可隐藏起来）。运用函数指针替换virtual函数，其优点（像是“每个对象可各自拥有自己的健康计算函数”和“可在运行期改变计算函数”）是否足以弥补缺点（例如可能必须降低GameCharacter封装性），是你必须根据每个设计情况的不同而抉择的。</p>
<h2 id="藉由std-function完成Strategy模式"><a href="#藉由std-function完成Strategy模式" class="headerlink" title="藉由std::function完成Strategy模式"></a>藉由std::function完成Strategy模式</h2><p>&emsp;&emsp;一旦习惯了templates以及它们对隐式接口的使用，基于函数指针的做法看起来便过分苛刻而死板了。为什么要求“健康指数之计算”必须是个函数，而不能是某种“像函数的东西”（例如函数对象）呢？如果一定得是函数，为什么不能够是个成员函数？为什么一定得返回int而不是任何可被转换为int的类型呢？</p>
<p>&emsp;&emsp;如果我们不再使用函数指针（如前例的healthFunc），而是改用一个类型为std::function的对象，这些约束就全部挥发不见了。这样的对象可持有（保存）任何可调用物（callable entity，也就是函数指针、函数对象、或成员函数指针），只要其签名式兼容于需求端。以下将刚才的设计改为使用std::function：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//HealthCalcFunc可以是任何“可调用物”（callable entity），可被调用并接受</span></span><br><span class="line">        <span class="comment">//任何兼容于GameCharacter之物，返回任何兼容于int的东西。详下。</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : <span class="title">healthFunc</span><span class="params">(hcf)</span></span></span><br><span class="line"><span class="function">        </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如你所见，HealthCalcFunc是个typedef，用来表现std::function的某个具现体，意味着该具现体的行为像一般的函数指针。</p>
<p>&emsp;&emsp;和前一个设计（其GameCharacter持有的是函数指针）比较，这个设计几乎相同。唯一不同的是如今GameCharacter持有一个std::function对象，相当于一个指向函数的泛化指针。这个改变如此细小，我总说它没有什么外显影响，除非客户在“指定健康计算函数”这件事上需要更惊人的弹性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">short <span class="title">calcHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;  <span class="comment">//健康计算函数；</span></span><br><span class="line">                                         <span class="comment">//注意其返回类型为non-int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span> &#123;</span>                <span class="comment">//为计算健康而设计的函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;  <span class="comment">//成员函数，用以计算健康；</span></span><br><span class="line">        ...                                        <span class="comment">//注意其non-int返回类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter &#123;          <span class="comment">//同前</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EyeCandyCharacter</span> :</span> <span class="keyword">public</span> GameCharacter &#123;   <span class="comment">//另一个人物类型；</span></span><br><span class="line">    ...                                            <span class="comment">//假设其构造函数与</span></span><br><span class="line">&#125;;                                                 <span class="comment">//EvilBadGuy同</span></span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;                       <span class="comment">//人物1，使用某个</span></span><br><span class="line">                                                   <span class="comment">//函数计算健康指数</span></span><br><span class="line"></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;        <span class="comment">//人物2，使用某个</span></span><br><span class="line">                                                   <span class="comment">//函数对象计算健康指数</span></span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::bind(&amp;GameLevel::health, currentLevel, _1)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先我要声明，为计算ebg2的健康指数，应该使用GameLevel class成员函数health。好，GameLevel::health宣称它自己接受一个参数（那是个reference指向GameCharacter），但它实际上接受两个参数，因为它也获得一个隐式参数GameLevel，也就是this所指的那个。然而GameCharacters的健康计算函数只接受单一参数：GameCharacter（这个对象将被计算出健康指数）。如果我们使用GameLevel::health作为ebg2的健康计算函数，我们必须以某种方式转换它，使它不再接受两个参数（一个GameCharacter和一个GameLevel），转而接受单一参数（一个GameCharacter）。在这个例子中我们必然会想要使用currentLevel作为“ebg2点健康计算函数所需的那个GameLevel对象”，于是我们将currentLevel绑定为GameLevel对象，让它在“每次GameLevel::health被调用用以计算ebg2的健康”时被使用。那正是std::bind的作为：它指出ebg2的健康计算函数应该总是以currentLevel作为GameLevel对象。</p>
<p>&emsp;&emsp;我跳过了一大堆细节，像是为什么“_1”意味“当为ebg2调用GameLevel::health时系以currentLevel作为GameLevel对象”。这样的细节不难阐述，但它们会分散我要说的根本重点：若以std::function替换函数指针，将因此允许客户在计算人物健康指数时使用任何兼容的可调用物。如果这还不酷，什么是酷？</p>
<h2 id="古典的Strategy模式"><a href="#古典的Strategy模式" class="headerlink" title="古典的Strategy模式"></a>古典的Strategy模式</h2><p>&emsp;&emsp;如果你对设计模式比对C++的酷劲更有兴趣，我告诉你，传统（典型）的Strategy做法会将健康计算函数做成一个分离的继承体系中的virtual成员函数。</p>
<p>&emsp;&emsp;比如下面的对应代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>  <span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCal;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCal)</span></span></span><br><span class="line"><span class="function">        : <span class="title">pHealthCalc</span><span class="params">(phcf)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pHealthCalc-&gt;calc(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个解法的吸引力在于，熟悉标准Strategy模式的人很容易辨认它，而且它还提供“将一个既有的健康算法纳入使用”的可能性——只要为HealthCalcFunc继承体系添加一个derived class即可。</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;本条款的根本忠告是。当你为解决问题而寻找某个设计方法时，不妨考虑virtual函数的替代方案：</p>
<ul>
<li><p>使用non-virtual interface（NVI）手法，这是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性的virtual函数。</p>
</li>
<li><p>将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。</p>
</li>
<li><p>以std::function成员变量替换virtual函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式。</p>
</li>
<li><p>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。</p>
</li>
</ul>
<p>&emsp;&emsp;以上并未彻底而详尽地列出virtual函数的所有替换方案，但应该足够让你知道的确有不少替换方案。此外，它们各有其相对的优点和缺点，你应该把它们全部列入考虑。</p>
<p>&emsp;&emsp;为避免陷入面向对象设计路上因常规而形成的凹洞中，偶尔我们需要对着车轮猛推一把。这个世界还有其他许多道路，值得我们花时间加以研究。</p>
<blockquote>
<ul>
<li>virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li>
<li>std::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>区分接口继承和实现继承</title>
    <url>/2020/10/29/%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<hr>
<h1 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h1><p>&emsp;&emsp;表面上直截了当的public继承概念，经过更严密的检查之后，发现它由两部分组成：函数接口继承和函数实现继承。这两种继承的差异，很像函数声明与函数定义之间的差异。</p>
<p>&emsp;&emsp;身为class设计者，有时候我们会希望derived class只继承成员函数的接口（也就是声明）；有时候又会希望derived class同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现；又有时候希望derived class同时继承函数的接口和实现，并且不允许覆写任何东西。</p>
<p>&emsp;&emsp;为了更好地感觉上述选择之间的差异，让我们考虑一个展现绘图程序中各种几何形状的class继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vod <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span> :</span> <span class="keyword">public</span> Shape &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Shape是个抽象class；它的pure virtual函数draw使他成为一个抽象class。所以客户不能够创建Shape class的实体，只能创建其derived class的实体。尽管如此，Shape还是强烈影响了所有以public形式继承它的derived class，因为：</p>
<ul>
<li>成员函数的接口总是会被继承，public继承意味着is-a，所以对base class为真的任何事情一定也对其derived class为真。因此，如果某个函数可施行于某class身上，一定也可施行于其derived class身上。</li>
</ul>
<p>&emsp;&emsp;Shape class声明了三个函数。第一个是draw，于某个隐喻的视屏中画出当前对象。第二个是error，准备让那些“需要报导某个错误”的成员函数调用。第三个是objectID，返回当前对象的一个独立无二的整数识别码。每个函数的声明方式都不相同：draw是个pure virtual函数；error是个简朴的（非纯）impure virtual函数；objectID是个non-virtual函数。这些不同的声明带来什么样的暗示呢？</p>
<p>&emsp;&emsp;首先考虑pure virtual函数draw：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;pure virtual函数有两个最突出的特性：它们必须被任何“继承了它们”的具象class重新声明，而且它们在抽象class中通常没有定义。把这两个性质摆在一起，你就会明白：</p>
<ul>
<li>声明一个pure virtual函数的目的是为了让derived class只继承函数接口。</li>
</ul>
<p>&emsp;&emsp;这对Shape::draw函数是再合理不过的事了，因为所有Shape对象都应该是可绘出的，这是合理的要求。但Shape class无法为此函数提供合理的缺省实现，毕竟椭圆形绘法迥异于矩形绘法。Shape::draw的声明式乃是对具象derived class设计者说，“你必须提供一个draw函数，但我不干涉你怎么实现它。”</p>
<p>&emsp;&emsp;令人意外的是，我们竟然可以为pure virtual函数提供定义。也就是说你可以为Shape::draw供应一份实现代码，C++并不会发出怨言，但调用它的唯一途径是“调用时明确指出其class名称”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shape* ps = <span class="keyword">new</span> Shape;       <span class="comment">//错误！Shape是抽象的</span></span><br><span class="line">Shape* ps1 = <span class="keyword">new</span> Rectangle;  <span class="comment">//没问题</span></span><br><span class="line">ps1-&gt;draw();                 <span class="comment">//调用Rectangle::draw</span></span><br><span class="line">Shape* ps2 = <span class="keyword">new</span> Ellipse;    <span class="comment">//没问题</span></span><br><span class="line">ps2-&gt;draw();                 <span class="comment">//调用Ellipse::draw</span></span><br><span class="line">ps1-&gt;Shape::draw();          <span class="comment">//调用Shape::draw</span></span><br><span class="line">ps2-&gt;Shape::draw();          <span class="comment">//调用Shape::draw</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;除了能够帮助你在高雅酒会上留给大师级程序员一个深刻的印象，一般而言这项性质用途有限。但是稍后你将看到，它可以实现一种机制，为简朴的（非纯）impure virtual函数提供更平常更安全的缺省实现。</p>
<p>&emsp;&emsp;简朴的impure virtual函数背后的故事和pure virtual函数有点不同。一如往常，derived class继承其函数接口，但impure virtual函数会提供一份实现代码，derived class可能覆写它。稍加思索，你就会明白：</p>
<ul>
<li>声明简朴的（非纯）impure virtual函数的目的，是让derived class继承该函数的接口和缺省实现。</li>
</ul>
<p>&emsp;&emsp;考虑Shape::error这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其接口表示，每个class都必须支持一个“当遇上错误时可调用”的函数，但每个class都可自由处理错误。如果某个class不想针对错误做出任何特殊行为，它可以退回到Shape class提供的缺省错误处理行为。也就是说Shape::error的声明式告诉derived class的设计者，“你必须支持一个error函数，但如果你不想自己写一个，可以使用Shape class提供的缺省版本”。</p>
<p>&emsp;&emsp;但是，允许impure virtual函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑XYZ航空公司设计的飞行继承体系。该公司只有A型和B型飞机，两者都以相同方式飞行。因此XYZ设计出这样的继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span> ... &#125;;  <span class="comment">//用以表现机场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    缺省代码，将飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的fly实现”，Airplane::fly被声明为virtual。然而为了避免在ModelA和ModelB中撰写相同代码，缺省飞行行为由Airplane::fly提供，它同时被ModelA和ModelB继承。</p>
<p>&emsp;&emsp;这是个典型的面相对象设计。两个class共享一份相同性质（也就是它们实现fly的方式），所以共同性质被搬到base class中，然后被这两个class继承。这个设计突显出共同性质，避免代码重复，并提升未来的强化能力，减缓长期维护所需的成本。所有这些都是面相对象技术如此受到欢迎的原因。XYZ航空公司应该感到骄傲。</p>
<p>&emsp;&emsp;现在，假设XYZ盈余大增，决定购买一种新式C型飞机。C型和A型以及B型有某些不同。更明确地说，它的飞行方式不同。</p>
<p>&emsp;&emsp;XYZ公司的程序员正在继承体系中针对C型飞机添加了一个class，但由于他们急着让新飞机上线服务，竟忘了重新定义其fly函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    ...  <span class="comment">//未声明fly函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后代码中有一些诸如此类的动作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Airport <span class="title">MLP</span><span class="params">(...)</span></span>;  <span class="comment">//MLP是某个机场</span></span><br><span class="line">Airplane* pa = <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line">pa-&gt;fly(MLP);      <span class="comment">//调用Airplane::fly</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这将酿成大祸；这个程序试图以ModelA或ModelB的飞行方式来飞ModelC。</p>
<p>&emsp;&emsp;问题不在Airplane::fly有缺省行为，而在于ModelC在未明白说出“我要”的情况下就继承了该缺省行为。幸运的是我们可以轻易做到“提供缺省实现给derived class，但除非它们明白要求否则免谈”。此间伎俩在于切断“virtual函数接口”和其”缺省实现“之间的连接。下面是一种做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    缺省行为，将飞行飞至指定目的地。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;请注意，Airplane::fly已被改为一个pure virtual函数，只提供飞行接口。其缺省行为也出现在Airplane class中，但此次系以独立函数defaultFly的姿态出现。若想使用缺省实现（例如ModelA和ModelB），可以在其fly函数中对defaultFly做一个inline调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            defaultFly(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            defaultFly(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在ModelC class不可能意外继承不正确的fly实现代码了，因为Airplane中的pure virtual函数迫使ModelC必须提供自己的fly版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    将C型飞机飞至指定目的地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个方案并非安全无虞，程序员还是可能因为剪贴代码而招来麻烦，但它的确比原先的设计值得依赖。至于Airplane::defaultFly，请注意它现在成了protected，因为它是Airplane及其derived class的实现细目。乘客应该只在意飞机能不能飞，不在意它们怎么飞。</p>
<p>&emsp;&emsp;Airplane::defaultFly是个non-virtual函数，这一点也很重要。因为没有任何一个derived class应该重新定义此函数。如果defaultFly是virtual函数，就会出现一个循环问题：万一某些derived class忘记重新定义defaultFly，会怎样？</p>
<p>&emsp;&emsp;有些人反对以不同的函数分别提供接口和缺省实现，像上述的fly和defaultFly那样。他们关心因过度雷同的函数名称而引起的class命名空间污染问题。但是他们也同意，接口和缺省实现应该分开。这个表面上看起来的矛盾该如何解决？唔，我们可以利用“pure virtual函数必须在derived class中重新声明，但它们也可以拥有自己的实现”这一事实。下面便是Airplane继承体系如何给pure virtual函数一份定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123; <span class="comment">//pure virtual函数实现</span></span><br><span class="line">    缺省行为，将飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            Airplane::fly(destination);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            Airplane::fly(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">    将C型飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这几乎和前一个设计一摸一样，只不过pure virtual函数Airplane:fly替换了独立函数Airplane::defaultFly。本质上，现在的fly被分割为两个基本要素：其声明部分表现的是接口（那是derived class必须使用的），其定义部分则表现出缺省行为（那是derived class可能使用的，但只有在它们明确提出申请时才是）。如果合并fly和defaultFly，就丧失了“让两个函数享有不同保护级别”的机会：习惯上被设为protected的函数（defaultFly）如今成了public（因为它在fly之中）。</p>
<p>&emsp;&emsp;最后，让我们看看Shape的non-virtual函数objectID：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果成员函数是个non-virtual函数，意味着它并不打算在derived class中有不同的行为。实际上一个non-virtual成员函数所表现的不变性凌驾其特异性，因为它表示不论derived class变得多么特异化，它的行为都不可以改变。就其自身而言：</p>
<ul>
<li>声明non-virtual函数的目的是为了令derived class继承函数的接口及一份强制性实现。</li>
</ul>
<p>&emsp;&emsp;你可以把Shape::objectID的声明想做是：“每个Shape对象都有一个用来产生对象识别码的函数；此识别码总是采用相同计算方法，该方法由Shape::objectID的定义式决定，任何derived class都不应该尝试改变其行为”。由于non-virtual函数代表的意义是不变性凌驾特异性，所以它绝不该在derived class中被重新定义。</p>
<p>&emsp;&emsp;pure virtual函数、simple（impure）virtual函数、non-virtual函数之间的差异，使你得以精确指定你想要derived class继承的东西：只继承接口，或是继承接口和一份缺省实现，或是继承接口和一份强制实现。由于这些不同类型的声明意味着根本意义并不相同的事情，当你声明你的成员函数时，必须谨慎选择。如果你确实履行，应该能够避免经验不足的class设计者最常犯的两个错误。</p>
<p>&emsp;&emsp;第一个错误是将所有函数声明为non-virtual。这使得derived class没有余裕空间进行特化工作。non-virtual析构函数尤其会带来问题（见“<a href="/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" title="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</a>”）。当然啦，设计一个并不想成为base class的class是绝对合理的，既然这样，将其所有成员函数都声明为non-virtual也很适当。但这种声明如果不是忽略了virtual和non-virtual函数之间的差异，就是过度担心virtual函数的效率成本。实际上任何class如果打算被用来当做一个base class，都会拥有若干virtual函数。</p>
<p>&emsp;&emsp;如果你关心virtual函数的成本，请容许我介绍所谓的80-20法则（也可见“<a href="/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/" title="透彻了解inlining的里里外外">透彻了解inlining的里里外外</a>。这个法则说，一个典型的程序有80%的执行时间花费在20%的代码身上。此一法则十分重要，因为它意味，平均而言你的函数调用中可以有80%是virtual而不冲击程序的大体效率。所以当你担心是否有能力负担virtual函数的成本之前，请先将心力放在那举足轻重的20%代码上头，它才是关键。</p>
<p>&emsp;&emsp;另一个常见错误是将所有成员函数声明为virtual。有时候这样做是正确的，例如“<a href="/2020/08/13/%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E/" title="将文件间的编译依存关系降至最低">将文件间的编译依存关系降至最低</a>”的interface class。然而这也可能是class设计者缺乏坚定立场的前兆。某些函数就是不该在derived class中被重新定义，果真如此你应该将那些函数声明为non-virtual。没有人有权利妄称你的class适用于任何人任何事物而他们只需花点时间重新定义你的函数就可以享受一切。如果你的不变性凌驾特异性，别害怕说出来。</p>
<blockquote>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。</li>
<li>pure virtual函数只具体指定接口继承。</li>
<li>简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual函数具体指定接口以及强制性实现继承。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>绝不重新定义继承而来的non-virtual函数</title>
    <url>/2020/11/11/%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h1><p>&emsp;&emsp;假设我告诉你，class D系由class B以public形式派生而来，class B定义有一个public成员函数mf。由于mf的参数和返回值都不重要，所以我们假设两者皆为void。换句话说我的意思是： </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;虽然我们对B，D和mf一无所知，但面对一个类型为D的对象x：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D x;  <span class="comment">//x是一个类型为D的对象</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果以下行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">B* pB = &amp;x;  <span class="comment">//获得一个指针指向x</span></span><br><span class="line">pB-&gt;mf();    <span class="comment">//经由该指针调用mf</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;异于以下行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D* pD = &amp;x;  <span class="comment">//获得一个指针指向x</span></span><br><span class="line">pD-&gt;mf();    <span class="comment">//经由该指针调用mf</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你可能会相当惊讶。毕竟两者都通过对象x调用成员函数mf。由于两者所调用的函数都相同，凭借的对象也相同，所以行为也应该相同，是吗？</p>
<p>&emsp;&emsp;是的，理应如此，但事实可能不是如此。更明确地说，如果mf是个non-virtual函数而D定义有自己的mf版本，那就不是如此：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;  <span class="comment">//遮掩了B::mf;</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pB-&gt;mf();  <span class="comment">//调用B::mf</span></span><br><span class="line">pD-&gt;mf();  <span class="comment">//调用D::mf</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;造成此一两面行为的原因是，non-virtual函数如B::mf和D::mf都是静态绑定。这意思是，由于pB被声明为一个pointer-to-B，通过pB调用的non-virtual函数永远是B所定义的版本，即使pB指向一个类型为“B派生之class”的对象，一如本例。</p>
<p>&emsp;&emsp;但另一方面，virtual函数却是动态绑定，所以它们不受这个问题之苦。如果mf是个virtual函数，不论是通过pB或pD调用mf，都会导致调用D::mf，因为pB和pD真正指的都是一个类型为D的对象。</p>
<p>&emsp;&emsp;如果你正在编写class D并重新定义继承自class B的non-virtual函数mf，D对象很可能展现出精神分裂的不一致行径。更明确地说，当mf被调用，任何一个D对象都可能表现出B或D的行为；决定因素不在对象自身，而在于“指向该对象之指针”当初的声明类型。References也会展现和指针一样难以理解的行径。</p>
<p>&emsp;&emsp;但那只是务实面上的讨论。我知道你真正想要的是理论层面的理由（关于“绝不重新定义继承而来的non-virtual函数”这回事）。我很乐意为你服务。</p>
<p>&emsp;&emsp;条款“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”已经说过，所谓public继承意味is-a的关系。条款“<a href="/2020/10/29/%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/" title="区分接口继承和实现继承">区分接口继承和实现继承</a>”则描述为什么在class内声明一个non-virtual函数会为该class建立起一个不变性，凌驾其特异性。如果你将这两个观点施行于两个class B和D以及non-virtual成员函数B::mf身上，那么：</p>
<ul>
<li>适用于B对象的每一件事，也适用于D对象，因为每个D对象都是一个B对象；</li>
<li>B的derived class一定会继承mf的接口和实现，因为mf是B的一个non-virtual函数。</li>
</ul>
<p>&emsp;&emsp;现在，如果D重新定义mf，你的设计便出现矛盾。如果D真有必要实现出与B不同的mf，并且每一个B对象——不管多么特化——真的必须使用B所提供的mf实现码，那么“每个D都是一个B”就不为真。既然如此D就不该以public形式继承B。另一方面，如果D真的必须以public方式继承B，并且如果D真有需要实现出与B不同的mf，那么mf就无法为B反映出“不变性凌驾特异性”的性质。既然这样mf应该声明为virtual函数。最后，如果每个D真的是一个B，并且如果mf真的为B反映出“不变性凌驾特异性”的性质，那么D便不需要重新定义mf，而且它也不应该尝试这样做。</p>
<p>&emsp;&emsp;不论哪一个观点，结论都相同：任何情况下都不该重新定义一个继承而来的non-virtual函数。</p>
<blockquote>
<ul>
<li>绝对不要重新定义继承而来的non-virtual函数。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>绝不重新定义继承而来的缺省参数值</title>
    <url>/2020/11/11/%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<hr>
<h1 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h1><p>&emsp;&emsp;让我们一开始就将讨论简化。你只能继承两种函数：virtual和non-virtual函数。然而重新定义一个继承而来的non-virtual函数永远是错误的，所以我们可以安全地将本条款的讨论局限于“继承一个带有缺省参数值的virtual函数”。</p>
<p>&emsp;&emsp;这种情况下，本条款成立的理由就非常直接而明确了：virtual函数系动态绑定，而缺省参数值却是静态绑定。</p>
<p>&emsp;&emsp;对象的所谓静态绑定类型，就是它在程序中被声明时所采用的类型。考虑以下的class继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用以描述几何形状的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue &#125;;</span><br><span class="line">        <span class="comment">//所有形状都必须提供一个函数，用来绘出自己</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//注意，赋予不同的缺省参数值。这真糟糕！</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//译注：请注意，以上这么写则当客户以对象调用此函数，一定要指定参数值。</span></span><br><span class="line">        <span class="comment">//     因为静态绑定下这个函数并不从其base继承缺省参数值。</span></span><br><span class="line">        <span class="comment">//     但若以指针（或reference）调用此函数，可以不指定参数值。</span></span><br><span class="line">        <span class="comment">//     因为动态绑定下这个函数会从其base继承缺省参数值。</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑这些指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shape* ps;                  <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;     <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;  <span class="comment">//静态类型为Shape*</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本例中ps，pc，pr都被声明为pointer-to-Shape类型，所以它们都以它为静态类型。注意，不论它们真正指向什么，它们的静态类型都是Shape*。</p>
<p>&emsp;&emsp;对象的所谓动态类型则是指“目前所指对象的类型”。也就是说，动态类型可以表现出一个对象将会有什么行为。以上例而言，pc的动态类型是Circle*，pr的动态类型是Rectangle*。ps没有动态类型，因为它尚未指向任何对象。</p>
<p>&emsp;&emsp;动态类型一如其名称所示，可在程序执行过程中改变（通常是经由赋值动作）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps = pc;  <span class="comment">//ps的动态类型如今是Circle*</span></span><br><span class="line">ps = pr;  <span class="comment">//ps的动态类型如今是Rectangle*</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;virtual函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pc-&gt;draw(Shape::Red);  <span class="comment">//调用Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;draw(Shape::Red);  <span class="comment">//调用Rectangle::draw(Shape::Red)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我知道这些都是老调重弹；是的，你当然已经了解virtual函数。但是当你考虑带有缺省参数值的virtual函数，花样来了，因为就如我稍早所说，virtual函数是动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用base class为它所指定的缺省参数值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pr-&gt;draw();  <span class="comment">//调用Rectangle::draw(Shape::Red)！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此例之中，pr的动态类型是Rectangle<em>，所以调用的是Rectangle的virtual函数，一如你所预期。Rectangle::draw函数的缺省参数值应该是GREEN，但由于pr的静态类型是Shape\</em>，所以此一调用的缺省参数值来自Shape class而非Rectangle class！结局是这个函数调用有着奇怪并且几乎绝对没人预料得到的组合，由Shape class和Rectangle class的draw声明式各出一半力。</p>
<p>&emsp;&emsp;以上事实不只局限于“ps，pc和pr都是指针”的情况；即使把指针换成reference问题仍然存在。重点在于draw是个virtual函数，而它有个缺省参数值在derived class中被重新定义了。</p>
<p>&emsp;&emsp;为什么C++坚持以这种乖张的方式来运作呢？答案在于运行期效率。如果缺省参数值是动态绑定，编译器就必须有某种方式在运行期为virtual函数决定适当的参数缺省值。这比目前实行的“在编译期决定”的机制更慢而且更复杂。为了程序的执行速度和编译器实现上的简易度，C++做了这样的取舍，其结果就是你如今所享受的执行效率。</p>
<p>&emsp;&emsp;这一切都很好，但如果你试着遵守这条规则，并且同时提供缺省参数值给base和derived class的用户，又会发生什么事呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;喔欧，代码重复。更糟的是，代码重复又带着相依性：如果Shape内的缺省参数值改变了，所有“重复给定缺省参数值”的那些derived class也必须改变，否则它们最终会导致“重复定义一个继承而来的缺省参数值”。怎么办？</p>
<p>&emsp;&emsp;当你想令virtual函数表现出你所想要的行为但却遭遇麻烦，聪明的做法是考虑替代设计。提条款“<a href="/2020/10/31/%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9/" title="考虑virtual函数以外的其他选择">考虑virtual函数以外的其他选择</a>”列了不少virtual函数的替代设计，其中之一是NVI手法：令base class内的一个public non-virtual函数调用private virtual函数，后者可被derived class重新定义。这里我们可以让non-virtual函数指定缺省参数，而private virtual函数负责真正的工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">//如今它是non-virtual</span></span><br><span class="line">            doDraw(color);                         <span class="comment">//调用一个virtual</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">//真正的工作在此完成</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;  <span class="comment">//注意，不须指定缺省参数值。</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于non-virtual函数应该绝对不被derived class覆写，这个设计很清楚地使得draw函数的color缺省参数值总是Red。</p>
<blockquote>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>通过复合塑模出has-a或“根据某物实现出”</title>
    <url>/2020/11/11/%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D/</url>
    <content><![CDATA[<hr>
<h1 id="通过复合塑模出has-a或“根据某物实现出”"><a href="#通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或“根据某物实现出”"></a>通过复合塑模出has-a或“根据某物实现出”</h1><p>&emsp;&emsp;复合（composition）是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span> ... &#125;;  <span class="comment">//某人的住址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name;         <span class="comment">//合成成分物（composed object）</span></span><br><span class="line">        Address address;          <span class="comment">//同上</span></span><br><span class="line">        PhoneNumber voiceNumber;  <span class="comment">//同上</span></span><br><span class="line">        PhoneNumber faxNumber;    <span class="comment">//同上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本例之中Person对象由string，Address，PhoneNumber构成。在程序员之间复合这个术语有许多同义词，包括layering（分层），containment（内含），aggregation（聚合）和embedding（内嵌）。</p>
<p>&emsp;&emsp;实际上复合有它自己的意义。实际上它有两个意义。复合意味has-a（有一个）或is-implemented-in-term-if（根据某物实现出）。那是因为你正打算在你的软件中处理两个不同的领域（domains）。程序中的对象其实相当于你所塑造的世界中的某些事物，例如人、汽车、一张张视频画面等等。这样的对象属于应用域（application domain）部分。其他对象则纯粹是实现细节上的人工制品，像是缓冲区（buffers）、互斥器（mutexs）、查找树（search trees）等等。这些对象相当于你的软件等实现域。当复合发生于应用域内的对象之间，表现出has-a的关系；当它发生于实现域内则是表现is-implemented-in-terms-of的关系。</p>
<p>&emsp;&emsp;上述的Person class示范has-a关系。Person有一个名称，一个地址，以及语音和传真两笔电话号码。你不会说“人是一个名称”或“人是一个地址”，你会说“人有一个名称”和“人有一个地址”。大多数人接受此一区别毫无困难，所以很少人会对is-a和has-a感到困惑。</p>
<p>&emsp;&emsp;比较麻烦的是区分is-a（是一种）和is-implemented-in-terms-of（根据某物实现出）这两种对象关系。假设你需要一个template，希望制造出一组class用来表现由不重复对象组成的sets。由于复用是件美妙无比的事情，你的第一个直觉是采用标准程序库提供的set template。是的，如果他人所写的template合乎需求，我们何必令写一个呢？</p>
<p>&emsp;&emsp;但是容我再说一次，复用是件美好的事。如果你是一位数据结构专家。你就会知道，实现sets的方法太多了，其中一种便是在底层采用linked lists。而你又刚好知道，标准程序库有一个list template，于是你决定复用它。</p>
<p>&emsp;&emsp;更明确地说，你决定让你那个萌芽中的Set template继承std::list。也就是说让Set&lt;T&gt;继承list&lt;T&gt;。毕竟在你的实现理念中Set对象其实是个list对象。你于是声明Set template如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//将list应用于Set。错误做法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每件事看起来都很好，但实际上有些东西完全错误。如果D是一种B，对B为真的每一件事对D也都应该为真。但list可以内含重复元素，如果数值3051被安插到list&lt;int&gt;两次，那个list将内含两笔3051。Set不可以内含重复元素，如果数值3051被安插到Set&lt;int&gt;两次，这个set只内含一笔3051。因此“Set是一种list”并不为真，因为对list为真对某些事情对Set对象并不为真。</p>
<p>&emsp;&emsp;由于这两个class之间并非is-a的关系，所以public继承不适合用来塑模它们。正确的做法是，你应当了解，Set对象可根据一个list对象实现出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //将<span class="title">list</span>应用于<span class="title">Set</span>。正确做法。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Set</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">member</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; rep;  <span class="comment">//用来表述Set的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Set成员函数可大量依赖list及标准程序库其他部分提供的机能来完成，所以其实现很直观也很简单，只要你熟悉以STL编写程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Set&lt;T&gt;::member(<span class="keyword">const</span> T&amp; item) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item) != rep.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!member(item)) rep.push_back(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; item) &#123;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::iterator it =</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item);</span><br><span class="line">    <span class="keyword">if</span>(it != rep.<span class="built_in">end</span>()) rep.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些函数如此简单，如果Set接口遵循STL容器的协议，就更容易符合对设计接口的警告：“让它容易被正确使用，不易被误用”。但是这儿如果要遵循那些协议，需得为Set添加许多东西，那将模糊了它和list之间的关系。由于Set和list之间的关系是本条款的重点，所以我们以教学清澈度交换STL兼容性。此外，Set接口也不该造成“对Set而言无可置辩的权利”黯然失色，那个权利是指它和list间的关系。这关系并非is-a（虽然最初似乎是），而是is-implemented-in-terms-of。</p>
<blockquote>
<ul>
<li>复合的意义和public继承完全不同。</li>
<li>在应用域，复合意味has-a。在实现域，复合意味is-implemented-in-terms-of。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于pragma那些事</title>
    <url>/2020/11/12/%E5%85%B3%E4%BA%8Epragma%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<hr>
<h1 id="关于gragma那些事"><a href="#关于gragma那些事" class="headerlink" title="关于gragma那些事"></a>关于gragma那些事</h1><p>&emsp;&emsp;gragma的作用是设定编译器的状态或者指示编译器完成一些特定的动作。编译指令是机器或操作系统专有的，且对每个编译器都是不同的。</p>
<h2 id="warning-pragma"><a href="#warning-pragma" class="headerlink" title="warning pragma"></a>warning pragma</h2><p>&emsp;&emsp;可以对编译器发出的警告信息进行选择性修改。</p>
<p>&emsp;&emsp;其语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(警告指示符：警告号列表[; 警告指示符：警告号列表...])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push[,n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;警告指示符（warning-specifier）：</p>
<table>
<thead>
<tr>
<th>Warning-specifier</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>1,2,3,4</td>
<td>给予特定警告一个警告级别，也可以开启一个指定的默认被关闭的警告。</td>
</tr>
<tr>
<td>default</td>
<td>重置一个警告行为恢复到其默认的状态</td>
</tr>
<tr>
<td>disable</td>
<td>不报告特定的警告信息</td>
</tr>
<tr>
<td>error</td>
<td>将特定警告信息作为错误报告</td>
</tr>
<tr>
<td>once</td>
<td>只显示出一次特定的警告信息</td>
</tr>
<tr>
<td>suppress</td>
<td>将当前状态的编译指示推入栈，禁止下一行的特定警告，并且推出警告栈，使得当前状态的编译指示被重置。</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;以下代码展示了一个警告指示符可以包含多个警告号，并且多个警告指示符可以被定义在同一个编译指令中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(diable : 4057 34; once : 4385; <span class="meta-keyword">error</span> : 164)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个指令与下列代码是完全一样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Disable warning messages 4507 and 4034.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4057 34)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Issue warning C4385 only once.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(once : 4385)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Report warning C4164 as an error.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(<span class="meta-keyword">error</span> : 164)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编译器会在任何在0到999之间的警告号上添加4000。</p>
<p>&emsp;&emsp;对于那些在4700到4999之间的警告号（与代码生成有关），当编译器遇到函数定义时警告的状态将会对剩下的函数生效。在函数中使用warning pragma来更改比4699大大的警告号的状态只会在函数末尾起作用。以下实例展示了用以禁用代码生成警告信息的warning pragma的正确位置，并且在之后复原被禁用的警告的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pragma_warning.cpp</span></span><br><span class="line"><span class="comment">//compile with: /W1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4700)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y = x;  <span class="comment">//no C4700 here</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(default : 4700)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y = x;  <span class="comment">//C4700</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;warninig pragma也支持以下句法，n表示警告级别（1到4）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push[, n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;pragma warning(push)为每一个警告存储当前的警告状态。pragma warning(push, n)为每个警告存储当前的警告状态，并且将全局警告级别设置为n。</p>
<p>&emsp;&emsp;pragma warning(pop)弹出最后一个被推入栈的警告状态。你在push和pop之间对警告状态做出的任何更改都会被取消，考虑下例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4705)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4706)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4707)</span></span><br><span class="line"><span class="comment">//Some code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这段代码的最后，pop复原每个警告（包括4705，4706和4707）到它们在此代码段之前的状态。</p>
<p>&emsp;&emsp;当你写头文件时，你可以使用push和pop来保证当警告状态被用户更改时不会阻止头文件正确地编译。在开头使用push并且在末尾使用pop。比如，假设你有一个头文件在第4级别警告不会被编译完全，那么可以在接下来的代码中将其警告级别改为3级别，然后在其末尾复原其至原始级别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push, 3)</span></span><br><span class="line"><span class="comment">//Declarations/definitions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>明智而审慎地使用private继承</title>
    <url>/2020/11/12/%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<hr>
<h1 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h1><p>&emsp;&emsp;条款“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”曾经论证过C++如何将public继承视为is-a关系。在那个例子中我们有个继承体系，其中class Student以public形式继承class Person，于是编译器在必要时刻（为了让函数调用成功）将Student暗自转换为Person。现在我再重复该例的一部分，并以private继承替换public继承：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> Person &#123; ... &#125;;  <span class="comment">//这次改用private继承</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;               <span class="comment">//任何人都会吃</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;            <span class="comment">//只有学生才在校学习</span></span><br><span class="line"></span><br><span class="line">Person p;                                <span class="comment">//p是人</span></span><br><span class="line">Student s;                               <span class="comment">//s是学生</span></span><br><span class="line"></span><br><span class="line">eat(p);                                  <span class="comment">//没问题，p是人，会吃。</span></span><br><span class="line">eat(s);                                  <span class="comment">//错误！难道学生不是人？！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;显然private继承并不意味is-a关系。那么它意味什么？</p>
<p>&emsp;&emsp;到底private继承的行为如何呢？如果class之间的继承关系是private，编译器不会自动地将一个derived class对象转换为一个base对象。这和public继承的情况不同。这也就是为什么通过s调用eat会失败的原因。第二条规则是，由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或public属性。</p>
<p>&emsp;&emsp;现在让我们开始讨论其意义。private继承意味implemented-in-terms-of（根据某物实现出）。如果你让class D以private形式继承class B，你的用意是为了采用class B内已经备妥的某些特性，不是因为B对象和D对象存在任何观念上的关系。private继承纯粹只是一种实现技术（这就是为什么继承自一个private base class的每样东西在你的class内都是private：因为它们都只是实现枝节而已）。借用条款“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”提出的术语，private继承意味只有实现部分被继承，接口部分应略去。如果D以private形式继承B，意思是D对象根据B对象实现而得，再没有其他意涵了。private继承在软件“设计”层面上没有意义，其意义只及于软件实现层面。</p>
<p>&emsp;&emsp;private继承意味is-implemented-in-terms-of（根据某物实现出），这个事实有点令人不安，因为复合（composition）的意义也是如此。如何在两者之间取舍？答案很简单：尽可能使用复合，必要时才使用private继承。何时才是必要？主要是当protected成员和／或virtual函数牵扯进来的时候。其实还有一种激进的情况，那是当空间方面的利害关系足以踢翻private继承的支柱时。稍后我们再来操这个心，毕竟它只是一种激进情况</p>
<p>&emsp;&emsp;假设我们的程序涉及Widget，而我们决定应该较好地了解如何使用Widget，例如我们不只想要知道Widget成员函数多么频繁地被调用，也想知道经过一段时间后调用比例如何变化。要知道，带有多个执行阶段的程序，可能在不同阶段拥有不同的行为轮廓。例如编译器在解析阶段所用的函数，大大不同于在最优化和代码生成阶段所使用的函数。</p>
<p>&emsp;&emsp;我们决定修改Widget class，让它记录每个成员函数的被调用次数。运行期间，我们将周期性地审查那份信息，也许再加上每个Widget的值，以及我们需要评估的任何其他数据。为了完成这项工作，我们需要设定某种定时器，使我们知道收集统计数据的时候是否到了。</p>
<p>&emsp;&emsp;我们宁可复用既有代码，尽量少写新代码，所以在自己的工具百宝箱中翻箱倒柜，并且很开心地发现了这个class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequency)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//定时器每滴答一次，</span></span><br><span class="line">        ...                           <span class="comment">//此函数就被自动调用一次。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这就是我们找到的东西。一个Timer对象，可调整为以我们需要的任何频率滴答前进，每次滴答就调用某个virtual函数。我们可以重新定义那个virtual函数，让后者取出Widget的当时状态。完美！</p>
<p>&emsp;&emsp;为了让Widget重新定义Timer内的virtual函数，Widget必须继承自Timer。但public继承在此例并不适当，因为Widget并不是个Timer。事呀，Widget客户总不该能够对着一个Widget调用onTick把，因为观念上那并不是Widget接口的的一部分。如果允许那样的调用动作，很容易造成客户不正确地使用Widget接口。在这里public继承不是个好策略。</p>
<p>&emsp;&emsp;我们必须以private形式继承Timer：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">private</span> Timer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//查看Widget的数据等等。</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;藉由private继承，Timer的public onTick函数在Widget内变成private，而我们重新声明（定义）时仍然把它留在那儿。再说一次，把onTick放进public接口内会误导客户端以为他们可以调用它。</p>
<p>&emsp;&emsp;这是个好设计，但不值几文钱，因为private继承并非绝对必要。如果我们决定以复合取而代之，是可以的。只要在Widget内声明一个嵌套式private class，后者以public形式继承Timer并重新定义onTick，然后放一个这种类型的对象于Widget内。下面是这种解法的草样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span> :</span> <span class="keyword">public</span> Timer &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">                ...</span><br><span class="line">        &#125;;</span><br><span class="line">        WidgetTimer timer;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个设计只比使用private继承要复杂一些些，因为它同时涉及public继承和复合，并导入一个新class（WidgetTimer）。坦白说我展示它主要是为了提醒你，解决一个设计问题的方法不只一种，而训练自己思考多种做法是值得的。尽管如此，我可以想出两个理由，为什么你可能愿意（或说应该）选择这样的public继承加复合，而不是选择原先的private继承设计。</p>
<p>&emsp;&emsp;首先，你或许会想设计Wdiget使它得以拥有derived class，但同时你可能会想阻止derived class重新定义onTick。如果Widget继承自Timer，上面的想法就不可能实现，即使是private继承也不可能。（因为derived class可以重新定义virtual函数，即使它们不得调用它。）但如果WidgetTimer是Widget内部的一个private成员并继承Timer，Widget的derived class将无法取用WidgetTimer，因此无法继承它或重新定义它的virtual函数。如果你曾经以Java或C#编程并怀念“阻止derived class重新定义virtual函数”的能力（也就是Java的final和C#的sealed），现在你知道怎么在C++中模拟它了。</p>
<p>&emsp;&emsp;第二，你或许会想要将Widget的编译依存性降低最低。如果Widget继承Timer，当Widget被编译时Timer的定义必须可见，所以定义Widget的那个文件恐怕必须#include Timer.h。但如果WidgetTimer移出Widget之外而Widget内含指针指向一个WidgetTimer，Widget可以只带着一个简单的WidgetTimer声明式，不再需要#include任何与Timer有关的东西。对大型系统而言，如此的解耦可能是重要的措施。关于编译依存性的最小化，详见“<a href="/2020/08/13/%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E/" title="将文件间的编译依存关系降至最低">将文件间的编译依存关系降至最低</a>”。</p>
<p>&emsp;&emsp;稍早我曾谈到，private继承主要用于“当一个意欲成为derived class者想访问一个意欲成为base class者的protected成分，或为了重新定义一或多个virtual函数”。但这时候两个class之间的概念关系其实是is-implemented-in-terms-of（根据某物实现出）而非is-a。然而我也说过，有一种激进情况涉及空间最优化，可能会促使你选择“private继承”而不是“继承加复合”。</p>
<p>&emsp;&emsp;这个激进情况真是有够激进，只适用于你所处理的class不带任何数据时。这样的class没有non-static成员变量，没有virtual函数（因为这种函数的存在会为每个对象带来一个vptr），也没有virtual base class（因为这样的base class也会招致体积上的额外开销）。于是这种所谓的empty class对象不使用任何空间，因为没有任何隶属对象的数据需要存储。然而由于技术上的理由，C++裁定凡是独立（非附属）对象都必须有非零大小，所以如果你这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;    <span class="comment">//没有数据，所以其对象应该不使用任何内存</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt</span> &#123;</span>  <span class="comment">//应该只需要一个int空间</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        Empty e;    <span class="comment">//应该不需要任何内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你会发现sizeof(HoldsAnInt) &gt; sizeof(int)；喔欧，一个Empty成员变量竟然要求内存。在大多数编译器中sizeof(Empty)获得1，因为面对“大小为零之独立对象”，通常C++官方勒令默默安插一个char到空对象内。然而齐位需求可能会造成编译器为类似HoldsAnInt这样的class加上一些衬垫，所以有可能HoldsAnInt对象不止获得一个char大小，也许实际上被放大到足够又存放一个int。在我试过的所有编译器中，的确有这种情况发生。</p>
<p>&emsp;&emsp;但或许你注意到了，我很小心地说“独立（非附属）”对象的大小一定不为零。也就是说，这个约束不适用于derived class内的base class成分，因为它们并非独立（非附属）。如果你继承Empty，而不是内含一个那种类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt</span> :</span> <span class="keyword">private</span> Empty &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;几乎可以确定sizeof(HoldsAnInt) == sizeof(int)。这是所谓的EBO（empty base optimization；空白基类最优化），我试过的所有编译器都有这样的结果。如果你是一个程序库开发人员，而你的客户非常在意空间，那么值得注意EBO。另外还值得知道的是，EBO一般只在单一继承（而非多重继承）下才可行，统治C++对象布局的那些规则通常表示EBO无法被施行于“拥有多个base”的derived class身上。</p>
<p>&emsp;&emsp;现实中的“empty”class并不真的是empty。虽然它们从未拥有non-static成员变量，却往往内含typedef，enum，static成员变量，或non-virtual函数。STL就有许多技术用途的empty class，其中内含有用的成员（通常是typedef），包括base class unary_function和binary_function，这些是“用户自定义之函数对象”通常会继承的class。感谢EBO的广泛实践，使这样的继承很少增加derived class的大小。</p>
<p>&emsp;&emsp;尽管如此，让我们回到根本。大多数class并非empty，所以EBO很少成为private继承的正当理由。更进一步说，大多数继承相当于is-a，这是指public继承，不是private继承。复合和private继承都意味is-implemented-in-terms-of，但复合比较容易理解，所以无论什么时候，只要可以，你还是应该选择复合。</p>
<p>&emsp;&emsp;当你面对“并不存在is-a关系”的两个class，其中一个需要访问另一个的protected成员，或需要重新定义一个或多个virtual函数，private继承极有可能成为正统设计策略。即便如此你也已经看到，一个混合了public继承和复合的设计，往往能够满足你要的行为，尽管这样的设计有较大的复杂度。“明智而审慎地使用private继承”意味，在考虑过所有其他方案之后，如果仍然认为private继承是“表现程序内两个class之间的关系”的最佳办法，这才用它。</p>
<blockquote>
<ul>
<li>private继承意味is-implemented-in-terms-of（根据某物实现出）。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。</li>
<li>和复合不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>明智而审慎地使用多重继承</title>
    <url>/2020/11/13/%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<hr>
<h1 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h1><p>&emsp;&emsp;一旦涉及多重继承（MI），C++社群便分为两个基本阵营。其中之一认为如果单一继承（SI）是好的，多重继承一定更好。另一派阵营则主张，单一继承是好的，但多重继承不值得拥有（或使用）。本条款的主要目的是带领大家了解多重继承的两个观点。</p>
<p>&emsp;&emsp;最先需要认清的一件事是，当MI进入设计景框，程序有可能从一个以上的base class继承相同名称（如函数、typedef等等）。那会导致较多的歧义机会。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorrowableItem</span> &#123;</span>    <span class="comment">//图书馆允许你借某些东西</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;  <span class="comment">//离开时进行检查</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectronicGadget</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//执行自我检测，返回是否测试成功</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3Player</span> :</span> </span><br><span class="line">    <span class="keyword">public</span> BorrowableItem,</span><br><span class="line">    <span class="keyword">public</span> ElectronicGadget &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.checkOut();  <span class="comment">//歧义！调用的是哪个checkOut？</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意此例之中对checkOut的调用是歧义（模棱两可）的，即使两个函数之中只有一个可取用（BorrowableItem内的checkOut是public，ElectronicGadget内的却是private）。这与C++用来解析重载函数调用的规则相符：在看到是否有个函数可取用之前，C++首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。本例的两个checkOut有相同的匹配程度，没有所谓最佳匹配。因此ElectronicGadget::checkOut的可取用性也就从未被编译器审查。</p>
<p>&emsp;&emsp;为了解决这个歧义，你必须明白指出你要调用哪一个base class内的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp.BorrowableItem::checkOut();  <span class="comment">//哎呀，原来是这个checkOut</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然你也可以尝试明确调用ElectronicGadget::checkOut，但然后你会获得一个“尝试调用private成员函数”的错误。</p>
<p>&emsp;&emsp;多重继承的意思是继承一个以上的base class，但这些base class并不常在继承体系中又有更高级的base class，因为那会导致要命的“钻石型多重继承”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputFile</span> :</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputFile</span> :</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOFile</span> :</span> <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;任何时候如果你有一个继承体系而其中某个base class和某个derived class之间有一条以上的相通路线（就像上述File和IOFile之间有两条路径，分别穿越InputFile和OutputFile），你就必须面对这样一个问题：是否打算让base class内的成员变量经由每一条路径被复制？假设File class有个成员变量fileName，那么IOFile内该有多少笔这个名称的数据呢？从某个角度说，IOFile从其每一个base class继承一份，所以其对象内应该有两份fileName成员变量。但从另一个角度说，简单的逻辑告诉我们，IOFile对象只该有一个文件名称，所以它继承自两个base class而来的fileName不该重复。</p>
<p>&emsp;&emsp;C++在这场辩论中并没有倾斜立场；两个方案它都支持——虽然其缺省做法是执行复制（也就是上一阶段所说的第一个做法）。如果那不是你要的，你必须令那个带有此数据的class（也就是File）成为一个virtual base class。为了这样做，你必须令所有直接继承自它的class采用“virtual继承”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputFile</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputFile</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOFile</span> :</span> <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;C++标准程序库内含一个多重继承体系，其结构就如上述那样，只不过其class其实是class template，名称分别是basic_ios，basic_istream，basic_ostream和basic_iostream，而非这里的File，InputFile，OutputFile和IOFile。</p>
<p>&emsp;&emsp;从正确行为的观点看，public继承应该总是virtual。如果这是唯一一个观点，规则很简单：任何时候当你使用public继承，请改用virtual public继承。但是，啊呀，正确性并不是唯一观点。为避免继承得来的成员变量重复，编译器必须提供若干幕后戏法，而其后果是：使用virtual继承的那些class所产生的对象往往比使用non-virtual继承的兄弟们体积大，访问virtual base class的成员变量时，也比访问non-virtual base class的成员变量速度慢。种种细节因编译器不同而异，但基本重点很清楚：你得为virtual继承付出代价。</p>
<p>&emsp;&emsp;virtual继承的成本还包括其他方面。支配“virtual base class初始化”的规则比起non-virtual base的情况远为复杂且不直观。virtual base的初始化责任是由继承体系中的最低层class负责，这暗示（1）class若派生自virtual base而需要初始化，必须认知其virtual base——不论那些base距离多远，（2）当一个新的derived class加入继承体系中，它必须承担其virtual base（不论直接或间接）的初始化责任。</p>
<p>&emsp;&emsp;我对virtual base class（也相当于对virtual继承）的忠告很简单。第一，非必要不使用virtual base。平常请使用non-virtual继承。第二，如果你必须使用virtual base class，尽可能避免在其中放置数据。这么一来你就不需担心这些class身上的初始化（和赋值）所带来的诡异事情了。Java和.NET的Interface值得注意，它在许多方面兼容于C++的virtual base class，而且也不允许含有任何数据。</p>
<p>&emsp;&emsp;现在让我们看看下面这个用来塑模“人”的C++Interface class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~IPerson();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> cosnt </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;IPerson的客户必须以IPerson的的pointer和reference来编写程序，因为抽象class无法被实体化创建对象。为了创建一些可被当作IPerson来使用的对象，IPerson的客户使用factory function（工厂函数）将“派生自IPerson的具象class”实体化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IPerson&gt; <span class="title">makePerson</span><span class="params">(DatabaseID personIdentifier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数从使用者手上取得一个数据库ID</span></span><br><span class="line"><span class="function">DatabaseID <span class="title">id</span><span class="params">(askUserForDatabaseID())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IPerson&gt; <span class="title">pp</span><span class="params">(makePerson(id))</span></span>;  <span class="comment">//创建一个对象支持IPerson接口，</span></span><br><span class="line">                                              <span class="comment">//藉由IPerson成员函数处理*pp。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是makePerson如何创建对象并返回一个指针指向它呢？无疑地一定有某些派生自IPerson的具象class，在其中makePerson可以创建对象。</p>
<p>&emsp;&emsp;假设这个class名为CPerson。就像具象class一样，CPerson必须提供“继承自IPerson”的pure virtual函数的实现代码。我们可以从无到有写出这些东西，但更好的是利用既有组件，后者做了大部分或所有必要事情。例如，假设有个既有的数据库相关class，名为PersonInfo，提供CPeron所需要的实质东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~PersonInfo();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theBirthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你可以说这是个旧式class，因为其成员函数返回const char*而不是string对象。尽管如此，如果鞋子合脚，干嘛不穿它？这个class的成员函数的名称已经暗示我们其结果有可能很令人满意。</p>
<p>&emsp;&emsp;你会发现，PersonInfo被设计用来协助以各种格式打印数据库字段，每个字段值的起始点和结束点以特殊字符串为界。缺省的头尾界限符号是方括号（中括号），所以（例如）字段值“Ring-tailed Lemur”被格式化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Ring-tailed Lemur]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但由于方括号并非放之四海人人喜爱的界限符号，所以两个virtual函数valueDelimOpen和valueDelimClose允许derived class设定它们自己的头尾界限符号。PersonInfo成员函数将调用这些virtual函数，把适当的界限符号添加到它们的返回值上。以PersonInfo::theName为例，代码看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">PersonInfo::valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"["</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">PersonInfo::valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">PersonInfo::theName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保留缓冲区给返回值使用；由于缓冲区是static，因此会被自动初始化为“全部是0”</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> value[Max_Formatted_Field_Value_Length];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//写入起始符号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(value, valueDelimOpen());</span><br><span class="line">    <span class="comment">//现在，将value内的字符串添附到这个对象的name成员变量中（小心，避免缓冲区超限）</span></span><br><span class="line">    <span class="comment">//写入结尾符号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcat</span>(value, valueDelimClose());</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;或许有人质疑PersonInfo::theName的老旧设计（特别是它竟然使用固定大小的static缓冲区，那将充斥超限问题和线程问题），但是不妨暂时把这样的疑问放两旁，把以下焦点摆中间：theName调用valueDelimOpen产生字符串起始符号，然后产生name值，然后调用valueDelimClose。由于valueDelimOpen和valueDelimClose都是virtual函数，theName返回的结果不仅取决于PersonInfo也取决于从PersonInfo派生下去的class。</p>
<p>&emsp;&emsp;身为CPerson实现者，这是个好消息，因为仔细阅读IPerson文档后，你发现name和birthDate两函数必须返回未经装饰（不带起始符号和结尾符号）的值。也就是说如果有人名为Homer，调用其name函数理应获得“Homer”而不是“[Homer]”。</p>
<p>&emsp;&emsp;CPerson和PersonInfo的关系是，PersonInfo刚好有若干函数可帮助CPerson比较容易实现出来。就这样。它们的关系因此是is-implemented-in-terms-of（根据某物实现出），而我们知道这种关系可以两种技术实现：复合和private继承。复合通常是较受欢迎的做法，但如果需要重新定义virtual函数，那么继承是必要的。本例之中CPerson需要重新定义valueDelimOpen和valueDelimClose，所以单纯的复合无法应付。最直接的解法就是令CPerson以private形式继承PersonInfo。CPerson也可以结合“复合+继承”技术以求有效重新定义PersonInfo的virtual函数。此处我将使用private继承。</p>
<p>&emsp;&emsp;但CPerson也必须实现IPerson接口，那需得以public继承才能完成。这导致多重继承的一个通情达理的应用：将“public继承自某接口”和“private继承自某实现”结合在一起：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPerson</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~IPerson();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseID</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~PersonInfo();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theBirthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span> :</span> <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">CPerson</span><span class="params">(DatabaseID pid)</span> : <span class="title">PersonInfo</span><span class="params">(pid)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> PersonInfo::theName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> PersonInfo::theBirthDate();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">""</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">""</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个例子告诉我们，多重继承也有它的合理用途。</p>
<p>&emsp;&emsp;故事结束前，请容我说，多重继承只是面向对象工具箱里的一个工具而已。和单一继承比较，它通常比较复杂，使用上也比较难以理解，所以如果你有个单一继承的设计方案，而它大约等价于一个多重继承设计方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候的确是完成任务之最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。只要确定，你的确是在明智而审慎地情况下使用它。</p>
<blockquote>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base class不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相组合。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>了解隐式接口和编译期多态</title>
    <url>/2020/11/14/%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<hr>
<h1 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h1><p>&emsp;&emsp;面向对象编程世界总是以显式接口和运行期多态解决问题。举个例子子，给定这样（无意义）的class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Widget();</span><br><span class="line">        <span class="keyword">virtual</span> ~Widget();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>; </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;和这样（也是无意义）的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(Widget&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以这样说doProcessing内的w：</p>
<ul>
<li>由于w的类型被声明为Widget，所以w必须支持Widget接口。我们可以在源码中找出这个接口（例如在Widget的.h文件中），看看它是什么样子，所以我称此为一个显式接口，也就是它在源码中明确可见。</li>
<li>由于Widget的某些成员函数是virtual，w对那些函数的调用将表现出运行期多态，也就是说将于运行期根据w的动态类型决定究竟调用哪一个函数。</li>
</ul>
<p>&emsp;&emsp;Template及泛型编程的世界，与面向对象有根本上的不同。在此世界中显式接口和运行期多态仍然存在，但重要性降低。反倒是隐式接口和编译期多态移到前头了。若想知道那是什么，看看当我们将doProcessing从函数转变成函数模版时发生什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们怎么说doProcessing内的w呢？</p>
<ul>
<li>w必须支持哪一种接口，系由template中执行于w身上的操作来决定。本例看来w的类型T好像必须支持size,normalize和swap成员函数、copy构造函数（用以建立temp）、不等比较（用来比较smeNasty-Widget）。我们很快会看到这并非完全正确，但对目前而言足够真实。重要的是，这一组表达式（对此template而言必须有效编译）便是T必须支持的一组隐式接口。</li>
<li>凡涉及w的任何函数调用，例如operator&gt;和operator!=，有可能造成template具现化，使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function template”会导致调用不同的函数，这便是所谓的编译期多态。</li>
</ul>
<p>&emsp;&emsp;纵使你从未用过template，应该不陌生“运行期多态”和“编译期多态”之间的差异，因为它类似于“哪一个重载函数该被调用”（发生在编译期）和“哪一个virtual函数该被绑定”（发生在运行期）之间的差异。显式接口和隐式接口的差异就比较新颖，需要更多更贴近的说明和解释。</p>
<p>&emsp;&emsp;通常显示接口由函数的签名式（也就是函数名称、参数类型、返回类型）构成。例如Widget class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Widget();</span><br><span class="line">        <span class="keyword">virtual</span> ~Widget();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其public接口由一个构造函数、一个析构函数、函数size，normalize，swap及其参数类型、返回类型、常量性构成。当然也包括编译器产生的copy构造函数和copy assignment操作符。另外也可以包括typedef。</p>
<p>&emsp;&emsp;隐式接口就完全不同了。它并不基于函数签名式，而是由有效表达式组成。再次看看doProcessing template一开始的条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;T（w的类型）的隐式接口看起来好像有这些约束：</p>
<ul>
<li>它必须提供一个名为size的成员函数，该函数返回一个整数值。</li>
<li>它必须支持一个operator!=函数，用来比较两个T对象。这里我们假设someNastyWidget的类型是T。</li>
</ul>
<p>&emsp;&emsp;真要感谢操作符重载带来的可能性，这两个约束都不需要满足。是的，T必须支持size成员函数，然而这个函数也可能从base class继承而得。这个成员函数不需返回一个整数值，甚至不需返回一个数值类型。就此而言，它甚至不需要返回一个定义由operator&gt;的类型！它唯一需要做的是返回一个类型为X的对象，而X对象加上一个int（10的类型）必须能够调用一个operator&gt;。这个operator&gt;不需要非得取得一个类型为X的参数不可，因为它也可以取得类型Y的参数，只要存在一个隐式转换能够将类型X的对象转换为类型Y的对象！</p>
<p>&emsp;&emsp;同样道理，T并不需要支持operator!=，因为以下这样也是可以的：operator!=接受一个类型为X的对象和一个类型为Y的对象，T可被转换为X而someNastyWidget的类型可被转换为Y，这样就可以有效调用operator!=。</p>
<p>&emsp;&emsp;（偷偷告诉你，以上分析并未考虑这样的可能性：operator&amp;&amp;被重载，从一个连接词改变为或许完全不同的某种东西，从而改变上述表达式的意义。）</p>
<p>&emsp;&emsp;当人们第一次以此种方式思考隐式接口，大多数的他们会感到头疼。但真的不需要阿司匹林来镇痛。隐式接口仅仅是由一组有效表达式构成，表达式自身可能看起来很复杂，但它们要求的约束条件一般而言相当直接又明确。例如一下条件式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) ...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于函数size，operator&gt;，operator&amp;&amp;或operator!=身上的约束条件，我们很难就此说得太多，但整体确认表达式约束条件却很容易。if语句的条件式必须是个布尔表达式，所以无论涉及什么实际类型，无论“w.size() &gt; 10 &amp;&amp; w != someNastyWidget”导致什么，它都必须与bool兼容。这是template doProcessing加诸于其类型参数T的隐式接口的一部分。doProcessing要求其他隐式接口：copy构造函数、normalize和swap也都必须对T型对象有效。</p>
<p>&emsp;&emsp;加诸于template参数身上的隐式接口，就像加诸于class对象身上的显式接口一样真实，而且两者都在编译期完成检查。就像你无法以一种“与class提供之显式接口矛盾”的方式来使用对象（代码将通不过编译），你也无法在template中使用“不支持template所要求之隐式接口”的对象（代码一样通不过编译）。</p>
<blockquote>
<ul>
<li>class和template都支持接口和多态。</li>
<li>对class而言接口是显式的，以函数签名为中心。多态则是通过virtual函数发生于运行期。</li>
<li>对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>了解typename的双重意义</title>
    <url>/2020/11/14/%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<hr>
<h1 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h1><p>&emsp;&emsp;提一个问题：以下template声明式中，class和typename有什么不同？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Widget</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;答案：没有不同。当我们说明template类型参数，class和typename的意义完全相同。某些程序员始终比较喜欢class，因为可以少打几个字。其他人（包括我）比较喜欢typename，因为它暗示参数并非一定得是个class类型。少数开发人员在接受任何类型时使用typename，而在只接受用户自定义类型时保留旧式的class。然而从C++的角度来看，说明template参数时，不论使用关键字class或typename，意义完全相同。</p>
<p>&emsp;&emsp;然而C++并不总是把class和typename视为等价。有时候你一定得使用typename。为了解其时机，我们必须先谈谈你可以在template内指涉的两种名称。</p>
<p>&emsp;&emsp;假设我们有个template function，接受一个STL兼容容器为参数，容器内持有的对象可被赋值为int。进一步假设这个函数仅仅只是打印其第二元素值。这是一个无聊的函数，以无聊的方式实现，而且如稍后所言，它甚至不能通过编译。但请暂时漠视那些事，下面是实践这个愚蠢想法的一种方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;                 <span class="comment">//这不是有效的C++代码</span></span><br><span class="line">    <span class="keyword">if</span>(container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.<span class="built_in">begin</span>())</span></span>;  <span class="comment">//取得第一元素的迭代器</span></span><br><span class="line">        ++iter;                                     <span class="comment">//将iter移往第二元素</span></span><br><span class="line">        <span class="keyword">int</span> value = *iter;                          <span class="comment">//将该元素复制到某个int</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;                         <span class="comment">//打印那个int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我在代码中特别强调两个local变量iter和value。iter的类型是C::const_iterator，实际是什么必须取决于template参数C。template内出现的名称如果相依于某个template参数，称之为从属名称。如果从属名称在class内呈嵌套状，我们称它为嵌套从属名称。C::const_iterator就是这样一个名称。实际上它还是个嵌套从属类型名称，也就是个嵌套从属名称并且指涉某类型。</p>
<p>&emsp;&emsp;print2nd内的另一个local变量是value，其类型是int。int是一个并不依赖任何template参数的名称。这样的名称是谓非从属名称。我不知道为什么不叫独立名称。如果你和我一样认为术语“non-dependent”令人憎恶，你我之间起了共鸣。但毕竟“non-dependent”已被定为这一类名称的术语，所以请和我一样，眨眨眼然后顺从它吧。</p>
<p>&emsp;&emsp;嵌套从属名称有可能导致解析困难。举个例子，假设我们令print2nd更愚蠢些，这样起头：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    C::const_iterator* x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来好像我们声明x为一个local变量，它是个指针，指向一个C::const_iterator。但它之所以被那么认为，只因为我们“已经知道”C::const_iterator是个类型。如果C::const_iterator不是个类型呢？如果C有个static成员变量而碰巧被命名为const_iterator，或如果x碰巧是个global变量名称呢？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作：C::const_iterator乘以x。当然啦，这听起来有点疯狂，但却是可能的，而撰写C++解析器的人必须操心所有可能的输入，甚至是这么疯狂的输入。</p>
<p>&emsp;&emsp;在我们知道C是什么之前，没有任何办法可以知道C::const_iterator是否为一个类型。而当编译器开始解析template print2nd时，尚未确认C是什么东西。C++有个规则可以解析此一歧义状态：如果解析器在template中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是，所以缺省情况下嵌套从属名称不是类型。此规则有个例外，稍后我会提到。</p>
<p>&emsp;&emsp;把这些记在心上，现在再次看看print2nd起始处：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.<span class="built_in">begin</span>())</span></span>;  <span class="comment">//这个名称被假设为非类型</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在应该很清楚为什么这不是有效的C++代码了吧。iter声明式只有在C::const_iterator是个类型时才合理，但我们并没有告诉C++说它是，于是C++假设它不是。若要矫正这个形势，我们必须告诉C++说C::const_iterator是个类型。只要紧临它之前放置关键字typename即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;  <span class="comment">//现在，这是合法的C++代码了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.<span class="built_in">begin</span>())</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般性规则很简单：任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename。（再提醒一次，很快我会谈到一个例外。）</p>
<p>&emsp;&emsp;typename只被用来验明嵌套从属名称：其他名称不该有它存在。例如下面这个function template，接受一个容器和一个“指向该容器”的迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;            <span class="comment">//允许使用“typename”（或“class”） </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp; container,       <span class="comment">//不允许使用“typename”</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">typename</span> C::iterator iter)</span></span>;  <span class="comment">//一定要使用“typename”</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述的C并不是嵌套从属类型名称（它并非嵌套于任何“取决于template参数”的东西内），所以声明container时并不需要以typename为前导，但C::iterator是个嵌套从属类型名称，所以必须以typename为前导。</p>
<p>&emsp;&emsp;“typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是，typename不可以出现在base class list内的嵌套从属类型名称之前，也不可在member initialization list（成员初值列）中作为base class修饰符。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span> : Base&lt;T&gt;::<span class="title">Nested</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的不一致性真令人恼恨，但一旦你有了一些经验，勉勉强强还能接受它。</p>
<p>&emsp;&emsp;让我们看看最后一个typename例子，那是你将在真实程序中看到的代表性例子。假设我们正在撰写一个function template，它接受一个迭代器，而我们打算为该迭代器指涉的对象做一份local复件temp。我们可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;别让std::iterator_traits&lt;IterT&gt;::value_type惊吓了你，那只不过是标准traits class的一种运用，相当于说“类型为IterT之对象所指之物的类型”。这个语句声明一个local变量（temp），使用IterT对象所指物的相同类型，并将temp初始化为iter所指物。如果IterT是vector&lt;int&gt;::iterator，temp的类型就是int。如果IterT是vector&lt;string&gt;::iterator，temp的类型就是string。由于std::iterator_traits&lt;IterT&gt;::value_type是个嵌套从属类型名称，所以我们必须在它之前放置typename。</p>
<p>&emsp;&emsp;如果你认为std::iterator_traits&lt;IterT&gt;::value_type读起来不畅快，想象一下打那么长的字又是什么光景。如果你像大多数程序员一样，认为多打几次这些字实在很恐怖，那么你应该会想建立一个typedef。对于traits成员名称如value_type。普遍的习惯是设定typedef名称用以代表某个traits成员名称，于是常常可以看到类似这样的local typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多程序员最初认为把“typedef typename”并列颇不和谐，但它实在是指涉“嵌套从属类型名称”的一个合理附带结果。你很快会习惯它，毕竟你有强烈的动机——你希望多打几次typename std::iterator_traits&lt;IterT&gt;::value_type吗？</p>
<p>&emsp;&emsp;作为结语，我应该提出，typename相关规则在不同的编译器上有不同的实践。某些编译器接受的代码原本该有typename却遗漏了；原本不该有typename却出现了；还有少数编译器（通常是较旧版本）根本就拒绝typename。这意味typename和“嵌套从属类型名称”之间的互动，也许会在移植性方面带给你某种温和的头疼。</p>
<blockquote>
<ul>
<li>声明template参数时，前缀关键字class和typename可互换。</li>
<li>请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class修饰符。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>学习处理模版化基类内的名称</title>
    <url>/2020/11/15/%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E7%89%88%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<hr>
<h1 id="学习处理模版化基类内的名称"><a href="#学习处理模版化基类内的名称" class="headerlink" title="学习处理模版化基类内的名称"></a>学习处理模版化基类内的名称</h1><p>&emsp;&emsp;假设我们需要撰写一个程序，它能够传送信息到若干不同的公司去。信息要不译成密码，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于template的解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">...                     <span class="comment">//针对其他公司设计的class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span> ... &#125;;  <span class="comment">//这个class用来保存信息，以备将来产生信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> msg;</span><br><span class="line">            <span class="comment">//在这里，根据info产生信息</span></span><br><span class="line">            Company c;</span><br><span class="line">            c.sendCleartext(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            ...  <span class="comment">//类似sendClear，唯一不同的是这里调用c.sendEncrypted</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个做法行得通。但假设我们有时候想要在每次送出信息时志记某些信息。derived class可轻易加上这样的生产力，那似乎是个合情合理的解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将“传送前”的信息写至log</span></span><br><span class="line">            sendClear(info);  <span class="comment">//调用base class函数，这段代码无法通过编译。</span></span><br><span class="line">            <span class="comment">//将“传送后”的信息写至log</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意这个derived class的信息传送函数有一个不同的名称（sendClearMsg），与其base class内的名称（sendClear）不同。那是个好设计，因为它避免遮掩“继承而得的名称”，也避免重新定义一个继承而得的non-virtual函数。但上述代码无法通过编译，至少对严守规律的编译器而言。这样的编译器会抱怨sendClear不存在。我们的眼睛可以看到sendClear的确在base class内，编译器却看不到它们。为什么？</p>
<p>&emsp;&emsp;问题在于，当编译器遭遇class template LoggingMsgSender定义式时，并不知道它继承什么样的class。当然它继承的是MsgSender&lt;Company&gt;，但其中的Company是个template参数，不到后来（当LoggingMsgSender被具现化）无法确切知道它是什么，而如果不知道Company是什么，就无法知道class MsgSender&lt;Company&gt;看起来像什么——更明确地说是没办法知道它是个sendClear函数。</p>
<p>&emsp;&emsp;为了让问题更具现化，假设我们有个class CompanyZ坚持使用加密通讯：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span> &#123;</span>  <span class="comment">//这个class不提供sendClearText函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般性的MsgSender template对CompanyZ并不合适，因为那个template提供了一个sendClear函数（其中针对其类型参数Company调用了sendCleartext函数），而这对CompanyZ对象并不合理。欲矫正这个问题，我们可以针对CompanyZ产生一个MsgSender特化版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span> &lt;CompanyZ&gt; &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意class定义式最前头的“template &lt;&gt;”语法象征这既不是template也不是标准class，而是个特化版的MsgSender template，在template实参是CompanyZ时被使用。这是所谓的模版全特化：template MsgSender针对类型CompanyZ特化了，而且其特化是全面性的，也就是说一旦类型参数被定义为CompanyZ，再没有其他template参数可供变化。</p>
<p>&emsp;&emsp;现在，MsgSender针对CompanyZ进行了全特化，让我们再次考虑derived class LoggingMsgSender：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogginMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将“传送前”的信息写至log</span></span><br><span class="line">            sendClear(info);  <span class="comment">//如果Company == CompanyZ，这个函数不存在。</span></span><br><span class="line">            <span class="comment">//将“传送后”的信息写至log</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;正如注释所言，当base class被指定为MsgSender&lt;CompanyZ&gt;时这段代码不合法，因为那个class并未提供sendClear函数！那就是为什么C++拒绝这个调用的原因：它知道base class template有可能被特化，而那个特化版本不可能提供和一般性template相同的接口。因此它往往拒绝在templatized base class（模版化基类，本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear）。就某种意义而言，当我们从Object Oriented C++跨进Template C++。继承就不像以前那般畅行无阻了。</p>
<p>&emsp;&emsp;为了重头来过，我们必须有某种办法令C++“不进入templatized base class观察”的行为失效。有三个办法，第一是在base class函数调用动作之前加上“this-&gt;”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogginMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将“传送前”的信息写至log</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;sendClear(info);  <span class="comment">//成立，假设sendClear将被继承</span></span><br><span class="line">            <span class="comment">//将“传送后”的信息写至log</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第二是使用using声明式。“”描述using声明式如何将“被遮掩的base class名称”带入一个derived class作用域内。我们可以这样写下sendClearMsg：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;  <span class="comment">//告诉编译器，请它假设</span></span><br><span class="line">        ...                                   <span class="comment">//sendClear位于base class内。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            sendClear(info);  <span class="comment">//OK，假设sendClear将被继承下来</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;（虽然using声明式在这里或在“”都可有效运行，但两处解决的问题其实不同。这里的情况并不是base class名称被derived class名称遮掩，而是编译器不进入base class作用域内查找，于是我们通过using告诉它，请它那么做。）</p>
<p>&emsp;&emsp;第三个做法，明白指出被调用函数位于base class内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendCLearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            MsgSender&lt;Company&gt;::sendClear(info);  <span class="comment">//OK，假设sendClear将被继承下来。</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但这往往是最不让人满意的一个解法，因为如果被调用的是virtual函数，上述的明确资格修饰会关闭“virtual绑定行为”。</p>
<p>&emsp;&emsp;从名称可视点的角度出发，上述每一个解法做的事情都相同：对编译器承诺“base class template的任何特化版本都将支持其一般（泛化）版本所提供的接口”。这样一个承诺是编译器在解析像LoggingMsgSender这样的derived class template时需要的。但如果这个承诺最终未被实践出来，往后的编译最终还是会还给事实一个公道。举个例子，如果稍后的源码内含这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LoggingMsgSender&lt;CompanyZ&gt; zMsgSender;</span><br><span class="line">MsgInfo msgData;</span><br><span class="line">...                                <span class="comment">//在msgData内放置信息。</span></span><br><span class="line">zMsgSender.sendClearMsg(msgData);  <span class="comment">//错误！无法通过编译。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中对sendClearMsg的调用动作将无法通过编译，因为在那个点上，编译器知道base class是个template特化版本MsgSender&lt;CompanyZ&gt;，而且它们知道那个class不提供sendClear函数，而后者却是sendClearMsg尝试调用的函数。</p>
<p>&emsp;&emsp;根本而言，本条款探讨的是，面对“指涉base class members”之无效reference，编译器的诊断时间可能发生在早期（当解析derived class template的定义式时）。C++的政策是宁愿较早诊断，这就是为什么“当base class从template中被具现化时”它假设它对那些base class的内容毫无所悉的缘故。</p>
<blockquote>
<ul>
<li>可在derived class template内通过“this-&gt;”指涉base class template内的成员名称，或藉由一个明白写出的“base class资格修饰符”完成。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>automake工具——介绍</title>
    <url>/2020/11/16/automake%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="automake工具——介绍"><a href="#automake工具——介绍" class="headerlink" title="automake工具——介绍"></a>automake工具——介绍</h1><p>&emsp;&emsp;automake是一个自动化工具，可以通过一个名为Makefile.am的文件来自动生成Makefile.in文件。每一个Makefile.in文件本质上就是一连串的的make命令变量的定义，通常会伴有相关规则。生成的Makefile.in文件遵从GNU Makefile的标准。</p>
<p>&emsp;&emsp;GNU Makefile的标准文档既冗长又复杂，并且随时都会更改。automake的目的就是要为GNU的个人维护者移除Makefile的维护负担（并且将其置于automake维护者的工作幕后）。</p>
<p>&emsp;&emsp;典型的automake输入文件仅仅是一连串的变量定义。每个这样的文件都被进一步用来创建Makefile.in文件。</p>
]]></content>
  </entry>
  <entry>
    <title>剔除template内与参数无关的代码</title>
    <url>/2020/11/16/%E5%89%94%E9%99%A4template%E5%86%85%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<hr>
<h1 id="剔除template内与参数无关的代码"><a href="#剔除template内与参数无关的代码" class="headerlink" title="剔除template内与参数无关的代码"></a>剔除template内与参数无关的代码</h1><p>&emsp;&emsp;使用template可以有效地避免代码重复。有时候你会需求10个类，每一个都含有100个成员函数（当然啦，这里稍微有点夸张）。那么在此情况下，你只需要编写一个class template，然后剩下的事情就交给编译器去吧，由编译器来具现化这10个类跟1000个成员函数。由于class template的成员函数只有在被使用时才会被具现化，因此只有当某些函数被真正使用时，你才会获得这些函数。同样的，function template也有此类功能。为了避免写出大量重复函数代码，你只需要写一个function template，然后让编译器去完成剩下的事情就够了。看来“懒惰”才是推进人类技术进步的关键。</p>
<p>&emsp;&emsp;但是，如果你的经验不够老道，使用template也可能会导致代码膨胀：其二进制码会带着重复的代码、数据，或两者都有。其结果就是：有可能看起来源码倒是挺干净整齐的，但目标码却不是这样的。所以你需要知道如何避免这样的二进制码臃肿。</p>
<p>&emsp;&emsp;这里要提到一个名称：commonality and variability analysis。翻译过来就是共性与变性分析，即使你从来没有写过template，你也应该熟悉这个分析方式。</p>
<p>&emsp;&emsp;比如，当你编写某个函数时，你会发现其中一个函数的某些实现码与另一个函数的实现码实质上是一样的。当然，一般来说我们不会去单纯地去重复这些代码，除非你是一个懒惰且不求甚解的程序员。为了避免这种情况，你一般会抽出这两个函数共同的部分，把它们放到第三个函数中，然后令原先两个函数调用这个函数。所谓“共性与变性分析”也就是：你分析这两个函数，找出它们共同的部分和变化的部分，把共同的部分搬到一个新函数去，保留变化的部分在原函数中不动。同样的道理，对于class来说，假设你正在编写2个class，而你需要将其中一个class与另外一个class共同的部分搬到一个新的class去，然后使用继承或复合，令原先的class取得这个共同特性。而原class的互异部分依然保留在原来的位置。</p>
<p>&emsp;&emsp;编写template时，也是要做上述类似的分析，以相同的方式来避免重复，但这里有一个关键点。在non-template中，重复的源码十分清楚明了：你可以“看到”两个函数或两个class之间确实有所“重复”。然而在template代码中，重复却是隐晦的：毕竟只存在一份template源码，所以你必须要能够感受到当template被具现化多次时可能发生的重复，这种感知需要长期的训练。</p>
<p>&emsp;&emsp;举个例子，假设你要为一个固定尺寸的正方形矩阵编写一个template。该矩阵的性质之一是支持逆矩阵运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typeame T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span>;  <span class="comment">//求逆矩阵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个template接受一个类型参数T，还有一个类型为size_t的参数（这是一个非类型参数）。这种非类型参数比起类型参数并不是那么常见，但是它们是合法的.</p>
<p>&emsp;&emsp;现在，考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm1.invert();  <span class="comment">//调用SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.invert();  <span class="comment">//调用SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码会具现出两份invert。这些函数并非完全相同，因为其中一个操作的是5*5矩阵而另一个操作的是10*10矩阵，但除了这两个常量5跟10，两个函数的其他部分完全相同。这是template造成代码膨胀的一个典型例子。</p>
<p>&emsp;&emsp;如果你看到两个函数完全相同，除了一个使用5而另一个使用10，这种情况下，你会怎么做？你的本能可能会为它们创建一个带数值参数的函数，然后以5和10来调用这个带参数的函数，而不重复代码。下面是对SquareMatrix的第一次修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span> &#123;</span>                      <span class="comment">//与尺寸无关的base class用于正方矩阵</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> matrixSize)</span></span>;  <span class="comment">//以给定尺寸求逆矩阵</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;  <span class="comment">//避免遮掩base版的invert</span></span><br><span class="line">                                            <span class="comment">//避免编译器不进入到base class作用域内查找invert</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;invert(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;base class SquareMatrixBase内有带参数的invert。也就是说，其只对“矩阵对象的类型”参数化，不对矩阵的尺寸参数化。因此对于某给定的对象类型，所有该类型的矩阵共享同一个SquareMatrixBase class，当然其中的带参数的invert也是共享的。</p>
<p>&emsp;&emsp;SquareMatrixBase::invert本意是为了“避免derived class代码重复”，并没有打算提供给用户这个机能，因此它以protected替换public。并且调用它的额外成本应该为0，因为derived class的invert调用base class版本时用的是inline调用。这里的函数应该使用“this-&gt;”，正如“<a href="/2020/11/15/%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E7%89%88%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/" title="学习处理模版化基类内的名称">学习处理模版化基类内的名称</a>”所说，若不这样做，编译器便不会进入到base class作用域内查找SquareMatrixBase的invert。最后，要注意的是上述代码的继承关系为private。也就是说这里的base class只是为了帮助derived class实现，而不是为了表现SquareMatrix和SquareMatrixBase之间的is-a关系。</p>
<p>&emsp;&emsp;接下来棘手的问题来了，SquareMatrixBase::invert如何知道该操作什么数据？虽然它从参数中知道了矩阵的尺寸，但它又如何知道哪个特定矩阵的数据在哪儿？想必只有derived class才知道吧。那么问题又来了，derived class该如何联络base class做逆矩阵运算呢？</p>
<p>&emsp;&emsp;其中一个办法是令SquareMatrixBase存储一个指针，指向矩阵数值所在的内存。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span> &#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        SquareMatrixBase(<span class="built_in">std</span>::<span class="keyword">size_t</span> n, T* pMem)  <span class="comment">//存储矩阵大小和一个指针</span></span><br><span class="line">            : <span class="built_in">size</span>(n), pData(pMem) &#123;&#125;             <span class="comment">//指针指向矩阵数值</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setDataPtr</span><span class="params">(T* ptr)</span> </span>&#123; pData = ptr; &#125;  <span class="comment">//重新赋值给pData</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>;  <span class="comment">//矩阵的大小</span></span><br><span class="line">        T* pData;          <span class="comment">//指针，指向矩阵内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这允许derived class决定内存分配方式。某些实现版本也许会将矩阵数据存储在SquareMatrix对象内部：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SquareMatrix()                         <span class="comment">//将矩阵大小</span></span><br><span class="line">            : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125;  <span class="comment">//和数据指针送给base class</span></span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种类型的对象不需要动态分配内存，但对象自身可能非常大。另一种做法是把每一个矩阵的数据放进heap（也就是通过new来分配内存）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SquareMatrix()                          <span class="comment">//将base class的数据指针设为null，</span></span><br><span class="line">            : SquareMatrixBase&lt;T&gt;(n, <span class="number">0</span>),        <span class="comment">//为矩阵内容分配内存，</span></span><br><span class="line">            pData(<span class="keyword">new</span> T[n*n])                   <span class="comment">//将指向该内存的指针存储起来，</span></span><br><span class="line">            &#123; <span class="keyword">this</span>-&gt;setDataPtr(pData.<span class="built_in">get</span>()); &#125;  <span class="comment">//然后将它的一个副本交给base class</span></span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        boost::scoped_array&lt;T&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码中SquareMatrix成员函数可以单纯地以inline方式调用base class版本，后者由“持有同类型元素（不论矩阵大小）之所有矩阵共享。更棒的是，不同大小的SquareMatrix对象现在有着不同的类型！即使（例如SquareMatrix&lt;double,5&gt;和SquareMatrix&lt;double,10&gt;）对象使用相同的SquareMatrixBase&lt;double&gt;成员函数，你也没法传递一个SquareMatrix&lt;double,5&gt;对象到一个期望获得SquareMatrix&lt;double,10&gt;的函数去。</p>
<p>&emsp;&emsp;这确实很棒，但是必须要付出一定的代价。绑着矩阵尺寸的那个invert版本，有可能生成比共享版本（其中尺寸是以函数参数传递或存储在对象内）更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以借助常量的“广泛传播性”达到最优化，包括把它们置于生成指令中成为直接操作数。这在“与尺寸无关”的版本中是无法办到的。</p>
<p>&emsp;&emsp;但是从另一个角度看，不同大小的同类型矩阵共享一个invert，可以减少执行文件的大小，也就因此降低了程序的working set（所谓working set是指对一个在“虚内存环境”下执行的进程而言，其所使用的那一组内存页）大小，并强化指令高速缓存区内的引用集中化。这些都可能令程序执行得更加快速，从而超越“尺寸专属版”invert的最优化效果。孰优孰劣就得看你的平台的行为以及实际代码中数据的表现了。</p>
<p>&emsp;&emsp;另一个效能评比的主题是对象大小。现在将前述“与矩阵大小无关的函数版本”搬到base class内，这会增加每个对象的大小。例如在上述代码中，每一个SquareMatrix对象都有一个指针（继承自base class）指向其内矩阵的数据。虽然每个derived class已有一种取得数据的办法，这会对每一个SquareMatrix对象增加至少一个指针那么大。当然你也可以修改这个设计，将这些指针拿掉，但是这依旧会留给你若干抉择问题。例如令base class存储一个protected指针指向矩阵数据，会导致其丧失封装性，也可能造成资源管理上的混乱和复杂。如果base class存储一个指针指向矩阵数据，那些数据空间也许是动态分配的，也许存储于derived class对象内，如何判断这个指针该不该删除呢？这个问题的答案留给你在以后的工作中慢慢思索，但是你越是尝试精密的做法，事情就会变得越发复杂。从这个角度来看，少许的代码重复倒是挺合情合理的。</p>
<p>&emsp;&emsp;综上讨论的都还仅限于非类型模版参数带来的膨胀，其实类型参数也会导致膨胀。例如在许多平台上int和long有相同的二进制表述，所以像vector&lt;int&gt;和vector&lt;long&gt;的成员函数有可能完全相同——也就是膨胀！某些连接器会合并完全相同的函数实现码，但有些不会，后者也就意味着某些template被具现化为int和long两个版本，并因此造成代码膨胀（在某些环境下）。同样，在大多数平台上，所有指针类型都有相同的二进制表述，因此凡是template持有指针者（例如list&lt;int<em>&gt;，list&lt;const int\</em>&gt;，list&lt;SquareMatrix&lt;long,3&gt;*&gt;等等）往往应该对每一个成员函数使用唯一一份底层实现。这意味，如果你实现某些成员函数而它们操作强指针类型（即T*），你应该令它们调用另一个操作无类型指针（即void*）的函数，由后者完成实际工作。某些C++标准程序库实现版本为vector，deque和list等template做了这件事。如果你在想着如何为你的template减少代码膨胀，可以参考前述的代码程序库。</p>
<blockquote>
<ul>
<li>template生成多个class和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相互依赖的关系。</li>
<li>因非类型模版参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li>
<li>因类型模版参数而造成的代码膨胀，往往可降低，做法是让带有完全二进制表述的具现类型共享实现码。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>编写有兼容性的成员函数模版</title>
    <url>/2020/11/18/%E7%BC%96%E5%86%99%E6%9C%89%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<hr>
<h1 id="编写有兼容性的成员函数模版"><a href="#编写有兼容性的成员函数模版" class="headerlink" title="编写有兼容性的成员函数模版"></a>编写有兼容性的成员函数模版</h1><p>&emsp;&emsp;STL容器的迭代器几乎总是智能指针，其优点不言而喻：可以在正确的时机自动删除heap-based资源。对于真实指针而言，做的较好的一件事是，支持隐式转换。Derived class指针可以隐式转换为base class指针，“指向non-const对象”的指针可以转换为“指向const对象”等等。以下为三层继承体系中的转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle;</span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom;</span><br><span class="line"><span class="keyword">const</span> Top* cpt = pt1;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;那么在智能指针中的转换又是如何呢？接下来我们希望以下代码可以通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> Top&gt; cpt = pt1;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是从同一个tamplate具现出来的不同具现体之间并没有任何“关系”，也就是说如果以带有base-derived关系的B，D类型分别具现化某个template，产生出来的两个具现体并不带有base-derived关系。所以编译器视SmartPtr&lt;Middle&gt;和SmartPtr&lt;Top&gt;为两个不同的class。为了使SmartPtr class之间具有转换能力，我们必须更进一步的将它们编写出来。</p>
<p>&emsp;&emsp;在对上述代码进行修改前，你似乎会构思出这样的想法：根据一个SmartPtr&lt;Middle&gt;或一个SmartPtr&lt;Bottom&gt;构造出一个SmartPtr&lt;Top&gt;，以此来完成转换。但是如果这个继承体系未来将进一步扩充的话，我们需要的构造函数数量也会进一步扩充，对于一个template来说，这样的扩充似乎无穷无尽，因为template可以被无限量地具现化。因此，让我们换个思路来解决上述问题，我们需要的不是为SmartPtr写一个构造函数，而是为它写一个构造模版。这样的模版也就是所谓的member function template，其作用是为class生成函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码意思是，对于任何T类型和任何U类型，这里可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;——因为SmartPtr&lt;T&gt;它的构造函数接受的是一个SmartPtr&lt;U&gt;参数。这一类构造函数根据对象u创建对象t（例如根据SmartPtr&lt;U&gt;创建一个SmartPtr&lt;T&gt;），而u和v的类型是同一个template的不同具现体，这类构造函数也就是泛化copy构造函数。</p>
<p>&emsp;&emsp;你会注意到上述泛化copy构造函数并未被声明为explicit。因为原始指针类型之间的转换（例如从derived class指针转为base class指针）是隐式转换，没有必要写出转型动作（cast），所以为了让我们的智能指针也表现出这种行为，在模版化构造函数时，我们略去了explicit。</p>
<p>&emsp;&emsp;现在我们可以对这个代码进行更进一步的优化。期望可以根据一个SmartPtr&lt;Bottom&gt;创建一个SmartPtr&lt;Top&gt;，而且我们不会期望根据一个SmartPtr&lt;Top&gt;创建一个SmartPtr&lt;Bottom&gt;，因为这对于public继承来说是矛盾的。当然，我们肯定也不会希望根据一个SmartPtr&lt;double&gt;创建出一个SmartPtr&lt;int&gt;，因为实际情况中并不会存在这样一个行为“将int*转换为double*”。也就是，我们必须要从某个方面来对member template所创建的成员函数簇进行一个剔除或筛选。</p>
<p>&emsp;&emsp;现在让我们一步一步创建起来的SmartPtr遵循std::shared_ptr那样的模版，也提供一个get成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模版”实现代码中约束转换行为，使它符合我们对它的期望：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) </span><br><span class="line">            : heldPtr(other.<span class="built_in">get</span>()) &#123; ... &#125;</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* heldPtr;  <span class="comment">//SmartPtr持有的内置（原始）指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我使用成员初值列来初始化SmartPtr&lt;T&gt;之类型为T*的成员变量，并用类型U*的指针（由SmartPtr&lt;U&gt;持有）作为初值。啊哈，这个结果正是我们想要的：只有当U*指针可以隐式转换为T*指针时该代码才可以通过编译。那么经过这一轮的优化，最终得到了我们想要的结果——这个构造函数只有在其所获得的实参属于兼容类型时才可以通过编译。</p>
<p>&emsp;&emsp;同样的，member function template也常用于赋值操作。例如std::shared_ptr支持所有“来自兼容类型的内置指针、std::shared_ptr和std::weak_ptr”的构造行为。以及所有来自上述各物（std::weak_ptr除外）的赋值操作。以下是关于std::shared_ptr的一份简单摘要码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt; </span></span><br><span class="line"><span class="class">        <span class="title">explicit</span> <span class="title">shared_ptr</span>(<span class="title">Y</span>* <span class="title">p</span>);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">share_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">explicit</span> <span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">weak_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>&amp; <span class="title">operator</span>=(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你会注意到上述所有构造函数都是explicit，除了“泛化copy构造函数”。这意味着从某个shared_ptr类型隐式转换至另一个shared_ptr类型是被允许的，但从某个内置指针或从其它智能指针类型进行隐式转换则不被允许（如果是显式转换，例如cast强制转型动作倒是可以）。</p>
<p>&emsp;&emsp;虽然member function template（成员函数模版）趣味无穷，但它们并不影响语言基本规则的运行。那意味着编译器仍然可能会为我们产生四个成员函数，其中两个是copy构造函数和copy assignment操作符。问题来了，让我们把关注点放到std::shared_ptr的泛化copy构造函数上，一旦T和Y的类型相同，泛化copy构造函数会被具现化为“正常的”copy构造函数。那么究竟编译器会暗自为std::shared_ptr生成一个copy构造函数呢？亦或是当某个std::shared_ptr对象根据另一个同型的std::shared_ptr对象展开构造行为时，编译器会将“泛化copy构造函数”具现化呢？</p>
<p>&emsp;&emsp;就像我所说的member template并不会改变语言规则，而语言规则说，如果程序需要一个copy构造函数，你却没有声明它，编译器会为你暗自生成一个。在class内声明泛化copy构造函数并不会阻止编译器生成它们自己的copy构造函数，所以如果你想要控制copy构造的方方面面，你必须同时声明泛化copy构造函数和“正常的”copy构造函数。这对于赋值操作也同样适用。以下代码展示了这一要点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; r);  <span class="comment">//copy构造函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; r);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>&amp; <span class="title">operator</span>=(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>请使用member function template（成员函数模版）生成“可接受所有兼容类型”的函数。</li>
<li>如果你声明member template用于“泛化copy构造函数”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用friend non-member function来完成template中的类型转换机能</title>
    <url>/2020/11/19/%E4%BD%BF%E7%94%A8friend%20non-member%20function%E6%9D%A5%E5%AE%8C%E6%88%90template%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E8%83%BD/</url>
    <content><![CDATA[<hr>
<h1 id="使用friend-non-member-function来完成template中的类型转换机能"><a href="#使用friend-non-member-function来完成template中的类型转换机能" class="headerlink" title="使用friend non-member function来完成template中的类型转换机能"></a>使用friend non-member function来完成template中的类型转换机能</h1><p>&emsp;&emsp;“<a href="/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/" title="若所有参数皆需类型转换，请为此采用non-member函数">若所有参数皆需类型转换，请为此采用non-member函数</a>”这个条款讨论过为什么只有non-member函数才有能力“在所有实参身上实施隐式类型转换”。由于此文也是以它作为基础的延伸，所以强烈建议你先熟稔那个例子，本文将对那个例子进行一系列的改动，对Rational和operator*模版化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>,</span><br><span class="line">                 <span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就像“<a href="/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/" title="若所有参数皆需类型转换，请为此采用non-member函数">若所有参数皆需类型转换，请为此采用non-member函数</a>”一样，我们希望template版本支持混合式算术运算，所以我们期望以下代码可以顺利通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="keyword">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = oneHalf * <span class="number">2</span>;  <span class="comment">//错误！无法通过编译。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;奇怪了，为什么non-template版本的可以通过编译，而这里却不行呢？模版化的Rational内的某些东西似乎和non-template版本不同。non-template版本中，编译器知道我们尝试调用什么函数（就是接受两个Rational参数的那个operator*啦），但是这里编译器不知道我们想要调用哪个函数。反而，它们自己倒是试图去想出什么函数被名为operator*的template具现化出来。它们知道（与其说“知道”倒不如说是“自认为”）自己应该可以具现化某个“名为operator*并接受两个Rational&lt;T&gt;参数”的函数，但为了完成这个目标，必须先算出T是什么，问题是它们没有这个能耐。</p>
<p>&emsp;&emsp;编译器为了推导出T，它们会将operator*调用行为中的实参类型分别纳入考虑范围内。</p>
<p>&emsp;&emsp;operator*的第一实参被声明为Rational&lt;T&gt;，而传递给operator*的第一实参（oneHalf）的类型是Rational&lt;int&gt;，所以T一定是int。但是其他参数的推导则没有这么顺利。operator*的第二实参被声明为Rational&lt;T&gt;，但是传递给operator*的第二实参类型是int，编译器如何才能根据这个推算出T？或许你以为编译器会这样工作：编译器使用Rational&lt;int&gt;的non-explicit构造函数将2转换为Rational&lt;int&gt;，进而将T推导为int。错！编译器不会如你所愿，因为在template实参推导过程中从不将隐式类型转换函数纳入考虑。这样的转换虽然在函数调用中确实被使用，但是在能够调用一个函数前，首先必须知道那个函数存在。而为了知道它，必须先为相关的function template推导出参数类型（然后才可以将适当的函数具现化出来）。然而template实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。这也正是C++与其他语言不同的地方，就像“<a href="/2020/07/17/%E8%A7%86C++%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/" title="视C++为一个语言联邦">视C++为一个语言联邦</a>”所说的那样，我们现在处于template part of C++领域内，有着不同的规则。</p>
<p>&emsp;&emsp;令人兴奋的是，class template并不倚赖template实参推导（后者只施行于function template身上），所以编译器总是能够在class Rational&lt;T&gt;具现化时得知T。那么你应该会自然而然的想到一个点子：声明operator*为class Rational&lt;T&gt;的一个friend函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">        <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                                 <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在对operator*的混合式调用可以通过编译了，因为当对象oneHalf被声明为一个Rational&lt;int&gt;，class Rational&lt;int&gt;于是被具现化出来，而作为过程的一部分，friend函数operator*（接受Rational&lt;int&gt;参数）也就被自动声明出来。后者身为一个函数而非函数模版，因此编译器可在调用它时使用隐式转换函数（例如Rational的non-explicit构造函数），而这便是混合式调用之所以“成功”的原因。</p>
<p>&emsp;&emsp;但是这里的“成功”并不完全成功，因为虽然这段代码通过编译，却无法连接。混合式代码通过了编译，因为编译器知道我们要调用哪个函数（就是接受一个Rational&lt;int&gt;以及又一个Rational&lt;int&gt;的那个operator*），但是那个函数只被声明于Rational内，并没有被定义出来。我们试图令次class外部的operator* template提供定义式，但是行不通——如果我们自己声明了一个函数（这也是Rational template内的行为），就有责任定义那个函数。既然我们没有提供定义式，连接器当然找不到它！</p>
<p>&emsp;&emsp;或许最简单的可行办法就是将operator*函数本体合并至其声明式内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">friend</span> </span><br><span class="line">        <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                                 <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> Rational(lhs.numberator() * rhs.numberator(),</span><br><span class="line">                            lhs.denominator() * rhs.denominator());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在对operator*对混合式调用可以编译连接并执行了。</p>
<p>&emsp;&emsp;这项技术的一个趣味点是，我们虽然使用了friend，却与friend的传统用途“访问class点non-public成分”毫不相干。为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（“<a href="/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/" title="若所有参数皆需类型转换，请为此采用non-member函数">若所有参数皆需类型转换，请为此采用non-member函数</a>”）；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是：令它成为一个friend。</p>
<p>&emsp;&emsp;定义于class内的函数都会暗自成为inline，包括像operator*这样的friend函数。你也可以将这样的inline声明所带来的冲击最小化，做法就是令operator*不做任何事情，只调用一个定义于class外部的辅助函数。在本例之中，这样做并没有太大意义，因为operator*已经是个单行函数了，但是对于更复杂的函数而言，这样做也许更有价值。“令friend函数调用辅助函数”的做法值得我们接下来好好探究一番。</p>
<p>&emsp;&emsp;“Rational是个template”也就意味着上述的辅助函数通常也是个template，所以定义了Rational的头文件代码应该长这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span>  <span class="comment">//声明Rational template</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;  <span class="comment">//声明helper template</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">        <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                    <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> doMultiply(lhs, rhs);  <span class="comment">//令friend调用helper</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多编译器实际上会强迫你把所有template定义式放进头文件内，所以你或许需要在头文件内定义doMultiply。</p>
<blockquote>
<ul>
<li>当我们编写一个class template，而它所提供的“与此template相关的”函数支持“所有参数的隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>traits class与类型信息之间的妙用</title>
    <url>/2020/11/21/traits%20class%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h1 id="traits-class与类型信息之间的妙用"><a href="#traits-class与类型信息之间的妙用" class="headerlink" title="traits class与类型信息之间的妙用"></a>traits class与类型信息之间的妙用</h1><p>&emsp;&emsp;STL主要由“用以表现容器、迭代器和算法”的template构成，但也覆盖若干工具性template，其中一个名为advance，用来将某个迭代器移动某个给定距离：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来advance做了iter+=d的动作，但是只有random access（随机访问）迭代器才支持+=操作。面对其他威力不是那么强大的迭代器种类，advance必须反复执行++或–，共d次。</p>
<p>&emsp;&emsp;简单回顾一下，STL一共有5种迭代器种类，对应于它们支持的操作。Input迭代器只能向前移动，一次一步，客户只可读取（不能写）它们所指的东西，而且只能读取一次。Output迭代器情况类似，只能向前移动，一次一步，客户只可写它们所指的东西，而且只能写一次。Forward迭代器威力就要强大的多了。这种迭代器可以做前述两种分类所能做的每一件事，而且可以读或写其所指物一次以上。Bidrectional迭代器比上一个分类威力更大。它除了可以向前移动还可以向后移动。最有威力的迭代器当属Random access迭代器。这种迭代器可以执行“迭代器算术”，也就是它可以在常量时间内向前或向后跳跃任意距离，因为random access迭代器正是以内置（原始）指针为榜样，而内置指针也可被当作random access迭代器使用。vector，deque和string提供的迭代器都是这一分类。</p>
<p>&emsp;&emsp;对于这5种分类，C++标准库分别提供专属的卷标（tag struct）加以确认：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidrectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidrectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些struct之间的继承关系是有效的的is-a关系：所有的forward迭代器都是input迭代器，一次类推。很快我们就会看到这个继承关系的威力。</p>
<p>&emsp;&emsp;现在回到advance函数。我们已经知道STL迭代器有着不同的能力，实现advance的策略之一是采用“最低但最普及”的迭代器能力，以循环反复递增或递减迭代器。然而这种做法耗费线性时间。我们知道random access迭代器支持迭代器算术运算，只耗费常量时间，因此如果我们遇到这种迭代器，我们希望运用其优势。期望以这种方式实现advance：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iter is a <span class="built_in">random</span> access iterator) &#123;</span><br><span class="line">        iter += d;  <span class="comment">//针对random access迭代器使用迭代器算术运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种做法首先必须要判断iter是否为random access迭代器，也就是说需要知道类型IterT是否为random access迭代器分类。换句话说我们需要取得类型的某些信息。这也就是traits提供给你的一个技术：它们允许你在编译期间取得某些类型信息。</p>
<p>&emsp;&emsp;traits并不是C++关键字，也不是一个预先定义好的组件；它们是一种技术，也是一个C++程序员共同遵守的协议。这个技术的要求之一是，它必须在内置类型和用户自定义类型上表现一致。举个例子，如果上述advance收到的实参是一个指针（例如const char*）和一个int，上述advance仍然能够有效运作，这意味着trait技术必须也能够实施于内置类型如指针身上。</p>
<p>&emsp;&emsp;“trait必须能够实施于内置类型”意味“类型内的嵌套信息”这样的“小伎俩”无法发挥作用，因为我们无法将信息嵌套于原始指针内。因此类型的traits信息必须位于类型之外。标准技术是把它放进一个template及其一个或多个特化版本中。这样的template在标准程序库中有若干个，其中针对迭代器者被命名为iterator_traits：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>;</span>  <span class="comment">//template，用来处理迭代器分类的相关信息</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;习惯上trait总是被实现为struct，但它们却又往往被称为trait class。</p>
<p>&emsp;&emsp;iterator_traits的运作方式是，针对每一个类型IterT，在struct iterator_traits&lt;IterT&gt;内一定声明了某个typedef名为iterator_category。这个typedef用来确认IterT的迭代器分类。</p>
<p>&emsp;&emsp;iterator_traits以两个部分来实现上述运作方式。首先它要求每一个“用户自定义的迭代器类型”必须嵌套一个typedef，名为iterator_category，用来确认适当的卷标结构（tag struct）。例如deque的迭代器可随机访问，所以一个针对deque迭代器而设计的class看起来会是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; ... &gt;  <span class="comment">//略写template参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">                ...</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;list的迭代器可以双向行进，所以它们应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; ... &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">                ...</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至于iterator_traits，则只是用来响应iterator class的嵌套式typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这对于用户自定义类型倒是挺合理的，但对指针（也是一种迭代器）行不通，因为指针不可能嵌套typedef。iterator_traits的第二部分如下，专门用来对付指针。</p>
<p>&emsp;&emsp;为了支持指针迭代器，iterator_traits特别针对指针类型提供了一个偏特化版本。由于指针的行为与random access迭代器类似，所以iterator_traits为指针指定的迭代器类型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;IterT*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，你应该知道如何设计并实现一个traits class了：</p>
<ul>
<li>确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类（category）。</li>
<li>为该信息选择一个名称（例如iterator_category）。</li>
<li>提供一个template和一组特化版本（例如上述所说的iterator_traits），内含你希望支持的类型相关信息。</li>
</ul>
<p>&emsp;&emsp;好，现在有了iterator_traits（实际上是std::iterator_traits，因为它是C++标准程序库的一部分），我们可以对advance实现先前的伪码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::iterator_category)</span><br><span class="line">       == <span class="keyword">typeid</span>(<span class="built_in">std</span>::random_access_iterator_tag))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;虽然看起来挺合理的，但其实它并达不到我们的期望。首先它会导致编译问题，这个问题将在下一次文章中进行讨论。现在更加重要的问题是，IterT类型在编译期获知，所以iterator_traits&lt;IterT&gt;::iterator_category也可以在编译期间确定。但if语句却是在运行期才进行核对。为什么将可在编译期完成的事拖延到运行期才做呢？这不仅浪费时间，也造成可执行文件膨胀。</p>
<p>&emsp;&emsp;我们真正想要的是一个“条件式”（也就是可以履行if…else语句的职责）用来进行“编译期核对卷标类型”的动作。正好C++给我们提供了这个“桥梁”，那就是重载。</p>
<p>&emsp;&emsp;当你重载某个函数f，你必须详细描述出各个重载件的参数类型。当你调用f，编译器便根据传来的实参选择最适当的重载件。编译器认为“如果这个重载件最匹配传递过来的实参，就调用这个f；如果那个重载件最匹配，就调用那个f；如果第三个f最匹配，就调用第三个f”依此类推。这正是一个针对类型而发生的“编译期条件语句”。以下是这个技术的代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">std</span>::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">std</span>::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">std</span>::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Negative distance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于forward_iterator_tag继承自input_iterator_tag，所以上述doAdvance的input_iterator_tag版本也能够处理forward迭代器。这是iterator_tag struct继承关系带来的一个好处。</p>
<p>&emsp;&emsp;现在有了这些doAdvance重载版本，advance需要做的只是调用它们并额外传递一个对象，后者必须带有适当的迭代器分类。于是编译器运用重载解析机制调用适当的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    doAdvance(iter, d,</span><br><span class="line">              <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们可以总结如何使用一个traits class了：</p>
<ul>
<li>建立一组重载函数（身份像劳工）或函数模版（例如doAdvance），彼此间的差异只在于各自的traits参数。令每个函数的实现码与其接受的traits信息相对应。</li>
<li>建立一个控制函数（身份像工头）或函数模版（例如advance），它调用上述那些“劳工函数”并传递traits class所提供的信息。</li>
</ul>
<blockquote>
<ul>
<li>traits class使得“类型相关信息”在编译期可用。它们以template和“template特化”来实现。</li>
<li>整合重载技术后，traits class有可能在编译期对类型执行“if…else”测试。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>template元编程</title>
    <url>/2020/11/22/template%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="template元编程"><a href="#template元编程" class="headerlink" title="template元编程"></a>template元编程</h1><p>&emsp;&emsp;TMP（template metaprogrammming）模版元编程是编写template-base C++程序并执行于编译期的过程。所谓TMP是以C++写成、执行于C++编译器内的程序。一旦TMP程序结束执行，其输出，也就是从template具现出来的若干C++源码，便会被编译。</p>
<p>&emsp;&emsp;C++并非是为TMP而设计，TMP是被发现而不是被发明出来的。当template加入C++时TMP底层特性也就被引进了。对某些人而言唯一需要注意的是如何以熟练巧妙的方式使用TMP。</p>
<p>&emsp;&emsp;TMP有两个强大的作用。第一，它让某些事情变得更加容易。如果没有它，那些事情将是十分困难的，甚至是不可能的。第二，由于template metaprograms执行于C++编译期，因此可将工作从运行期转移至编译期。这将导致一个结果，某些错误原本通常在运行期才能侦测到，现在可在编译期找出来。另一个结果是，使用TMP的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求，然而将工作从运行期转移至编译期的另一个结果是，编译时间变长了。</p>
]]></content>
  </entry>
  <entry>
    <title>对new-handler这一技术的探讨</title>
    <url>/2020/11/23/%E5%AF%B9new-handler%E8%BF%99%E4%B8%80%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8E%A2%E8%AE%A8/</url>
    <content><![CDATA[<hr>
<h1 id="什么是new-handler？"><a href="#什么是new-handler？" class="headerlink" title="什么是new-handler？"></a>什么是new-handler？</h1><p>&emsp;&emsp;在调用operator new动作时，如果没有满足要求的内存可供分配，该动作会抛出一个异常。而在此“抛出异常”动作之前，它operator new会先调用一个客户指定的错误处理函数，也就是所谓的new-handler。（其实operator new正真做的事情稍微更加复杂些）。</p>
<a id="more"></a>

<h1 id="使用new-handler的一个简单实例"><a href="#使用new-handler的一个简单实例" class="headerlink" title="使用new-handler的一个简单实例"></a>使用new-handler的一个简单实例</h1><p>&emsp;&emsp;为了指定这个“用以处理内存不足”的函数，客户必须调用set_new_handler，这是声明于&lt;new&gt;的一个标准程序库函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span> <span class="params">()</span></span>;                      <span class="comment">//new_handler是个函数指针</span></span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//不抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> &emsp;&emsp;set_new_handler的参数是一个指针，指向operator new无法分配足够内存时该被调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要被替换）的那个new-handler函数。</p>
<p>&emsp;&emsp;你可以这样使用set_new_handler：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是当operator new无法分配足够内存时，该被调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to satisfy request for memory\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::set_new_handler(outOfMem);</span><br><span class="line">    <span class="keyword">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就本例而言，如果operator new无法为100000000分配足够空间，outOfMem就会被调用。</p>
<p>&emsp;&emsp;当operator new无法满足内存申请时，它会不断调用new-handler函数，直到找到足够内存。</p>
<h1 id="设计良好的new-handler函数必须要做的事"><a href="#设计良好的new-handler函数必须要做的事" class="headerlink" title="设计良好的new-handler函数必须要做的事"></a>设计良好的new-handler函数必须要做的事</h1><ul>
<li><strong>让更多内存可被使用</strong>。这样的策略可能会使operator new内的下一次内存分配动作成功。实现此策略的一个做法是，程序一开始执行就分配一大块内存，然后当new-handler第一次被调用，将它们释放还给程序使用。</li>
<li><strong>安排另一个new-handler</strong>。如果目前这个new-handler无法取得更多可用内存，或许它知道另外哪个new-handler有这个能力。那么，目前这个new-handler就可以安装另外那个new-handler来替换自己（只要调用set_new_handler）。下次当operator new调用new-handler，调用的将是最新安装的那个。关于new-handler有一件值得关注的事，我们可以让new-handler修改自己的行为，于是当它下次被调用，就会做某些不同的事。为了达到这个功效，做法之一就是令new-handler修改“会影响new-handler行为”的static数据、namespace数据或global数据。</li>
<li><strong>卸除new-handler</strong>。也就是将null指针传给set_new_handler。一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。</li>
<li><strong>抛出bad_alloc（或派生自bad_alloc）的异常</strong>。这样的异常不会被operator new捕捉，因此会被传播到内存索求处。</li>
<li><strong>不返回</strong>。通常调用abort或exit。</li>
</ul>
<h1 id="C-并不支持class的专属new-handler"><a href="#C-并不支持class的专属new-handler" class="headerlink" title="C++并不支持class的专属new-handler"></a>C++并不支持class的专属new-handler</h1><p>&emsp;&emsp;虽然说C++并不支持class的专属new-handler，但其实也不需要。你可以自己实现出这种行为。只需要令每一个class提供自己的set_new_handler和operator new即可。其中set_new_handler允许客户指定class专属的new-handler（就像标准的set_new_handler允许客户指定global new-handler），至于operator new则确保在分配class对象内存的过程中以class专属的new-handler替换global new-handler。</p>
<h1 id="定制专属class的set-new-handler和operator-new"><a href="#定制专属class的set-new-handler和operator-new" class="headerlink" title="定制专属class的set_new_handler和operator new"></a>定制专属class的set_new_handler和operator new</h1><h2 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h2><p>&emsp;&emsp;现在我们拥有一个Widget class，假设我们打算处理Widget class的内存分配情况。当operator new无法为一个Widget对象分配足够内存时，我们需要声明一个类型为new_handler的static成员，用以指向class Widget的new-handler，相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::new_handler <span class="title">set_new_handler</span><span class="params">(<span class="built_in">std</span>::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;static成员必须在class定义式之外被定义（除非它们是const而且是整数型），所以需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::new_handler Widget::currentHandler = <span class="number">0</span>;  <span class="comment">//初始化为null</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Widget内的set_new_handler函数会将它获得的指针存储起来，然后返回先前（在此调用之前）存储的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(<span class="built_in">std</span>::new_handler p)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::new_handler oldHandler= currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后，Widget的operator new会做以下事情：</p>
<ol>
<li>调用标准set_new_handler，告知Widget的错误处理函数。这会将Widget的new-handler安装为global new-handler。</li>
<li>调用global operator new，执行实际的内存分配。如果分配失败，global operator new会调用Widget的new-handler，因为这个函数才刚被安装为global new-handler。如果global operator new最终无法分配足够内存，会抛出一个bad_alloc异常。在此情况下Widget的operator new必须恢复原本的global new-handler，然后再传播该异常。为确保原本的new-handler总是能够被重新安装回去，Widget将global new-handler视为资源，并运用资源管理对象（例如智能指针）防止资源泄漏。</li>
<li>如果global operator new能够分配足够一个Widget对象所用的内存，Widget的operator new会返回一个指针，指向分配所得的内存空间。Widget析构函数会管理global new-handler，它会自动将Widget的operator new被调用前的那个global new-handler恢复回来。</li>
</ol>
<p>&emsp;&emsp;下面用C++作为实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolder</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(<span class="built_in">std</span>::new_handler nh)</span> : <span class="title">handler</span><span class="params">(nh)</span> </span>&#123;&#125;</span><br><span class="line">        ~NewHandlerHolder() &#123;</span><br><span class="line">            <span class="built_in">std</span>::set_new_handler(handler);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::new_handler handler;</span><br><span class="line">        NewHandlerHolder(<span class="keyword">const</span> NewHandlerHolder&amp;);  <span class="comment">//阻止copying	</span></span><br><span class="line">        NewHandler&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这就使得Widget的operator new的实现相当简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(<span class="built_in">std</span>::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Widget的客户应该类似这样使用其new-handler：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;  <span class="comment">//函数声明。此函数在Widget对象分配失败时被调用。</span></span><br><span class="line"></span><br><span class="line">Widget::set_new_handler(outOfMem);  <span class="comment">//设定outOfMem为Widget的new-handler函数。</span></span><br><span class="line"></span><br><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;  <span class="comment">//如果内存分配失败，调用outOfMem。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;  <span class="comment">//如果内存分配失败，调用global new-handler函数（如果有的话）。</span></span><br><span class="line"></span><br><span class="line">Widget::set_new_handler(<span class="number">0</span>);  <span class="comment">//设定Widget专属的new-handler函数为null。</span></span><br><span class="line"></span><br><span class="line">Widget* pw2 = <span class="keyword">new</span> Widget;  <span class="comment">//如果内存分配失败，立刻抛出异常（class Widget并没有专属的new-handler函数）。</span></span><br></pre></td></tr></table></figure>

<h2 id="template版本"><a href="#template版本" class="headerlink" title="template版本"></a>template版本</h2><p>&emsp;&emsp;现在让我们用template方式来实现上述代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerSupport</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::new_handler <span class="title">set_new_handler</span><span class="params">(<span class="built_in">std</span>::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alooc)</span></span>;</span><br><span class="line">        ...  <span class="comment">//其他的operator版本</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::new_handler</span><br><span class="line">NewHandlerSuppport&lt;T&gt;::set_new_handler(<span class="built_in">std</span>::new_handler p) <span class="keyword">throw</span>() &#123;</span><br><span class="line">    <span class="built_in">std</span>::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(<span class="built_in">std</span>::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下将每一个currentHandler初始化为null</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有了这个class template，为Widget添加set_new_handler支持能力就轻而易举了：只要令Widget继承自NewHandlerSupport&lt;Widget&gt;就可以了，像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line">    ...  <span class="comment">//和之前一样，但不必声明set_new_handler或operator new</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="operator-new的异常处理"><a href="#operator-new的异常处理" class="headerlink" title="operator new的异常处理"></a>operator new的异常处理</h1><p>&emsp;&emsp;直到1993年，C++都还要求operator new必须在无法分配足够内存时返回null。新一代的operator new则应该抛出bad_alloc异常，但很多C++程序是在编译器开始支持新修改规范前写出来的。C++标准委员会不想抛弃那些“侦测null”的族群，于是提供了另一形式的operator new，负责支持传统的“分配失败便返回null”行为。这个形式被称为“nothrow”形式——某种程度上是因为他们在new的使用场合用了nothrow对象（定义于头文件&lt;new&gt;）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;  <span class="comment">//如果分配失败，抛出bad_alloc</span></span><br><span class="line"><span class="keyword">if</span>(pw1 == <span class="number">0</span>) ...  <span class="comment">//这个结果一定为false</span></span><br><span class="line">Widget* pw2 = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) Widget;  <span class="comment">//如果分配Widget失败，返回0</span></span><br><span class="line"><span class="keyword">if</span>(pw2 == <span class="number">0</span>) ...  <span class="comment">//这个结果可能为true</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;nothrow new对异常的强制性保证并不会像你所想的那样如此的可靠。要知道，表达式“new (std::nothrow) Widget”发生两件事，第一，nothrow版的operator new被调用，用以分配足够内存给Widget对象。如果分配失败便会返回null指针。如果分配成功，接下来Widget构造函数会被调用，而这之后之前nothrow new所做的保证便一去不复返了，因为Widget构造函数可以做它想做的任何事。它有可能又new一些内存，而没人可以强迫它再次使用nothrow new。因此虽然“new (std::nothrow) Widget”调用的operator new并不抛出异常，但Widget构造函数却可能会。</p>
<p>&emsp;&emsp;结论就是：使用nothrow new只能保证operator new不抛出异常，不保证像“new (nothrow) Widget”这样的表达式绝不导致异常。因此你其实没有使用nothrow new的必要。</p>
<p>&emsp;&emsp;无论使用正常（会抛出异常）的new，还是其或多或少有点发育不良等nothrow兄弟，重要的是你需要了解new-handler的行为，因为两种形式都使用它。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><blockquote>
<ul>
<li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>nothrow new是一个有局限性的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于替换new和delete的技术</title>
    <url>/2020/11/27/%E5%85%B3%E4%BA%8E%E6%9B%BF%E6%8D%A2new%E5%92%8Cdelete%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<hr>
<h1 id="想要替换operator-new或operator-delete的原因"><a href="#想要替换operator-new或operator-delete的原因" class="headerlink" title="想要替换operator new或operator delete的原因"></a>想要替换operator new或operator delete的原因</h1><p>&emsp;&emsp;为什么会有人想要替换编译器提供的operator new或operator delete呢？下面是三个最常见的理由：</p>
<a id="more"></a>

<ul>
<li><p><strong>用来检测运用上的错误</strong>。如果将“new所得内存”delete掉却不幸失败，这就会导致内存泄漏。如果在“new所得内存”身上多次delete则会导致不确定行为。如果operator new持有一串动态分配所得地址，而operator delete将地址从中移走，倒是很容易检测出上述错误用法。此外各式各样的编程错误可能导致数据“overrun”（写入点在分配区块尾端之后）或“underruns”（写入点在分配区块起点之前）。如果我们自定定义一个operator new，使得可以超额分配内存，以额外空间（位于客户所得区块之前或之后）放置特定的byte patterns（即签名，signatures）。operator delete便得以检查上述签名是否原封不动，若否就表示在分配区的某个生命时间点发生了overrun或underrun，这时候operator delete可以志记（log）所发生的事情以及那个罪魁祸首的指针。</p>
</li>
<li><p><strong>为了强化效能</strong>。编译器所带的operator new和operator delete主要用于一般目的，它们不但可被长时间执行的程序（例如网页服务器，web serves）接受，也可被执行时间少于一秒的程序接受。它们必须处理一系列需求，包括大块内存、小块内存、大小混合型内存。它们必须接纳各种分配形态，范围从程序存活期间的少量区块动态分配，到大数量短命对象的持续分配和归还。此外还有一个问题也是它们需要考虑的——内存碎片：即使有时候内存空间总量足够但由于它们分散为许多小区块的自由内存，这也就导致了程序无法满足大区块内存的要求。</p>
<p>&emsp;&emsp;通常我们可以发现，定制版的operator new和operator delete性能胜过缺省版本。也就是说它们更快，有时候甚至会快很多，而且它们需要的内存比较少，最高可省50%。对某些应用程序而言，将旧有的（编译器自带的）new和delete替换为定制版本，是获得重大效能提升的办法之一。</p>
</li>
<li><p><strong>为了收集使用上的统计数据</strong>。在你开始定制new和delete之前，应该先弄清楚你的软件如何使用其动态内存。分配区块的大小分布如何？寿命分布如何？它们倾向于以FIFO（先进先出）次序或LIFO（后进先出）次序或随机次序来分配和归还？它们的运用形态是否随时间改变，也就是说你的软件在不同的执行阶段有不同的分配／归还形态吗？任何时刻所使用的最大动态分配量（高水位）是多少？自行定义operator new和operator delete使我们得以轻松收集到这些信息。</p>
</li>
</ul>
<h1 id="定制我们自己的operator-new所需要注意的问题"><a href="#定制我们自己的operator-new所需要注意的问题" class="headerlink" title="定制我们自己的operator new所需要注意的问题"></a>定制我们自己的operator new所需要注意的问题</h1><p>&emsp;&emsp;理论上，写一个定制型operator new十分简单。举个例子，下面是一个global operator new，可以帮助检测“overrun”或“underrun”。其中还有不少小错误，稍后我们会完善它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> signature = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Byte;</span><br><span class="line"><span class="comment">//这段代码还有若干小错误，详下。</span></span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>（<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>) <span class="keyword">throw</span>(<span class="built_in">std</span>::bad_alloc) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">size_t</span> realSize = <span class="built_in">size</span> + <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);  <span class="comment">//增加大小，使能够塞入两个signatures。</span></span><br><span class="line">    <span class="keyword">void</span>* pMem = <span class="built_in">malloc</span>(realSize);  <span class="comment">//调用malloc取得内存。</span></span><br><span class="line">    <span class="keyword">if</span>(!pMem) <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将signature写入内存的最前端和最后端。</span></span><br><span class="line">    *(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pMem)) = signature;</span><br><span class="line">    *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem)</span><br><span class="line">        + realSize - <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) = signature;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回指针，指向位于第一个signature之后的内存位置。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述operator new的缺点主要在于它没有履行身为这个特殊函数所应该“坚持C++规矩”的职责。举个例子operator new都应该内含一个循环，反复调用某个new-handler函数，这里却没有。另外还有一个比较微妙的主题：齐位（alignment）。</p>
<p>&emsp;&emsp;许多计算机体系结构要求特定的类型必须放在特定的内存地址上。例如它可能会要求指针的地址必须是4倍数或double的地址必须是8倍数。如果没有遵循这个约束条件，可能导致运行期硬件异常。有些体系结构比较慈悲，不需要我们严格遵守上述规则，当然，如果满足齐位条件，程序便可以获得更佳的效率。例如Intel x86体系结构上的double可被对齐于任何byte边界，但如果它是8-byte齐位，其访问速度会快许多。</p>
<p>&emsp;&emsp;C++要求所有operator new返回的指针都有适当的对齐（取决于数据类型）。malloc就是在这样的要求下工作，所以令operator new返回一个取得自malloc的指针是安全的。然而上述operator new中我并未返回一个取得自malloc的指针，而是返回一个得自malloc且偏移一个int大小的指针。没人能够保证它的安全！如果客户端调用operator new希望获取一个double所需的内存，而我们在一部“int为4byte且double必须为8byte齐位”的机器上跑，我们可能会获得一个没有适当齐位的指针。这可能会造成程序崩溃或执行速度变慢。不论哪种情况都不是我们所愿意见到的。</p>
<p>&emsp;&emsp;其实很多时候定制我们需要的高效的new和delete并非是必要的。许多平台上面已有商业产品可以替代编译器子自带的内存管理器。如果需要它们来为你的程序提高技能和改善效能，你唯一需要做的就是重新连接（relink）。当然啦，首先你得花点钱买下它们。</p>
<p>&emsp;&emsp;另一个选择是open source社区里面的内存管理器。它们在许多平台上面都可以用，你可以下载并试试。很多时候我们编写的内存管理器可能会遗漏可移植性和齐位考虑、线程安全性等等令人厌恶的麻烦细节。真正配得上程序库这个称号的“程序库”，必然十分的健全。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><blockquote>
<ul>
<li>有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义new和delete的规则</title>
    <url>/2020/11/30/%E8%87%AA%E5%AE%9A%E4%B9%89new%E5%92%8Cdelete%E7%9A%84%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<hr>
<h1 id="C-关于new的奇怪规定"><a href="#C-关于new的奇怪规定" class="headerlink" title="C++关于new的奇怪规定"></a>C++关于new的奇怪规定</h1><p>&emsp;&emsp;在new的规定上面，C++有一点非常奇怪，即使客户要求0bytes，operator new也得返回一个合法指针。这种看似诡异的行为其实是为了简化C++这个语言联邦中的其他“语言成分”。以下是个non-memer operator new伪码：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>) &#123;  <span class="comment">//处理0-byte申请</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1</span>;    <span class="comment">//将它视为1-byte申请</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        尝试分配<span class="built_in">size</span> bytes;</span><br><span class="line">        <span class="keyword">if</span>(分配成功)</span><br><span class="line">        <span class="keyword">return</span> (一个指针，指向分配得来的内存);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//分配失败；找出目前的new-handler函数</span></span><br><span class="line">        new_handler globalHandler = set_new_handler(<span class="number">0</span>);</span><br><span class="line">        set_new_handler(globalHandler);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(globalHandler) (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你可能会觉得这份代码有点奇怪，它将new-handler函数指针设为null而后又立刻恢复原样。但这是没有办法的事情，因为我们无法直接取得new-handler函数指针，所以必须调用set_new_handler找出它来。</p>
<h1 id="operator-new无限循环内所做的事情"><a href="#operator-new无限循环内所做的事情" class="headerlink" title="operator new无限循环内所做的事情"></a>operator new无限循环内所做的事情</h1><p>&emsp;&emsp;上述伪码内有一个无限循环。退出此循环的唯一办法是：内存被成功分配或new-handler函数使用到了“<a href="/2020/11/23/%E5%AF%B9new-handler%E8%BF%99%E4%B8%80%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8E%A2%E8%AE%A8/" title="对new-handler这一技术的探讨">对new-handler这一技术的探讨</a>”内所谈及到的技术：让更多内存可用、安装另一个new-handler、卸除new-handler、抛出bad_alloc异常（或其派生物），或是承认失败而直接return。</p>
<h1 id="operator-new／delete成员函数会被derived-class继承"><a href="#operator-new／delete成员函数会被derived-class继承" class="headerlink" title="operator new／delete成员函数会被derived class继承"></a>operator new／delete成员函数会被derived class继承</h1><p>&emsp;&emsp;operator new成员函数会被derived class继承，这会导致某些有趣的复杂度。定制型内存管理器是为针对某特定class的对象内存分配行为提供最佳的优化，而不是为了该class的任何derived class。也就是说，针对class X而设计的operator new，其行为只是为大小刚好为sizeof(X)的对象而设计的。然而一旦被继承下去，有可能base class的operator new被调用用以分配derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; ... &#125;;  <span class="comment">//假设Derived未声明operator new</span></span><br><span class="line">Derived* p = <span class="keyword">new</span> Derived;             <span class="comment">//这里调用的是Base::operator new</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果Base class专属的operator new并非是用来为Derived class服务的，那么处理这种情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准operator new，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> != <span class="keyword">sizeof</span>(Base))          <span class="comment">//如果大小错误，</span></span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);  <span class="comment">//让标准的operator new来处理</span></span><br><span class="line">    ...                               <span class="comment">//否则在这里处理。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这里，我们将“检验size等于0的情况”与“size与sizeof(Base)的检测”融合在一起了。C++认为所有的非附属（独立式）对象必须有非零大小（见“<a href="/2020/11/12/%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/" title="明智而审慎地使用private继承">明智而审慎地使用private继承</a>”。因此sizeof(Base)无论如何不能为零，所以如果size是0，这份申请会被转交到::operator new手上，后者必须以某种合理的方式来处理这种情况。</p>
<h1 id="C-关于delete的规定"><a href="#C-关于delete的规定" class="headerlink" title="C++关于delete的规定"></a>C++关于delete的规定</h1><p>&emsp;&emsp;operator new情况比new要简单些，你唯一需要记住的就是C++保证“删除null指针永远安全”，所以你必须兑现这份承诺。下面是non-member operator delete的伪码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//如果被删除的是个null指针，</span></span><br><span class="line">                                <span class="comment">//那就什么都不做。</span></span><br><span class="line">    现在，归还rawMemory所指的内存;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个函数的member版本也很简单，只需要多加一个动作检查删除数量。万一你的class专属的operator new将大小有误的分配行为转交::operator new执行，你也必须将大小有误的删除行为转交::operator delete执行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//检查null指针。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> != <span class="keyword">sizeof</span>(Base)) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    现在，归还rawMemory所指的内存;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0bytes申请。class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
<li>operator delete应该在收到null指针时不做任何事。class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>placement new与placement delete一定要成双成对</title>
    <url>/2020/12/02/placement%20new%E4%B8%8Eplacement%20delete%E4%B8%80%E5%AE%9A%E8%A6%81%E6%88%90%E5%8F%8C%E6%88%90%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="运行期系统对于正常形式new／delete所做出的决策"><a href="#运行期系统对于正常形式new／delete所做出的决策" class="headerlink" title="运行期系统对于正常形式new／delete所做出的决策"></a>运行期系统对于正常形式new／delete所做出的决策</h1><p>&emsp;&emsp;当你写一个像这样的new表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;共有两个函数被调用：一个是用以分配内存的operator new，一个是Widget的default构造函数。</p>
<p>&emsp;&emsp;假设其中第一个函数调用成功，第二个函数抛出异常。那么这种情况下，第一步内存分配的空间必须取消并恢复原状，否则会造成内存泄漏。但是由于Widget构造函数抛出异常，pw尚未被赋值，那么客户手上自然就没有指针指向应该被归还的内存。</p>
<a id="more"></a>

<p>&emsp;&emsp;C++运行期系统会调用第一步所调用的operator new的相应operator delete版本，前提当然是它必须知道哪一个（因为可能有多个）operator delete该被调用。在上述情况下，我们面对的是拥有正常签名式的new和delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//global作用域中的正常签名式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//class作用域中典型的签名式</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因此，当你使用正常形式的new和delete，运行期系统很自然地可以找出那个“知道如何取消new所作所为并恢复原状”的delete。</p>
<h1 id="非正常形式的new浮现出的问题"><a href="#非正常形式的new浮现出的问题" class="headerlink" title="非正常形式的new浮现出的问题"></a>非正常形式的new浮现出的问题</h1><p>&emsp;&emsp;然而，当你开始声明非正常形式的operator new，也就是带有附加参数的operator new，“究竟哪一个delete伴随这个new”的问题便浮现了。</p>
<p>&emsp;&emsp;举个例子，假设你写了一个class专属的operator new，要求接受一个ostream，用来志记（log）相关分配信息，同时又写了一个正常形式的class专属operator delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="built_in">std</span>::ostream&amp; logStream)</span> </span></span><br><span class="line"><span class="function">            <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;  <span class="comment">//非正常形式的new</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//正常的class专属delete</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个设计有点问题，但现在我们可以先绕开这个问题。简要的讨论以下概念。</p>
<p>&emsp;&emsp;什么是placement new：如果operator new接受的参数除了一定会有的那个size_t之外还有其他的，这个便是所谓的placement new。因此上述的operator new是一个placement版本。在众多的placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”，那样的operator new长相如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个版本的new已被纳入C++标准程序库，你只要#include &lt;new&gt;就可以使用它。这个new的用途之一是负责在vector的未使用空间上创建对象。它同时也是最早的placement new版本。实际上它正是这个函数的命名依据：一个特定位置上的new。</p>
]]></content>
  </entry>
</search>
