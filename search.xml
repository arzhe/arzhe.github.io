<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>0.1+0.2?</title>
    <url>/2021/03/20/0.1+0.2?/</url>
    <content><![CDATA[<hr>
<h1 id="0-1-0-2-0-30000000000000004"><a href="#0-1-0-2-0-30000000000000004" class="headerlink" title="0.1+0.2=0.30000000000000004?"></a>0.1+0.2=0.30000000000000004?</h1><p>&emsp;&emsp;$0.1+0.2=0.30000000000000004$?难道不是0.3吗，为什么结果是这样的？你或许会觉得不可思议，但是在计算机的世界里，这是完全正确的。计算机只能存储整数，因此对于小数而言，它需要有别于存储整数的方式来对其进行处理，这也就是为什么上述计算有违我们的常识。</p>
<p>&emsp;&emsp;那么到底是为什么呢？计算机为何要这样进行这样的操作呢？这其实一直都是一个经典的问题，甚至有一个网站的域名就叫做0.30000000000000004.com，就是为了解释这个问题。</p>
<a id="more"></a>

<p>&emsp;&emsp;在这个网站中，列举了各种编程语言中计算$0.1+0.2$的结果，以下是摘取的部分示例：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/20210320-1.png" alt="示例1"></p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/20210320-2.png" alt="实例2"></p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/20210320-3.png" alt="实例3"></p>
<p>可以看到，无论是何种语言，最后的计算结果都是出奇的一致，都是0.30000000000000004。</p>
<p>&emsp;&emsp;现在让我们实践一下，打开我们的浏览器的控制台（按F12），进行上述计算，我们会看到：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/20210320-4.png" alt="实例4"></p>
<p>正如之前的实例一样，这里我们的结果也是0.30000000000000004。其实浏览器的控制台进行计算时，用到的语言就是JavaScript。所以，这个现象与具体的编程语言并无关系，主要的问题还是计算机中到底是如何表示小数的以及如何进行小数运算的。</p>
<h1 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h1><h2 id="计算机中数据的存储形式"><a href="#计算机中数据的存储形式" class="headerlink" title="计算机中数据的存储形式"></a>计算机中数据的存储形式</h2><p>&emsp;&emsp;我们知道计算机中只存在0和1，也只认识0和1，并且只接受二进制，无论外界传入什么样的信息，都需要转换为二进制，之后再进行相应的处理。在之前的一篇博客中，我介绍了计算机如何进行加减法以及对于正负数的处理方式，见“<a href="/2021/03/12/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E8%AF%A6%E8%A7%A3/" title="原码、补码、反码详解">原码、补码、反码详解</a>”。</p>
<p>&emsp;&emsp;整数包括正整数、负整数以及零。在计算机中存储的整数则分为有符号整数和无符号整数，而计算机存储整数的方式是补码。对于无符号整数而言， 采用的编码方式就是其原码；对于有符号整数来说，补码就是其存储形式。</p>
<h2 id="二进制小数的转换"><a href="#二进制小数的转换" class="headerlink" title="二进制小数的转换"></a>二进制小数的转换</h2><p>&emsp;&emsp;相信我们都对十进制整数转换为二进制整数十分的熟悉。那么，十进制小数呢？如何将其转换为二进制小数呢？具体做法是：用2乘十进制小数，可以得到积，再将积的整数部分取出，再用2乘余下的小数部分，以此循环，直到积中的小数部分为0，此时0或1为二进制的最后一位。示例如下：</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>整数部分</th>
</tr>
</thead>
<tbody><tr>
<td>0.75 * 2 = 1.5​</td>
<td>1</td>
</tr>
<tr>
<td>0.5 * 2 = 1.0</td>
<td>1</td>
</tr>
</tbody></table>
<p>所以，十进制的0.75的二进制小数就是0.11。</p>
<p>&emsp;&emsp;但是，并不是所有的十进制小数都可以完美转换为上述结果的，比如0.1。你能算出它对应的二进制小数吗？</p>
<table>
<thead>
<tr>
<th>运算</th>
<th>整数部分</th>
</tr>
</thead>
<tbody><tr>
<td>0.1 * 2 = 0.2</td>
<td>0</td>
</tr>
<tr>
<td>0.2 * 2 = 0.4</td>
<td>0</td>
</tr>
<tr>
<td>0.4 * 2 = 0.8</td>
<td>0</td>
</tr>
<tr>
<td>0.8 * 2 = 1.6</td>
<td>1</td>
</tr>
<tr>
<td>0.6 * 2 = 1.2</td>
<td>1</td>
</tr>
<tr>
<td>0.2 * 2 = 0.4</td>
<td>0</td>
</tr>
<tr>
<td>….</td>
<td>….</td>
</tr>
</tbody></table>
<p>没错，我们发现0.1的二进制表示中出现了无限循环的情况。这种情况下，计算机就没有办法用二进制精确的表示0.1了。也就是说像0.1这样的数字，我们是没有办法将它转换为一个确定的二进制数的。</p>
<p>&emsp;&emsp;那么现代计算机是如何解决这个问题的呢？答案很简单，既然没有办法精确表示的话，那就用近似值表示。这就不得不提到IEEE 754了。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><p>&emsp;&emsp;为了解决部分小数无法精确表示的问题，IEEE 754规范由此诞生。</p>
<p>&emsp;&emsp;IEEE二进制浮点数算术标准（IEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，被许多CPU和浮点运算器所采用。</p>
<p>&emsp;&emsp;浮点数和小数并不是完全一样的，计算机中小数的表示方法，其实有定点和浮点两种。但是由于在位数相同的情况下，定点数的表示范围要比浮点数小。所以在计算机领域中，通常采用浮点数来表示实数的近似值。</p>
<p>&emsp;&emsp;IEEE 754规定来四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43位以上，很少使用）与延伸双精确度（79位以上，通常以80位实现）。其中最常用的就是32位单精度浮点数和64位双精度浮点数，这也是最为我们程序员所熟知的两种数据类型。</p>
<p>&emsp;&emsp;IEEE 754并没有解决小数无法精确表示的问题，只是提出了一种使用近似值表示小数的方式，并且引入了精度的概念。</p>
<h2 id="浮点数如何存储？"><a href="#浮点数如何存储？" class="headerlink" title="浮点数如何存储？"></a>浮点数如何存储？</h2><p>&emsp;&emsp;浮点数是一串0和1构成的位序列(bit sequence)，从逻辑上用三元组{S,E,M}表示一个数N,如下图所示：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/20210320-5.png" alt="浮点数存储形式"></p>
<ul>
<li>S(sign)表示N的符号位。对应值s满足：n&gt;0时，s=0; n≤0时，s=1。</li>
<li>E(exponent)表示N的指数位，位于S和M之间的若干位。对应值e值也可正可负。</li>
<li>M(mantissa)表示N的尾数位，恰好，它位于N末尾。M也叫有效数字位（significand）、系数位（coefficient）, 甚至被称作”小数”。</li>
</ul>
<p>浮点数N的实际值的计算方法：<br>$$<br>N = (-1)^s * M * 2^E<br>$$<br>上面这个公式看起来也许有点复杂，但是，本博客不深究其原理。其实，大家也不用过于纠结这个公式，只需要我们记住的是，对于单精度浮点数，最多只能用32位字符表示一个数字；对于双精度浮点数，最多只能用64位字符表示一个数字。而对于那些无限循环的二进制数来说，计算机采用浮点数的方式保留了一定的有效数字，那么这个值只能是近似值，不可能是真实值。</p>
<p>&emsp;&emsp;至于一个数对应的IEEE 754浮点数应该如何计算，不是本博客的重点，这里就不再赘述了，过程还是比较复杂的，需要进行对阶、尾数求和、规格化、舍入以及溢出判断等。但是这些其实不需要了解的太详细，我们只需要知道，小数在计算机中的表示是近似数，并不是真实值。根据精度不同，近似程度也有所不同。</p>
<h2 id="中庸之道"><a href="#中庸之道" class="headerlink" title="中庸之道"></a>中庸之道</h2><p>&emsp;&emsp;为了避免计算机在进行浮点数运算时出现的精度丢失，尽量不使用float或者double，尤其是金融领域的运算，比如Java中使用BigDecimal来进行精确运算。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>C++有关时间的操作</title>
    <url>/2021/11/19/C++%E6%9C%89%E5%85%B3%E6%97%B6%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;在<code>&lt;ctime&gt;</code>或<code>&lt;time.h&gt;</code>头文件中，包含了用于获取和操作日期和时间信息的函数的各类定义。其经常用于日志的格式化输出。本文将系统全面的介绍上述各类函数。以下是函数，宏以及类型的概览：</p>
<a id="more"></a>

<h1 id="指引"><a href="#指引" class="headerlink" title="指引"></a>指引</h1><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ul>
<li>clock：<a href="#clock">clock program</a></li>
<li>difftime：<a href="#difftime">返回两个时间点之差</a></li>
<li>time：<a href="#time">获取当前时间</a></li>
<li>gettimeofday：<a href="#gettimeofday">获取当前时间</a></li>
<li>clock_gettime：<a href="#clock_gettime">获取当前时间</a></li>
</ul>
<h2 id="Convertion"><a href="#Convertion" class="headerlink" title="Convertion"></a>Convertion</h2><ul>
<li>mktime：<a href="#mktime">将结构体tm转换为time_t类型</a></li>
<li>asctime：<a href="#asctime">将结构体tm转换为字符串</a></li>
<li>ctime：<a href="#ctime">将time_t类型的值转换为字符串</a></li>
<li>gmtime：<a href="#gmtime">将time_t类型的值转换为UTC的tm类型的值</a></li>
<li>gmtime_r：<a href="#gmtime_r">将time_t类型的值转换为UTC的tm类型的值且线程安全</a></li>
<li>localtime：<a href="#localtime">将time_t类型的值转换为local的tm类型的值</a></li>
<li>strftime：<a href="#strftime">将时间格式化为字符串</a></li>
</ul>
<h2 id="Macro-constants"><a href="#Macro-constants" class="headerlink" title="Macro constants"></a>Macro constants</h2><ul>
<li>CLOCKS_PER_SEC：<a href="#CLOCKS_PER_SEC">时钟每秒摆动次数</a></li>
</ul>
<h2 id="types"><a href="#types" class="headerlink" title="types"></a>types</h2><ul>
<li>clock_t：<a href="#clock_t">时钟类型</a></li>
<li>time_t：<a href="#time_t">时间类型</a></li>
<li>struct tm：<a href="#tm">时间结构体</a></li>
</ul>
<h1 id="clock"><a href="#clock" class="headerlink" title="clock"></a><span id="clock">clock</span></h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">clock</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;返回程序消耗的处理器时间。返回的值以时钟的摆动（滴答）次数表示，它是系统指定长度的常量时间单位（与每秒的<code>CLOCK_PER_SEC</code>时钟滴答次数有关）。</p>
<p>&emsp;&emsp;在不同的系统中，时钟参考的时间是不同的，但是它与程序的执行有关（通常是它的启动）。为了计算程序实际的处理时间，时钟返回值应该与之前调用的同一个函数返回的值进行比较。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>&emsp;&emsp;none</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>&emsp;&emsp;从一个epoch开始，经过的时钟摆动次数，该epoch与特定程序的执行相关。</p>
<p>&emsp;&emsp;如果失败了，则返回-1。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  // clock_t, clock, CLOCKS_PER_SEC</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">... <span class="comment">// do something.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> t;</span><br><span class="line">    t = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"starting ...\n"</span>);</span><br><span class="line">    DoSomething();</span><br><span class="line">    t = clock() - t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"It took me %d clicks (%f seconds).\n"</span>, </span><br><span class="line">           t, (<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(t)) / CLOCKS_PER_SEC);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>&emsp;&emsp;并发地调用这个函数是安全的，不会导致数据竞争。</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>&emsp;&emsp;保证不会抛出异常。</p>
<h1 id="difftime"><a href="#difftime" class="headerlink" title="difftime"></a><span id="difftime">difftime</span></h1><h2 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span><span class="params">(<span class="keyword">time_t</span> <span class="built_in">end</span>, <span class="keyword">time_t</span> <span class="built_in">begin</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;计算两个时间之差。</p>
<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><ul>
<li>end：计算时间间隔长度的上限者</li>
<li>begin：计算时间间隔长度的下限者，如果end小于begin，则返回负值。</li>
</ul>
<h2 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h2><p>&emsp;&emsp;<code>(end - begin)</code>的结果。</p>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  // time_t, struct tm, difftime, time, mktime</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">new_year</span>;</span></span><br><span class="line">    <span class="keyword">double</span> seconds;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// get current time, same as: now = time(NULL).</span></span><br><span class="line">    time(&amp;now);</span><br><span class="line">    </span><br><span class="line">    new_year = *localtime(&amp;now);</span><br><span class="line">    new_year.tm_mon = <span class="number">0</span></span><br><span class="line">    new_year.tm_mday = <span class="number">1</span>;</span><br><span class="line">    new_year.tm_hour = <span class="number">0</span>;</span><br><span class="line">    new_year.tm_min = <span class="number">0</span>;</span><br><span class="line">    new_year.tm_sec = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    seconds = difftime(now, mktime(&amp;new_year));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.f seconds since new year in the current timezone.\n"</span>, seconds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据竞争-1"><a href="#数据竞争-1" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>&emsp;&emsp;并发地调用这个函数是安全的，不会导致数据竞争。</p>
<h2 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h2><p>&emsp;&emsp;保证不会抛出异常。</p>
<h1 id="time"><a href="#time" class="headerlink" title="time"></a><span id="time">time</span></h1><h2 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span>* timer)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;获取当前日历时间作为time_t类型的值。</p>
<p>&emsp;&emsp;返回的值通常表示从1970年1月1日00:00小时（即当前的unix时间戳）开始的秒数。由于库可能使用不同的时间表示方式，因此，可移植程序不应直接使用该函数返回的值，而应始终依赖对标准库的其他元素的调用，将它们转换为可移植类型（如localtime、gmtime和difftime）。</p>
<h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><ul>
<li>timer：类型为time_t的对象的指针，其中存储时间值。该参数也可以是空指针（默认参数），在这种情况下，函数仍然返回一个time_t类型的值。</li>
</ul>
<h2 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h2><p>&emsp;&emsp;返回当前日历时间作为time_t类型的值。</p>
<h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  // time_t, struct tm, difftime, time, mktime</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> timer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">time_info</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span> seconds;</span><br><span class="line">    </span><br><span class="line">    time_info.year = <span class="number">100</span>;</span><br><span class="line">    time_info.mon = <span class="number">0</span>;</span><br><span class="line">    time_info.mday = <span class="number">1</span>;</span><br><span class="line">    time_info.hour = <span class="number">0</span>;</span><br><span class="line">    time_info.<span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line">    time_info.sec = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    time(&amp;timer);</span><br><span class="line">    seconds = difftime(timer, mktime(&amp;time_info));</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.f seconds since January 1, 2000 in the current timezone"</span>, seconds);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据竞争-2"><a href="#数据竞争-2" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>&emsp;&emsp;计时器所指向的对象被修改（如果不为空）。</p>
<h2 id="异常-2"><a href="#异常-2" class="headerlink" title="异常"></a>异常</h2><p>&emsp;&emsp;保证不会抛出异常。</p>
<h1 id="gettimeofday"><a href="#gettimeofday" class="headerlink" title="gettimeofday"></a><span id="gettimeofday">gettimeofday</span></h1><h2 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gettimeofday</span><span class="params">(struct timeval* tv, struct timezone* tz)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;获取当前时间作为结构体timeval的值，即会把当前时间由tv所指的结构体返回，当地时区的信息则放在tz所指的结构体中。</p>
<h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><ul>
<li>struct timeval*：指向struct timeval的指针，其指向的结构体结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">time_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec; <span class="comment">// 秒，1</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;  <span class="comment">// 微秒，10*6</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其更为精确的结构体为</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec; <span class="comment">// 秒，1</span></span><br><span class="line">    <span class="keyword">long</span> tv_nsec;  <span class="comment">// 纳秒，10*9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>struct timezone*：指向struct timezone的指针，其指向的结构体结构如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tz_minuteswest;</span><br><span class="line">    <span class="keyword">int</span> tz_dsttime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该结构体一般用于time的函数中都置于NULL。</span></span><br></pre></td></tr></table></figure>

<p>#<span id="clock_gettime">clock_gettime</span></p>
<h2 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clock_gettime</span><span class="params">(<span class="keyword">clockid_t</span> clk_id, struct timespec* tp)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;获取当前时间作为结构体timesepc的值，即会把当前时间由tp所指的结构体返回，该函数比<code>gettimeofday</code>更为精确，因为<code>struct timesepc</code>是纳秒级别的，而<code>struct timeval</code>是微秒级别的。</p>
<h2 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h2><ul>
<li>clockid_t：用于指定计时时钟的类型，一般有以下几种类型：<ul>
<li>CLOCK_REALTIME：系统实时时间，随系统实时时间而改变。</li>
<li>CLOCK_MONOTONIC：从系统启动这一刻起开始计时，不受系统时间被用户改变的影响。</li>
<li>CLOCK_PROCESS_CPUTIME_ID：本进程到当前代码系统CPU所花费的时间。</li>
<li>CLOCK_THREAD_CPUTIME_ID：本线程到当前代码系统CPU所花费的时间。</li>
</ul>
</li>
<li>struct timespec*：指向结构体timesepc的指针。比结构体timeval更为精确。</li>
</ul>
<h1 id="mktime"><a href="#mktime" class="headerlink" title="mktime"></a><span id="mktime">mktime</span></h1><h2 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">mktime</span><span class="params">(struct tm* time_ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-5"><a href="#说明-5" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;将结构体tm转换为time_t类型。返回时间类型time_t的值，该值表示由timeptr指向的结构体tm所描述的本地时间（可修改）。</p>
<p>&emsp;&emsp;该函数执行的操作与<code>localtime</code>相反。</p>
<h2 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h2><ul>
<li>time_ptr：指向结构体tm的指针，该结构包含日历时间的各个组件。</li>
</ul>
<h2 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h2><p>&emsp;&emsp;时间time_t的值，如果日历时间不能表示，则返回-1值。</p>
<h2 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  // time_t, struct tm, time, mktime</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> raw_time;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">time_info</span>;</span></span><br><span class="line">    <span class="keyword">int</span> year, month, day;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* weekday[] = &#123; <span class="string">"Sunday"</span>, <span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>,</span><br><span class="line">                              <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>,</span><br><span class="line">                              <span class="string">"Friday"</span>, <span class="string">"Saturday"</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter year: "</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;year);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter month: "</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;month);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter day: "</span>); fflush(<span class="built_in">stdout</span>); <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;day);</span><br><span class="line">  </span><br><span class="line">    time(&amp;raw_time);</span><br><span class="line">    time_info = localtime(&amp;raw_time);</span><br><span class="line">    time_info-&gt;tm_year = year - <span class="number">1900</span>;</span><br><span class="line">    time_info-&gt;tm_mon = month - <span class="number">1</span>;</span><br><span class="line">    time_info-&gt;tm_mday = day;</span><br><span class="line">    </span><br><span class="line">    mktime(time_info);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"That day is a %s.\n"</span>, weekday[time_info-&gt;tm_wday]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据竞争-3"><a href="#数据竞争-3" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>&emsp;&emsp;time_ptr所指向的对象如果被访问，有可能会被修改。</p>
<h2 id="异常-3"><a href="#异常-3" class="headerlink" title="异常"></a>异常</h2><p>&emsp;&emsp;保证不会抛出异常。</p>
<h1 id="asctime"><a href="#asctime" class="headerlink" title="asctime"></a><span id="asctime">asctime</span></h1><h2 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">asctime</span><span class="params">(<span class="keyword">const</span> struct tm* time_ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-6"><a href="#说明-6" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;将结构体tm转换为字符串。其返回的字符串的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Www Mmm dd hh:mm:ss yyyy</span><br></pre></td></tr></table></figure>

<p>Www是星期，Mmm是月份（字母表示），dd是日期（按月，也就是1-31），hh:mm:ss是时间，yyyy是年份。该字符串最后面是一个换行符（<code>&#39;\n&#39;</code>），并且有一个结束符（<code>&#39;\0&#39;</code>）。</p>
<p>以下函数的功能等同于<code>asctime</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">asctime</span><span class="params">(<span class="keyword">const</span> struct tm* timeptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> wday_name[] = &#123;</span><br><span class="line">        <span class="string">"Sun"</span>, <span class="string">"Mon"</span>, <span class="string">"Tue"</span>, <span class="string">"Web"</span>, <span class="string">"Thu"</span>, <span class="string">"Fri"</span>, <span class="string">"Sat"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> mon_name[] = &#123;</span><br><span class="line">        <span class="string">"Jan"</span>, <span class="string">"Feb"</span>, <span class="string">"Mar"</span>, <span class="string">"Apr"</span>, <span class="string">"May"</span>, <span class="string">"Jun"</span>,</span><br><span class="line">        <span class="string">"July"</span>, <span class="string">"Aug"</span>, <span class="string">"Sep"</span>, <span class="string">"Oct"</span>, <span class="string">"Nov"</span>, <span class="string">"Dec"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> result[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(result, <span class="string">"%.3s %.3s%3d %.2d:%.2d:%.2d %d\n"</span>,</span><br><span class="line">            wday_name[timeptr-&gt;tm_wday],</span><br><span class="line">            mon_name[timeptr-&gt;tm_mon],</span><br><span class="line">            timeptr-&gt;tm_mday, </span><br><span class="line">            timeptr-&gt;tm_hour, timeptr-&gt;tm_min, timeptr-&gt;tm_sec,</span><br><span class="line">            <span class="number">19000</span> + timeptr-&gt;year);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果要自定义格式化输出时间，见<a href="#strftime">strftime</a>。</p>
<h2 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h2><ul>
<li>time_ptr：指向结构体tm的指针，该结构包含日历时间的各个组件。</li>
</ul>
<h2 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h2><p>&emsp;&emsp;包含日期与时间的信息的C风格字符串。</p>
<h2 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  // time_t, struct tm, time, localtime, asctime</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> raw_time;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">time_info</span>;</span></span><br><span class="line">    </span><br><span class="line">    time(&amp;raw_time);</span><br><span class="line">    time_info = localtime(&amp;raw_time);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The current data/time is: %s"</span>, asctime(time_info));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据竞争-4"><a href="#数据竞争-4" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>&emsp;&emsp;该函数访问time_ptr所指向的对象。该函数还访问和修改共享的内部缓冲区，这可能会导致并发调用asctime或ctime时的数据竞争。一些库提供了一个替代函数来避免这种数据竞争：<code>asctime_r</code>(不可移植)。</p>
<h2 id="异常-4"><a href="#异常-4" class="headerlink" title="异常"></a>异常</h2><p>&emsp;&emsp;保证不抛出异常。</p>
<h1 id="ctime"><a href="#ctime" class="headerlink" title="ctime"></a><span id="ctime">ctime</span></h1><h2 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timer)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数与<code>asctime</code>等价。</p>
<h1 id="gmtime"><a href="#gmtime" class="headerlink" title="gmtime"></a><span id="gmtime">gmtime</span></h1><h2 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct tm* <span class="title">gmtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timer)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-7"><a href="#说明-7" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;将time_t类型转换为UTC时间表示的结构体tm。与<code>localtime</code>对应。</p>
<h2 id="参数-7"><a href="#参数-7" class="headerlink" title="参数"></a>参数</h2><ul>
<li>timer：指向包含time_t类型的时间值。</li>
</ul>
<h2 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h2><p>&emsp;&emsp;一个指向结构体tm的指针，该结构体成员用与计时器的UTC时间表示相对应的值填充。</p>
<h2 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  // time_t, struct tm, time, gmtime</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MST (-7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTC (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CCT (+8)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> raw_time;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">time_info</span>;</span></span><br><span class="line">    </span><br><span class="line">    time(&amp;raw_time);</span><br><span class="line">    time_info = gmtime(&amp;raw_time);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">"Current time around the World:"</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Phoenix, AZ (U.S.) :  %2d:%02d\n"</span>, </span><br><span class="line">            (time_info-&gt;tm_hour+MST)%<span class="number">24</span>, time_info-&gt;tm_min);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Reykjavik (Iceland) : %2d:%02d\n"</span>, </span><br><span class="line">            (time_info-&gt;tm_hour+UTC)%<span class="number">24</span>, time_info-&gt;tm_min);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"Beijing (China) :     %2d:%02d\n"</span>, </span><br><span class="line">            (time_info-&gt;tm_hour+CCT)%<span class="number">24</span>, time_info-&gt;tm_min);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据竞争-5"><a href="#数据竞争-5" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>&emsp;&emsp;该函数访问定时器所指向的对象。该函数还访问和修改共享的内部对象，这可能会在并发调用gmtime和localtime时引入数据竞争。一些库提供了避免这种数据竞争的替代函数：<code>gmtime_r</code>(不可移植)。</p>
<h2 id="异常-5"><a href="#异常-5" class="headerlink" title="异常"></a>异常</h2><p>&emsp;&emsp;保证不抛出异常。</p>
<h1 id="gmtime-r"><a href="#gmtime-r" class="headerlink" title="gmtime_r"></a><span id="gmtime_r">gmtime_r</span></h1><h2 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct tm* <span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timer)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-8"><a href="#说明-8" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;将time_t类型转换为UTC时间表示的结构体tm。与<code>localtime</code>对应。这个函数与<code>gmtime</code>功能一样，但是该函数是线程安全的，更为推荐使用该函数。但是缺点是不可移植。</p>
<h1 id="localtime"><a href="#localtime" class="headerlink" title="localtime"></a><span id="localtime">localtime</span></h1><h2 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct tm* <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span>* timer)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与函数<code>gmtime</code>类似。</p>
<h1 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a><span id="strftime">strftime</span></h1><h2 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strftime</span><span class="params">(<span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> max_size, <span class="keyword">const</span> <span class="keyword">char</span>* format,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> struct tm* time_ptr)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="说明-9"><a href="#说明-9" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;将结构体tm的中描述的时间的相应值按照format格式化，并限制其最大长度为max_size，然后复制到ptr中。</p>
<h2 id="参数-8"><a href="#参数-8" class="headerlink" title="参数"></a>参数</h2><ul>
<li>ptr：该指针指向最后结果存储的位置</li>
<li>max_size：max_size：要复制到ptr中的最大字符数，包括结束字符（<code>&#39;\0&#39;</code>）。</li>
<li>format：包含任何正则字符和特殊格式说明符的组合的C风格字符串。这些格式说明符被函数替换为相应的值，以表示timep_tr中指定的时间。它们都以百分号(%)开头，具体如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>specifier</th>
<th>Replaced by</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td><code>%a</code></td>
<td>Abbreviated weekday name *</td>
<td><code>Thu</code></td>
</tr>
<tr>
<td><code>%A</code></td>
<td>Full weekday name *</td>
<td><code>Thursday</code></td>
</tr>
<tr>
<td><code>%b</code></td>
<td>Abbreviated month name *</td>
<td><code>Aug</code></td>
</tr>
<tr>
<td><code>%B</code></td>
<td>Full month name *</td>
<td><code>August</code></td>
</tr>
<tr>
<td><code>%c</code></td>
<td>Date and time representation *</td>
<td><code>Thu Aug 23 14:55:02 2001</code></td>
</tr>
<tr>
<td><code>%C</code></td>
<td>Year divided by 100 and truncated to integer (<code>00-99</code>)</td>
<td><code>20</code></td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Day of the month, zero-padded (<code>01-31</code>)</td>
<td><code>23</code></td>
</tr>
<tr>
<td><code>%D</code></td>
<td>Short <code>MM/DD/YY</code> date, equivalent to <code>%m/%d/%y</code></td>
<td><code>08/23/01</code></td>
</tr>
<tr>
<td><code>%e</code></td>
<td>Day of the month, space-padded (<code>1-31</code>)</td>
<td><code>23</code></td>
</tr>
<tr>
<td><code>%F</code></td>
<td>Short <code>YYYY-MM-DD</code> date, equivalent to <code>%Y-%m-%d</code></td>
<td><code>2001-08-23</code></td>
</tr>
<tr>
<td><code>%g</code></td>
<td>Week-based year, last two digits (<code>00-99</code>)</td>
<td><code>01</code></td>
</tr>
<tr>
<td><code>%G</code></td>
<td>Week-based year</td>
<td><code>2001</code></td>
</tr>
<tr>
<td><code>%h</code></td>
<td>Abbreviated month name * (same as <code>%b</code>)</td>
<td><code>Aug</code></td>
</tr>
<tr>
<td><code>%H</code></td>
<td>Hour in 24h format (<code>00-23</code>)</td>
<td><code>14</code></td>
</tr>
<tr>
<td><code>%I</code></td>
<td>Hour in 12h format (<code>01-12</code>)</td>
<td><code>02</code></td>
</tr>
<tr>
<td><code>%j</code></td>
<td>Day of the year (<code>001-366</code>)</td>
<td><code>235</code></td>
</tr>
<tr>
<td><code>%m</code></td>
<td>Month as a decimal number (<code>01-12</code>)</td>
<td><code>08</code></td>
</tr>
<tr>
<td><code>%M</code></td>
<td>Minute (<code>00-59</code>)</td>
<td><code>55</code></td>
</tr>
<tr>
<td><code>%n</code></td>
<td>New-line character (<code>&#39;\n&#39;</code>)</td>
<td>``</td>
</tr>
<tr>
<td><code>%p</code></td>
<td>AM or PM designation</td>
<td><code>PM</code></td>
</tr>
<tr>
<td><code>%r</code></td>
<td>12-hour clock time *</td>
<td><code>02:55:02 pm</code></td>
</tr>
<tr>
<td><code>%R</code></td>
<td>24-hour <code>HH:MM</code> time, equivalent to <code>%H:%M</code></td>
<td><code>14:55</code></td>
</tr>
<tr>
<td><code>%S</code></td>
<td>Second (<code>00-61</code>)</td>
<td><code>02</code></td>
</tr>
<tr>
<td><code>%t</code></td>
<td>Horizontal-tab character (<code>&#39;\t&#39;</code>)</td>
<td>``</td>
</tr>
<tr>
<td><code>%T</code></td>
<td>ISO 8601 time format (<code>HH:MM:SS</code>), equivalent to <code>%H:%M:%S</code></td>
<td><code>14:55:02</code></td>
</tr>
<tr>
<td><code>%u</code></td>
<td>ISO 8601 weekday as number with Monday as <code>1</code> (<code>1-7</code>)</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>%U</code></td>
<td>Week number with the first Sunday as the first day of week one (<code>00-53</code>)</td>
<td><code>33</code></td>
</tr>
<tr>
<td><code>%V</code></td>
<td>ISO 8601 week number (<code>01-53</code>)</td>
<td><code>34</code></td>
</tr>
<tr>
<td><code>%w</code></td>
<td>Weekday as a decimal number with Sunday as <code>0</code> (<code>0-6</code>)</td>
<td><code>4</code></td>
</tr>
<tr>
<td><code>%W</code></td>
<td>Week number with the first Monday as the first day of week one (<code>00-53</code>)</td>
<td><code>34</code></td>
</tr>
<tr>
<td><code>%x</code></td>
<td>Date representation *</td>
<td><code>08/23/01</code></td>
</tr>
<tr>
<td><code>%X</code></td>
<td>Time representation *</td>
<td><code>14:55:02</code></td>
</tr>
<tr>
<td><code>%y</code></td>
<td>Year, last two digits (<code>00-99</code>)</td>
<td><code>01</code></td>
</tr>
<tr>
<td><code>%Y</code></td>
<td>Year</td>
<td><code>2001</code></td>
</tr>
<tr>
<td><code>%z</code></td>
<td>ISO 8601 offset from UTC in timezone (1 minute=1, 1 hour=100) If timezone cannot be determined, no characters</td>
<td><code>+100</code></td>
</tr>
<tr>
<td><code>%Z</code></td>
<td>Timezone name or abbreviation * If timezone cannot be determined, no characters</td>
<td><code>CDT</code></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>A <code>%</code> sign</td>
<td><code>%</code></td>
</tr>
</tbody></table>
<ul>
<li>time_ptr：指向结构体tm的指针，该结构包含日历时间的各个组件。</li>
</ul>
<h2 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h2><p>&emsp;&emsp;如果要复制的C字符串的长度(包括结束符)没有超过max_size，则函数返回复制到ptr的字符总数(不包括结束符)。否则，它将返回0，并且ptr所指向的数组的内容是不确定的。</p>
<h2 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; // printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  // time_t, struct tm, time, localtime, strftime</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> raw_time;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">time_info</span>;</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">80</span>];</span><br><span class="line">  </span><br><span class="line">    time(&amp;raw_time);</span><br><span class="line">    time_info = localtime(&amp;raw_time);</span><br><span class="line">  </span><br><span class="line">    strftime(<span class="built_in">buffer</span>, <span class="number">80</span>, <span class="string">"Now it's %I:%M%p."</span>, time_info);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">buffer</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据竞争-6"><a href="#数据竞争-6" class="headerlink" title="数据竞争"></a>数据竞争</h2><p>&emsp;&emsp;该函数访问format所指向的数组和time_ptr所指向的对象。如果成功，它还会修改ptr所指向的数组中的元素。同时更改地区设置也可能导致数据竞争。</p>
<h2 id="异常-6"><a href="#异常-6" class="headerlink" title="异常"></a>异常</h2><p>&emsp;&emsp;保证不会抛出异常。</p>
<h1 id="CLOCKS-PER-SEC"><a href="#CLOCKS-PER-SEC" class="headerlink" title="CLOCKS_PER_SEC"></a><span id="CLOCKS_PER_SEC">CLOCKS_PER_SEC</span></h1><h2 id="说明-10"><a href="#说明-10" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;此宏扩展为表示每秒时钟滴答数的表达式。时钟滴答数是系统特定长度的常量时间单位。例如时钟函数<code>clock</code>返回的时间单位，将返回的时钟滴答计数除以这个表达式得到秒数。</p>
<h1 id="time-t"><a href="#time-t" class="headerlink" title="time_t"></a><span id="time_t">time_t</span></h1><h2 id="说明-11"><a href="#说明-11" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;基本算术类型的别名，能够表示时间，如由函数time返回的时间。由于历史原因，它通常被实现为一个整数值，表示自1970年1月1日00:00小时(即unix时间戳)以来经过的秒数。虽然库可以使用替代时间表示来实现这种类型。可移植程序不应该直接使用这种类型的值，而是始终依赖于对标准库元素的调用来将它们转换为可移植类型。</p>
<h1 id="struct-tm"><a href="#struct-tm" class="headerlink" title="struct tm"></a><span id="tm">struct tm</span></h1><h2 id="说明-12"><a href="#说明-12" class="headerlink" title="说明"></a>说明</h2><p>&emsp;&emsp;该结构体包含能够表示一个日历的9个组件，它们都是int类型的成员：</p>
<table>
<thead>
<tr>
<th>Member</th>
<th>Type</th>
<th>Meaning</th>
<th>Range</th>
</tr>
</thead>
<tbody><tr>
<td>tm_sec</td>
<td><code>int</code></td>
<td>seconds after the minute</td>
<td><code>0-60*</code></td>
</tr>
<tr>
<td>tm_min</td>
<td><code>int</code></td>
<td>minutes after the hour</td>
<td><code>0-59</code></td>
</tr>
<tr>
<td>tm_hour</td>
<td><code>int</code></td>
<td>hours since midnight</td>
<td><code>0-23</code></td>
</tr>
<tr>
<td>tm_mday</td>
<td><code>int</code></td>
<td>day of the month</td>
<td><code>1-31</code></td>
</tr>
<tr>
<td>tm_mon</td>
<td><code>int</code></td>
<td>months since January</td>
<td><code>0-11</code></td>
</tr>
<tr>
<td>tm_year</td>
<td><code>int</code></td>
<td>years since 1900</td>
<td></td>
</tr>
<tr>
<td>tm_wday</td>
<td><code>int</code></td>
<td>days since Sunday</td>
<td><code>0-6</code></td>
</tr>
<tr>
<td>tm_yday</td>
<td><code>int</code></td>
<td>days since January 1</td>
<td><code>0-365</code></td>
</tr>
<tr>
<td>tm_isdst</td>
<td><code>int</code></td>
<td>Daylight Saving Time flag</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的常用标准IO函数</title>
    <url>/2021/06/25/C++%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86IO%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="I-O-Stream的共通基础"><a href="#I-O-Stream的共通基础" class="headerlink" title="I/O Stream的共通基础"></a>I/O Stream的共通基础</h1><p>&emsp;&emsp;C++不直接处理输入输出，而是通过一组定义在标准库中的类型来处理IO。这些类型支持从设备中读取数据、向设备中写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO，即从string读取数据，向string写入数据。</p>
<h2 id="Stream对象"><a href="#Stream对象" class="headerlink" title="Stream对象"></a>Stream对象</h2><p>&emsp;&emsp;C++ I/O由stream完成。所谓stream就是一条数据流，字符序列在其中“川流不息”。按照面向对象原则，stream是由某个class定义出来具有特定性质的对象。输出动作被解释为“数据流进stream”，输入动作则是“数据流出stream”。另外，还有一些全局对象，是为标准I/O通道而定义的。</p>
<a id="more"></a>

<h2 id="Stream-Class"><a href="#Stream-Class" class="headerlink" title="Stream Class"></a>Stream Class</h2><p>&emsp;&emsp;正如有不同种类的I/O（例如输入、输出、文件访问），对应地也有不同的stream class，其中最重要的是：</p>
<ul>
<li><strong>Class istream</strong>定义input stream，用来读数据。</li>
<li><strong>Class ostream</strong>定义output stream，用来写数据。</li>
</ul>
<p>&emsp;&emsp;两者分别具体实现自<code>template class basic_istream&lt;&gt;</code>或<code>basic_ostream&lt;&gt;</code>，以char作为字符类型。事实上整个IOStream程序库不依赖任何特定的字符类型，而是以一个template实参替代之。这样的参数化在string class也存在，并且也被运用于国际化议题。</p>
<h2 id="全局的Stream对象"><a href="#全局的Stream对象" class="headerlink" title="全局的Stream对象"></a>全局的Stream对象</h2><p>&emsp;&emsp;IOStream程序库定义了数个类型为istream和ostream的全局对象，它们对应于标准I/O通道：</p>
<ul>
<li><strong>cin</strong>，隶属于istream，是供使用者输入用的标准输入通道，对应于C中的stdin。操作系统通常将它和键盘连接。</li>
<li><strong>cout</strong>，隶属于ostream，是供使用者输出用的标准输出通道，对应于C中的stdout。操作系统通常将它和监视器（屏幕）连接。</li>
<li><strong>cerr</strong>，隶属于ostream，是所有报错信息所使用的标准报错输出通道，对应于C中的stderr。操作系统通常也将它和监视器（屏幕）连接。默认情况下cerr无缓冲。</li>
<li><strong>clog</strong>，隶属于ostream，是标准日志通道，C中没有对应物。默认情况下操作系统将它连接于cerr所连接的设备，但clog有缓冲。</li>
</ul>
<p>&emsp;&emsp;将“正常输出”和“报错信息输出”加以分离，可以让程序以不同的方式对待两种不同的输出。例如可以将正常输出重新定向至某个文件，而同时仍然令报错信息显示于控制台。当然，前提是操作系统必须支持标准I/O通道的重定向功能。这种分离方式起源于UNIX的I/O重定向概念。</p>
<h1 id="IO类的相关类型信息"><a href="#IO类的相关类型信息" class="headerlink" title="IO类的相关类型信息"></a>IO类的相关类型信息</h1><h2 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h2><p>&emsp;&emsp;我们不能拷贝或对IO对象赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2; <span class="comment">// error!</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>; <span class="comment">// error!</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>
<h2 id="操控器"><a href="#操控器" class="headerlink" title="操控器"></a>操控器</h2><p>&emsp;&emsp;在大部分输出语句的末尾，我们都会写一个如下的东西，称为操控器：<code>std::cout &lt;&lt; std::endl</code>。这种东西是“专门用来操控stream”的一种特殊对象，通常它只会改变“输入的解释方式”或“输入的格式化方式”，例如数值的进制dec（十进制）、hex（十六进制）、oct（八进制）。用于ostream的操控器并不会凭空制造出输出数据，用于istream的操控器也不会吃掉任何输入数据。但有些操控器会引发立即动作，例如用于“刷新（flush）output缓冲区”或“跳过input缓冲区空格”的那些操控器。</p>
<p>&emsp;&emsp;操控器endl的意思是终止一行（end line）。它做两件事情：</p>
<ol>
<li>输出换行符，也就是‘\n’。</li>
<li>刷新output缓冲区（也就是对于给定的stream，应用其<code>flush()</code>强制输出缓冲区内所有数据）。 </li>
</ol>
<p>&emsp;&emsp;IOStream程序库定义的一些最重要的操控器见下表：</p>
<table>
<thead>
<tr>
<th>操控器</th>
<th>类</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="C-标准cin函数"><a href="#C-标准cin函数" class="headerlink" title="C++标准cin函数"></a>C++标准cin函数</h1><h2 id="标准输入缓冲区"><a href="#标准输入缓冲区" class="headerlink" title="标准输入缓冲区"></a>标准输入缓冲区</h2><p>&emsp;&emsp;在阐述C++的cin标准读取函数前，需要了解标准输入缓冲区。当一次键盘输入结束时（也就是按下Enter键，此时Enter的分隔符也会被存入输入缓冲区）会将输入的数据存入输入缓冲区，而输入语句则直接从输入缓冲区中读取数据。正因为是直接从缓冲区读取数据，所以有时候当缓冲区中有残留数据时，输入函数直接取得这些残留数据而不会请求键盘输入。</p>
<h2 id="cin-gt-gt"><a href="#cin-gt-gt" class="headerlink" title="cin &gt;&gt;"></a>cin &gt;&gt;</h2><p>&emsp;&emsp;该操作符是根据后面变量的类型读取数据。</p>
<p>&emsp;&emsp;输入结束条件：遇到Enter、Space、Tab分隔符。</p>
<p>&emsp;&emsp;对结束字符的处理：丢弃缓冲区中使得输入结束的结束符（Enter、Space、Tab）。</p>
<p>&emsp;&emsp;若缓冲区中的第一个字符是Enter、Sapce、Tab这些分隔符，cin&gt;&gt;会将其忽略并清除，然后继续读取下一个字符，若缓冲区为空，则继续等待。如果读取成功，字符后面的分隔符会残留在缓冲区内，本次cin&gt;&gt;调用不做处理，下次cin&gt;&gt;调用时会将其忽略并消除。</p>
<h2 id="cin-get（数组名，长度，结束符）"><a href="#cin-get（数组名，长度，结束符）" class="headerlink" title="cin.get（数组名，长度，结束符）"></a>cin.get（数组名，长度，结束符）</h2><p>&emsp;&emsp;该函数有多种形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">cin</span>.<span class="built_in">get</span>();</span><br><span class="line">istream&amp; <span class="built_in">cin</span>.<span class="built_in">get</span>(<span class="keyword">char</span>&amp; c);</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span>* s, streamsize n)</span></span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">get</span><span class="params">(<span class="keyword">char</span>* s, streamsize n, <span class="keyword">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;前两种用于读取一个字符，可以使用<code>c = cin.get()</code>或者<code>cin.get(c)</code>，这两种几乎没有差别。它们从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取。此外，<code>cin.get()</code>的返回值是int值，成功返回读取字符的ASCII码值，遇到文件结束符时，返回EOF，即-1。Windows下命令行输入文件结束符的方式为Ctrl + z，Linux为Ctrl + d。由于<code>cin.get(c)</code>返回的是cin对象，因此可以支持链式操作，如<code>cin.get(b).get(c)</code>。</p>
<p>&emsp;&emsp;后两</p>
<h2 id="cin-getline（）"><a href="#cin-getline（）" class="headerlink" title="cin.getline（）"></a>cin.getline（）</h2><p>&emsp;&emsp;<code>cin.getline(数组名，长度，结束符)</code>大体与<code>cin.get(数组名，长度，结束符)</code>类似。区别在于：当<code>cin.get()</code>输入的字符串超过长度时，不会引起cin函数的错误，后面的cin操作会继续执行，只是直接从缓冲区中读取数据。但是当<code>cin.getline()</code>输入超过长度时，会引起cin函数的错误，后面的cin操作将不再执行。而且，<code>cin.getline()</code>与<code>cin.get()</code>不同，<code>cin.getline()</code>虽然也会将结束符读取出来，但不会将结束符残留在输入缓冲区中。</p>
<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake命令之configure_file</title>
    <url>/2021/01/05/CMake%E5%91%BD%E4%BB%A4%E4%B9%8Bconfigure_file/</url>
    <content><![CDATA[<hr>
<h1 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(&lt;input&gt; &lt;output&gt;</span><br><span class="line">               [COPYONLY] [ESCAPE_QUOTES] [@ONLY]</span><br><span class="line">               [NO_SOURCE_PERMISSIONS]</span><br><span class="line">               [NEWLINE_STYLE [UNIX|DOS|WIN32|LF|CRLF] ])</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;将&lt;input&gt;文件复制到&lt;output&gt;文件，并替换在input文件中的<code>@var@</code>或<code>${var}</code>为cmake中指定的值。根据cmake中是否定义了var来决定<code>#cmakedefine VAR ...</code>会被替换为<code>#define VAR ...</code>还是<code>#undef VAR</code>。同样的，<code>#cmakedefine01 VAR</code>会被替换为<code>#define VAR 1</code>或是<code>#define VAR 0</code>。</p>
<a id="more"></a>

<p>&emsp;&emsp;除了<code>#undef</code>以外，<code>#</code>与<code>cmakedefine</code>或<code>cmakedefine01</code>之间可以使用space或者是tabs来进行缩进，并且缩进的空格将会在输出文件中保留下来。如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  cmakedefine VAR</span></span><br><span class="line"><span class="comment">#  cmakedefine01 VAR</span></span><br></pre></td></tr></table></figure>

<p>如果VAR被定义了，上述命令会被替换为：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  define VAR</span></span><br><span class="line"><span class="comment">#  define VAR 1</span></span><br></pre></td></tr></table></figure>

<h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><p>&emsp;&emsp;相关的命令参数有以下几个：</p>
<ul>
<li><code>&lt;input&gt;</code>：输入文件的路径。相对路径是相对于<code>CMAKE_CURRENT_SOURCE_DIR</code>变量的值。该路径必须是文件，不能是目录。</li>
<li><code>&lt;output&gt;</code>：输出文件或目录的路径。相对路径是相对于<code>CMAKE_CURRENT_BINARY_DIR</code>变量的值。如果路径的名称是已经存在的目录，则输出文件会被置于那个目录下，并且其名称会与输入文件的名称一样。</li>
<li><code>COPYONLY</code>：仅仅拷贝文件，不会替换任何的引用变量以及其他的内容。该选项不能与<code>NEWLINE_STYLE</code>同时使用。</li>
<li><code>ESCAPE_QUOTES</code>：不对反斜杠进行转义。</li>
<li><code>@ONLY</code>：限制变量只能在<code>@VAR@</code>形式下进行替换。</li>
<li><code>NO_SOURCE_PERMISSIONS</code>：拷贝后的文件不会拥有与原来文件相同的访问权限。拷贝后的文件的权限默认为644（-rw-r-r）。</li>
<li><code>NEWLINE_STYLE &lt;style&gt;</code>：为输出文件也就是<code>&lt;output&gt;</code>确定换行符的格式。UNIX或者LF系统为<code>\n</code>换行符格式，DOS、WIN32和CRLF系统为<code>\r\n</code>换行符格式。这个选项不能与<code>COPYONLY</code>同时使用。</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>&emsp;&emsp;考虑一个源代码树，其包含一个<code>foo.h.in</code>文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cmakedefine FOO_ENABLE</span></span><br><span class="line"><span class="comment">#cmakedefine FOO_STRING "@FOO_STRING@"</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其邻近的<code>CMakeLists.txt</code>可以使用<code>configure_file</code>来配置头文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(FOO_ENABLE <span class="string">"Enable Foo"</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(FOO_ENABLE)</span><br><span class="line">    <span class="keyword">set</span>(FOO_SRTING <span class="string">"foo"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">configure_file</span>(foo.h.in foo.h @ONLY)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这将会在与源目录相对应的构建目录下创建出一个<code>foo.h</code>文件。如果<code>FOO_ENABLE</code>选项是开启的，则配置头文件会包含：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_ENABLE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOO_STRING <span class="meta-string">"foo"</span></span></span><br></pre></td></tr></table></figure>

<p>如果<code>FOO_ENABLE</code>没有开启，则配置头文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* #undef FOO_ENABLE */</span></span><br><span class="line"><span class="comment">/* #undef FOO_STRING */</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;之后便可以使用<code>include_directories()</code>命令来定义一个输出目录（output directory）作为包含目录（include directory）：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们的源文件就可以使用<code>#include &quot;foo.h&quot;</code>来包含该头文件。</p>
]]></content>
      <categories>
        <category>cmake命令</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake命令之install</title>
    <url>/2021/07/05/CMake%E5%91%BD%E4%BB%A4%E4%B9%8Binstall/</url>
    <content><![CDATA[<hr>
<h1 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">install(TARGETS &lt;target&gt;... [...])</span><br><span class="line">install(IMPORTED_RUNTIME_ARTIFACTS &lt;target&gt;... [...])</span><br><span class="line">install(&#123;FILES | PROGRAMS&#125; &lt;file&gt;... [...])</span><br><span class="line">install(DIRECTORY &lt;dir&gt;... [...])</span><br><span class="line">install(SCRIPT &lt;file&gt; [...])</span><br><span class="line">install(CODE &lt;code&gt; [...])</span><br><span class="line">install(EXPORT &lt;export-name&gt; [...])</span><br><span class="line">install(RUNTIME_DEPENDENCY_SET &lt;set-name&gt; [...])</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;install指令可以用来构建一个项目的安装规则。亦可以通过调用<code>add_subdirectory()</code>命令来添加子目录中的安装规则，与父目录中的安装规则一同按照命令的声明顺序来运行该安装指令。该命令有多个标签，如上述所示，TARGETS、FILES等。以下为多个标签的通用选项：</p>
<ul>
<li><p><code>DESTINATION</code></p>
<p>&emsp;&emsp;指定安装文件的路径。参数可以是相对路径也可以是绝对路径。</p>
<p>&emsp;&emsp;当参数是相对路径时，该路径是相对于<code>CMAKE_INSTALL_PREFIX</code>变量的值，该变量在UNIX下默认为<code>/usr/local</code>，在Windows下默认为<code>c:/Program Files/${PROJECT_NAME}</code>。在UNIX上可以使用<code>DESTDIR</code>变量来重新定位整个安装路径。例如：<code>make DESTDIR=/home/arzhe install</code>，这会将<code>DESTDIR</code>的值添加至默认安装目录（在UNIX下，也就是<code>/usr/local</code>）的前缀，最终软件会被安装至<code>/home/arzhe/usr/local</code>目录下。<code>DESTDIR</code>不能被用于Windows中，因为Windows默认安装目录不能以其他目录作为前缀。</p>
<p>&emsp;&emsp;当参数是绝对路径时（以<code>/</code>开头或者是驱动器号），安装路径就是该完整路径。</p>
<p>&emsp;&emsp;由于绝对路径不支持cpack安装程序构建器，所以更推荐使用相对路径。此外，也没有必要添加前缀<code>CMAKE_INSTALL_PREFIX</code>变量来声明一个绝对路径，该前缀在使用相对路径时，会被自动添加至该路径。</p>
</li>
<li><p><code>PERMISSIONS</code></p>
<p>&emsp;&emsp;为安装文件指定权限。一般为以下参数：</p>
<table>
<thead>
<tr>
<th>READ</th>
<th>WRITE</th>
<th>EXECUTE</th>
</tr>
</thead>
<tbody><tr>
<td><code>OWNER_READ</code></td>
<td><code>OWNER_WRITE</code></td>
<td><code>OWNER_EXECUTE</code></td>
</tr>
<tr>
<td><code>GROUP_READ</code></td>
<td><code>PROUP_WRITE</code></td>
<td><code>GROUP_EXECUTE</code></td>
</tr>
<tr>
<td><code>WORLD_READ</code></td>
<td><code>WORLD_WRITE</code></td>
<td><code>WORLD_EXECUTE</code></td>
</tr>
</tbody></table>
</li>
<li><p><code>CONFIGURATIONS</code></p>
<p>&emsp;&emsp;指定应用程序的安装配置（例如Debug，Release等）。例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">install(TARGETS target</span><br><span class="line">        CONFIGURATIONS Debug</span><br><span class="line">        RUNTIME DESTINATION Debug/bin)</span><br><span class="line">install(TARGETS target</span><br><span class="line">        CONFIGURATIONS Release</span><br><span class="line">        RUNTIME DESTINATION Release/bin)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>COMPONENT</code></p>
<p>&emsp;&emsp;指定与安装规则相关联的安装组件名称，例如“runtime”或“development”。在特定组件的安装过程中，只会执行与特定组件相关联的安装规则。在整个安装期间，所有的组件都会被安装，除非被标记为<code>EXCLUDE_FROM_ALL</code>。如果没有提供<code>COMPONENT</code>标签，那么一个默认组件“Unspecified”将会被创建。</p>
</li>
<li><p><code>EXCLUDE_FROM_ALL</code></p>
<p>&emsp;&emsp;将该文件排除在完整安装之外，并且只作为特定组件的一部分来安装。</p>
</li>
<li><p><code>RENAME</code></p>
<p>&emsp;&emsp;为安装文件重命名（可能与原文件名不同），只有当该命令安装了单个文件时，才允许重命名。</p>
</li>
<li><p><code>OPTIONAL</code></p>
<p>&emsp;&emsp;如果将被安装的文件不存在，那么将指定该操作不是一个错误。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>cmake命令</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake命令之target_compile_definitions</title>
    <url>/2021/06/30/CMake%E5%91%BD%E4%BB%A4%E4%B9%8Btarget_compile_definitions/</url>
    <content><![CDATA[<hr>
<h1 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target_compile_definitions(&lt;target&gt;</span><br><span class="line">  &lt;INTERFACE&gt;|&lt;PUBLIC&gt;|&lt;PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE&gt;|&lt;PUBLIC&gt;|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该命令会为给定的<code>&lt;target&gt;</code>添加编译定义项。其中<code>&lt;INTERFACE&gt;|&lt;PUBLIC&gt;|&lt;PRIVATE&gt;</code>指定了<code>[items...]</code>可以传播的域。</p>
<a id="more"></a>

<p>&emsp;&emsp;<code>&lt;target&gt;</code>必须是由<code>add_excutable()</code>或<code>add_library()</code>命令创建而来的，并且不能是<code>Alias target</code>。<code>PRIVATE</code>和<code>PUBLIC</code>选项会填充<code>&lt;target&gt;</code>的<code>COMPILE_DEFINITIONS</code>变量。<code>PUBLIC</code>和<code>INTERFACE</code>选项填充<code>&lt;target&gt;</code>的<code>INTERFACE_COMPILE_DEFINITIONS</code>变量。</p>
<p>&emsp;&emsp;以-D开头的item中的-D会被移除，任何空的item也会被移除。例如，以下几个命令都是等价的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target_compile_definition(foo PUBLIC FOO)</span><br><span class="line">target_compile_definition(foo PUBLIC -DFOO)   <span class="comment"># -D removed</span></span><br><span class="line">target_compile_definition(foo PUBLIC <span class="string">""</span> FOO)  <span class="comment"># "" ignored</span></span><br><span class="line">target_compile_definition(foo PUBLIC -D FOO)  <span class="comment"># -D becomes "", then ignored</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编译定义项也可以有值：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">target_compile_definition(foo PUBLIC FOO=1)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要注意的是，很多编译器会将<code>-DFOO</code>与<code>-DFOO=1</code>划上等号，也就是说默认“没有值的编译定义项”的值为1，然而也有其他的一些编译器并不会做出这样的规定。所以最好总是给编译定义项添加值。</p>
]]></content>
      <categories>
        <category>cmake命令</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>C／C++中的字节对齐</title>
    <url>/2021/04/17/C%EF%BC%8FC++%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<hr>
<h1 id="理一理字节对齐"><a href="#理一理字节对齐" class="headerlink" title="理一理字节对齐"></a>理一理字节对齐</h1><h2 id="什么是字节对齐"><a href="#什么是字节对齐" class="headerlink" title="什么是字节对齐"></a>什么是字节对齐</h2><p>&emsp;&emsp;计算机中内存大小的基本单元是字节（byte），理论上来说，我们可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小连续地读写内存，而是以2，4或8的倍数的字节块来读写内存，这也就限制了基本数据类型在计算机中存储的方式，至少是对于我们需要一种高效的程序时，这会对我们的数据类型有所限制。那么按照一定规则来将基本数据类型在存储空间上进行排列，这个操作就叫做字节对齐。</p>
<a id="more"></a>

<h2 id="字节对齐的规则"><a href="#字节对齐的规则" class="headerlink" title="字节对齐的规则"></a>字节对齐的规则</h2><p>&emsp;&emsp;在了解字节对齐规则前，需要先对以下几个概念有所了解：</p>
<ul>
<li>基本数据类型的对齐值：基本数据类型的对齐值即为它们自身大小的值，比如在64位操作系统中，char型数据对齐值为1字节，int型数据对齐值为4字节，unsigned long型对齐值为8字节。</li>
<li>结构体或类的对齐值：它们的对齐值是其自身成员对齐值最大的那个值。</li>
<li>指定对齐值：使用宏命令<code>#pragma pack(value)</code>可以指定对齐值value。</li>
<li>数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即<code>有效对齐值 = min{自身对齐值，当前指定的pack值}</code>。</li>
</ul>
<p>&emsp;&emsp;其中有效对齐值N是最终用来决定数据存放地址方式的值。有效对齐N表示“对齐在N上”，也就是该数据存储地址要满足<code>存放起始地址%N = 0</code>。需要记住的是数据在计算机地址中的存储顺序是按照它们定义的先后顺序决定的，先定义的优先进行存储。第一个数据存放的起始地址就是数据结构的起始地址。不仅结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整（即结构体成员变量占用总字节 = 结构体有效对齐值的整数倍）。</p>
<p>&emsp;&emsp;考虑如下代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> int_4byte;</span><br><span class="line">    <span class="keyword">char</span> char_1byte;</span><br><span class="line">    short short_2byte;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_2</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> char_1byte;</span><br><span class="line">    <span class="keyword">int</span> int_4byte;</span><br><span class="line">    short short_2byte;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the size of struct test1 is %zu\n"</span>, <span class="keyword">sizeof</span>(struct test1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the size of struct test2 is %zu\n"</span>, <span class="keyword">sizeof</span>(struct test2));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可能你的计算机是64位的，那么默认是8字节对齐，我们将上述代码以32位来进行编译（默认是4字节对齐）：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/2021-04-17%20%E4%B8%8B%E5%8D%888.19.51.png" alt="编译结果示例"></p>
<p>&emsp;&emsp;可以看到结构体Test_1的大小为8字节，而并不是所谓的7字节（4+1+2），结构体Test_2的大小为12字节，而不是所谓的7字节（4+1+2），你又可能会十分苦恼，这里明明是一样的结构体，但是为什么最后的结果不一样呢？</p>
<p>&emsp;&emsp;实际上，就拿Test_1结构体来说，其在内存地址中的存储位置简图如下：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/2021-04-18%20%E4%B8%8A%E5%8D%8810.49.png" alt="Test_1结构体存储地址"></p>
<p>&emsp;&emsp;可以看到我们的<code>int_4byte</code>起始存储地址满足条件“<code>起始存储地址%4 = 0</code>”，也就是0地址位（当然这里并不是指实际中的存储地址，只是以一种抽象易懂的方式呈现出来）；接下来该存储<code>char_1byte</code>变量了，由于下一个地址位4满足其起始存储地址，自然也就存储在该地址位了；现在只剩下<code>short_2byte</code>变量了，它找到下一个地址位5，但是其对齐值为2，并不满足“对齐条件”，怎么办呢？很简单，继续向后搜索直到找到满足该“对齐条件”的地址位，很好，地址位6满足它的起始存储地址。这样一来，正好从从0地址位到8地址位，一共8个字节，虚线部分是由计算机填充的字节，由图中所示一共填充了1个字节。特别需要注意的是，这里的<code>Test_1结构体</code>在最后也需要填充字节以满足自身对齐值（其最大成员的对齐值）的要求，但是在此例中已然满足了，就无需再填充字节了。关于<code>Test_2结构体的解析</code>就留给你们了。</p>
<h2 id="为什么要字节对齐"><a href="#为什么要字节对齐" class="headerlink" title="为什么要字节对齐"></a>为什么要字节对齐</h2><p>&emsp;&emsp;在了解了字节对齐的工作机制之后，我们需要思考，为什么计算机要如此大费周章地来进行字节对齐这个操作呢？按顺序一个个地存放不行吗？可以，当然可以，无论数据是否对齐，大多数计算机还是能够正确工作的，而且从前面的例子可以看到，结构体本来只需要7个字节的空间，最后却占用了8个字节，很明显浪费了空间，那么为什么还要进行字节对齐呢？最重要的考虑就是为了提高内存系统性能。</p>
<p>&emsp;&emsp;前面也提到过，计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。甚至在有些处理器中，如果存在未对齐的数据，可能不能正确工作。</p>
<p>&emsp;&emsp;一般来说在32位系统下，系统默认对齐值是4字节，而在64位系统下，系统默认对齐值是8字节，也就是说在缺省状态下，编译器会默认为你的数据按自然对齐条件分配空间。此外在不同的平台上，默认对齐值都不尽相同。这样一来，假设你的程序是跨平台，那么某些架构的CPU在处理另一个平台的数据时，可能会发生奇奇怪怪的错误。</p>
<p>&emsp;&emsp;字节对齐的作用不仅仅是便于CPU快速访问，同时合理的字节对齐可以有效地节省存储空间。</p>
<h2 id="如何实现字节对齐"><a href="#如何实现字节对齐" class="headerlink" title="如何实现字节对齐"></a>如何实现字节对齐</h2><p>&emsp;&emsp;在实际的coding中，字节对齐的细节都由编译器完成，我们不需要特意地进行字节的对齐，但这并不意味着我们不需要关注字节对齐的问题。在处理跨平台的问题上，我们有两种处理方法：</p>
<ul>
<li>1字节对齐</li>
<li>手动对结构体进行字节对齐</li>
</ul>
<p>&emsp;&emsp;我们可以使用<code>#pragma pack(n)</code>（n为字节对齐值）来指定对齐值，并且可以使用<code>#pragma pack()</code>来还原默认对齐值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) <span class="comment">// 1字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> int_4byte;</span><br><span class="line">    <span class="keyword">char</span> char_1byte;</span><br><span class="line">    short short_2byte;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack() <span class="comment">// 还原默认对齐</span></span></span><br></pre></td></tr></table></figure>

<p>如此一来，任何平台结构体test的大小就都是7字节了，这样做可以保证跨平台的结构大小一致，同时还节省了空间，但不幸的是，降低了效率，因为CPU依然会按照自身的对齐值来读取数据。</p>
<p>&emsp;&emsp;对于单个结构体，gcc还有如下方法来解决跨平台问题：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> int_4byte;</span><br><span class="line">    <span class="keyword">char</span> char_1byte;</span><br><span class="line">    short short_2byte;</span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__attribute__((aligned (n)))</code>，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。</li>
<li><code>__attribute__ ((packed))</code>，取消结构在编译过程中的优化对齐，也可以认为是1字节对齐。</li>
</ul>
<p>&emsp;&emsp;除了前述的1字节对齐，还可以进行人为的填充：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> int_4byte;</span><br><span class="line">    <span class="keyword">char</span> char_1byte;</span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">1</span>];</span><br><span class="line">    short short_2byte;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该结构体虽然访问效率高，但是并没有节省空间，同时扩展性也并不是很好，例如，当字节对齐变化时，需要填充的字节数可能就会发生变化。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake的install操作</title>
    <url>/2021/07/04/Cmake%E7%9A%84install%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h1 id="如何使用cmake来执行install操作"><a href="#如何使用cmake来执行install操作" class="headerlink" title="如何使用cmake来执行install操作"></a>如何使用cmake来执行install操作</h1><p>&emsp;&emsp;首先假定我们有以下目录树以及相关文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProjectTopDir</span><br><span class="line">---&gt;CMakeLists.txt</span><br><span class="line">---&gt;Util</span><br><span class="line">    ---&gt;CMakeLists.txt</span><br><span class="line">    ---&gt;util.h</span><br><span class="line">    ---&gt;u1.cpp</span><br><span class="line">    ---&gt;u2.cpp</span><br><span class="line">---&gt;build</span><br><span class="line">---&gt;src</span><br><span class="line">    ---&gt;tutorial.cpp</span><br></pre></td></tr></table></figure>

<p>其中源码树为ProjectTopDir，构建树为build，所有中间文件以及最终目标将存放在build树中。我们额外定义了一个Util库，存放着相关的工具库，CMakeLists.txt大致为如下所示：</p>
<a id="more"></a>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Util u1.cpp u2.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(Util</span><br><span class="line">    INTERFACE</span><br><span class="line">        <span class="variable">$&#123;CMAKE_CURRNET_SOURCE_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">TARGET</span> Util DESTINATION lib)</span><br><span class="line"><span class="keyword">install</span>(FILES util.h DESTINATION <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>该CMakeLists.txt定义了一个静态库，并且默认安装在/usr/local目录下（UNIX）。当然用户可以通过在执行<code>cmake --install .</code>命令时添加一个额外参数<code>--prefix &quot;pre-to-installDir-path&quot;</code>来指定一个安装目录的前缀，例如当执行<code>cmake --install . --prefix &quot;/usr/localInstall&quot;</code>时，该静态库的会被安装在<code>/usr/localInstall/lib</code>中，头文件则会被安装在<code>/usr/localInstall/include</code>中。</p>
<p>&emsp;&emsp;在顶层的CMakeLists.txt文件中，大致如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(Tutorial VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(Util)</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(APPEND EXTRA_LIBS Util)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src/tutorial.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    PUBLIC</span><br><span class="line">        <span class="variable">$&#123;EXTRA_LIBS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span> DESTINATION bin)</span><br></pre></td></tr></table></figure>

<p>同样的，该可执行文件将会被安装在<code>/usr/localInstall/bin</code>中。</p>
<p>&emsp;&emsp;需要注意的是，在执行<code>cmake --install . --prefix &quot;...&quot;</code>之前，需要先构建出该项目的构建系统，以及使用构建器来完成项目的构建。例如在顶级目录中执行<code>cmake . -B build</code>命令，然后进入build目录下，执行<code>make</code>命令，至此，项目构建完毕。</p>
<p>&emsp;&emsp;关于cmake更为详细的install指令收录在</p>
]]></content>
      <categories>
        <category>cmake工具教程</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX标准IO库之流的操作</title>
    <url>/2022/01/07/UNIX%E6%A0%87%E5%87%86IO%E5%BA%93%E4%B9%8B%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h1 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h1><p>&emsp;&emsp;下列三个函数打开一个标准<code>I/O</code>流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//三个函数的返回值：若成功，返回文件指针；若出错，返回NULL。</span></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* type)</span></span>;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;这三个函数的区别如下。</p>
<ol>
<li><code>fopen</code>函数打开路径名为<code>pathname</code>的一个指定文件。</li>
<li><code>freopen</code>函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若该流已经定向，则使用<code>freopen</code>清除该定向。此函数一般用于将一个指定文件打开为一个预定义的流：标准输入、标准输出或标准错误。</li>
<li><code>fdopen</code>函数取一个已有的文件描述符（可能从<code>open</code>、<code>dup</code>、<code>dup2</code>、<code>fcntl</code>、<code>pipe</code>、<code>socket</code>、<code>socketpair</code>或<code>accept</code>函数得到此文件描述符），并使一个标准的<code>I/O</code>流与该描述符相结合。此函数常用于由创建管道和网络通信信道函数返回的描述符。因为这些特殊类型的文件不能用标准<code>I/O</code>函数<code>fopen</code>打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用<code>fdopen</code>使一个标准<code>I/O</code>流与该描述符相结合。</li>
</ol>
<blockquote>
<p>&emsp;&emsp;<code>fopen</code>和<code>freopen</code>是<code>ISO C</code>的所属部分。而<code>ISO C</code>并不涉及文件描述符，所以仅有<code>POSIX.1</code>具有<code>fdopen</code>。</p>
</blockquote>
<p>&emsp;&emsp;<code>type</code>参数指定对该<code>I/O</code>流的读、写方式，<code>ISO C</code>规定<code>type</code>参数可以有15种不同的值，如下表所示。</p>
<table>
<thead>
<tr>
<th><code>type</code></th>
<th>说明</th>
<th><code>open(2)</code>标志</th>
</tr>
</thead>
<tbody><tr>
<td><code>r</code>或<code>rb</code></td>
<td>为读而打开</td>
<td><code>O_RDONLY</code></td>
</tr>
<tr>
<td><code>w</code>或<code>wb</code></td>
<td>把文件截断至0长，或为写而创建</td>
<td>`O_WRONLY</td>
</tr>
<tr>
<td><code>a</code>或<code>ab</code></td>
<td>追加；为在文件尾写而打开，或为写而创建</td>
<td>`O_WRONLY</td>
</tr>
<tr>
<td><code>r+</code>或<code>r+b</code>或<code>rb+</code></td>
<td>为读和写而打开</td>
<td><code>O_RDWR</code></td>
</tr>
<tr>
<td><code>w+</code>或<code>w+b</code>或<code>wb+</code></td>
<td>把文件截断至0长，或为读和写而打开</td>
<td>`O_RDWR</td>
</tr>
<tr>
<td><code>a+</code>或<code>a+b</code>或<code>ab+</code></td>
<td>为在文件尾读和写而打开或创建</td>
<td>`O_RDWR</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;使用字符<code>b</code>作为<code>type</code>的一部分，这使得标准<code>I/O</code>系统可以区分文本文件和二进制文件。因为<code>UNIX</code>内核并不对这两种文件进行区分，所以在<code>UNIX</code>系统环境下指定字符<code>b</code>作为<code>type</code>的一部分实际上并无作用。</p>
<p>&emsp;&emsp;对于<code>fdopen</code>，<code>type</code>参数的意义稍有区别。因为该描述符已被打开，所以<code>fdopen</code>为写而打开并不截断该文件。（例如，若该描述符原来是由<code>open</code>函数创建的，而且该文件已经存在，则其<code>O_TRUNC</code>标志将决定是否截断该文件。<code>fdopen</code>函数不能截断它为写而打开的任一文件。）另外，标准<code>I/O</code>追加写方式也不能用于创建该文件（因为如果一个描述符引用一个文件，则该文件一定已经存在）。</p>
<p>&emsp;&emsp;当用追加写类型打开一个文件后，每次写都将数据写到文件的当前尾端处。如果有多个进程用标准<code>I/O</code>追加写方式打开同一文件，那么来自每个进程的数据都将正确地写到文件中。</p>
<p>&emsp;&emsp;当以读和写类型打开一个文件时（<code>type</code>中<code>+</code>号），具有以下限制。</p>
<ul>
<li>如果中间没有<code>fflush</code>、<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，则在输出的后面不能直接跟随输入。</li>
<li>如果中间没有<code>fseek</code>、<code>fsetpos</code>或<code>rewind</code>，或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出。</li>
</ul>
<p>&emsp;&emsp;对应上表，下表列出了打开一个流的6种不同的方式。</p>
<table>
<thead>
<tr>
<th>限制</th>
<th><code>r</code></th>
<th><code>w</code></th>
<th><code>a</code></th>
<th><code>r+</code></th>
<th><code>w+</code></th>
<th><code>a+</code></th>
</tr>
</thead>
<tbody><tr>
<td>文件必须已存在</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
</tr>
<tr>
<td>放弃文件以前的内容</td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
</tr>
<tr>
<td>流可以读</td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>流可以写</td>
<td></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>流只可在尾端处写</td>
<td></td>
<td></td>
<td>✅</td>
<td></td>
<td></td>
<td>✅</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;需要注意的是，在指定<code>w</code>或<code>a</code>类型创建一个新文件时，我们无法说明该文件的访问权限位（在“<a href="/2021/12/08/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%B8%80%EF%BC%89/" title="UNIX文件IO（一）">UNIX文件IO（一）</a>”中所述的<code>open</code>和<code>create</code>函数则能做到这一点）。<code>POSIX.1</code>要求实现使用如下的权限位集来创建文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>UNIX标准IO</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX文件IO（一）</title>
    <url>/2021/12/08/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;UNIX系统中大多数文件IO只需用到5个函数：<code>open</code>、<code>read</code>、<code>write</code>、<code>lseek</code>以及<code>close</code>。本文将分别讨论以上函数的作用以及不同缓冲长度对<code>read</code>和<code>write</code>函数的影响。</p>
<p>&emsp;&emsp;本文描述的函数经常被称为不带缓冲的IO，也就是每个<code>read</code>和<code>write</code>都调用内核中的一个系统调用。这些不带缓冲的IO函数不是<code>ISO C</code>的组成部分，但是，它们是<code>POSIX.1</code>和<code>Single UNIX Specification</code>的组成部分。</p>
<a id="more"></a>

<h1 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h1><p>&emsp;&emsp;对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读、写一个文件时，使用<code>open</code>或<code>create</code>返回的文件描述符标识该文件，将其作为参数传送给<code>read</code>或<code>write</code>。</p>
<p>&emsp;&emsp;按照惯例，<code>UNIX</code>系统<code>shell</code>把文件描述符0与进程的标准输入关联，文件描述符1与标准输出关联，文件描述符2与标准错误关联。这是各种<code>shell</code>以及很多应用程序使用的惯例，与UNIX内核无关。尽管如此，如果不遵循这种惯例，很多<code>UNIX</code>系统应用程序就不能正常工作。</p>
<p>&emsp;&emsp;在符合<code>POSIX.1</code>的应用程序中，幻数0、1、2虽然已经被标准化，但应当把它们替换成符号常量<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>以提高可读性。这些常量都定义在头文件<code>&lt;unistd.h&gt;</code>中。</p>
<p>&emsp;&emsp;文件描述符的变化范围是<code>0～OPEN_MAX-1</code>。早期的UNIX系统实现采用的上限是19（允许进程最多打开20个文件），但现在很多系统将其上限值增至63。</p>
<blockquote>
<p>对于<code>FreeBSD 8.0</code>、<code>Linux 3.2.0</code>、<code>MacOS X 10.6.8</code>来说，文件描述符的变化范围几乎是无限的。它只受到系统配置的存储器总量、整型的字长以及系统管理员所配置的软限制和硬限制的约束。</p>
</blockquote>
<h1 id="函数open和openat"><a href="#函数open和openat" class="headerlink" title="函数open和openat"></a>函数open和openat</h1><p>&emsp;&emsp;调用<code>open</code>和<code>openat</code>函数可以打开或创建一个文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两函数的返回值：若成功，返回文件描述符；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们将最后一个参数写为<code>...</code>，<code>ISO C</code>用这种方法表明余下的参数的数量及其类型是可变的。对于<code>open</code>函数而言，仅当创建新文件时才使用最后这个参数。在函数原型中将此参数放置在注释中。</p>
<p>&emsp;&emsp;<code>path</code>参数是要打开或创建文件的名字。<code>oflag</code>参数可用来说明此函数的多个选项。用下列一个或多个常量进行“或”运算构成<code>oflag</code>参数（这些常量在头文件<code>&lt;fcntl.h&gt;</code>中定义）。</p>
<ul>
<li><code>O_RDONLY</code>：只读打开。</li>
<li><code>O_WRONLY</code>：只写打开。</li>
<li><code>O_RDWR</code>：读、写打开。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;大多数实现将<code>O_RDONLY</code>定义为0，<code>O_WRONLY</code>定义为1，<code>O_RDWR</code>定义为2，以与早期的程序兼容。</p>
</blockquote>
<ul>
<li><code>O_EXEC</code>：只执行打开。</li>
<li><code>O_SEARCH</code>：只搜索打开（应用于目录）。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;<code>O_SEARCH</code>常量的目的在于在目录打开时验证它的搜索权限。对目录的文件描述符的后续操作就不需要再次检查对该目录的搜索权限。但目前大部分操作系统都不支持<code>O_SEARCH</code>。即使通过<code>man</code>命令也搜索不到。</p>
</blockquote>
<p>&emsp;&emsp;在前三个常量中必须指定一个且只能指定一个。下列常量则是可选的。</p>
<ul>
<li><code>O_APPEND</code>：每次写时都追加到文件的尾端。</li>
<li><code>O_CLOEXEC</code>：把<code>FD_CLOEXEC</code>常量设置为文件描述符标志。</li>
<li><code>O_CREAT</code>：若此文件不存在则创建它。使用此选项时，<code>open</code>函数需同时说明第三个参数<code>mode</code>（<code>openat</code>函数需说明第四个参数<code>mode</code>），用<code>mode</code>指定该新文件的访问权限位。</li>
<li><code>O_DIRECTORY</code>：如果<code>path</code>引用的不是目录，则出错。</li>
<li><code>O_EXCL</code>：如果同时指定了<code>O_CREAT</code>，而文件已经存在，则出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建两者成为一个原子操作。</li>
<li><code>O_NOCTTY</code>：如果<code>path</code>引用的是终端设备，则不将该设备分配作为此进程的控制终端。</li>
<li><code>O_NOFOLLOW</code>：如果<code>path</code>引用的是一个符号链接，则出错。</li>
<li><code>O_NONBLOCK</code>：如果<code>path</code>引用的是一个<code>FIFO</code>、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的<code>I/O</code>操作设置为非阻塞方式。</li>
<li><code>O_SYNC</code>：使每次<code>write</code>等待物理<code>I/O</code>操作完成，包括由该<code>write</code>操作引起的文件属性更新所需的<code>I/O</code>。</li>
<li><code>O_TRUNC</code>：如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0。</li>
<li><code>O_TTY_INIT</code>：如果打开一个还未打开的终端设备，设置非标准<code>terminos</code>参数值，使其符合<code>Single UNIX Specification</code>。</li>
</ul>
<p>&emsp;&emsp;由<code>open</code>和<code>openat</code>函数返回的文件描述符一定是最小的未用描述符数值。这点被某些应用程序用来在标准输入、标准输出或标准错误上打开新的文件。例如，一个应用程序可以先关闭标准输出（通常是文件描述符1），然后再打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。<code>dup2</code>函数可以更好的来保证在一个给定的描述符上打开一个文件。</p>
<p>&emsp;&emsp;<code>fd</code>参数把<code>open</code>和<code>openat</code>函数区分开来，共有三种可能性。</p>
<ol>
<li><code>path</code>参数指定的是绝对路径名，在这种情况下，<code>fd</code>参数被忽略，<code>openat</code>函数就相当于<code>open</code>函数。</li>
<li><code>path</code>参数指定的是相对路径名，<code>fd</code>参数指出了相对路径名在文件系统中的开始地址。<code>fd</code>参数是通过打开相对路径名所在的目录来获取的。</li>
<li><code>path</code>参数指定了相对路径名，<code>fd</code>参数具有特殊值<code>AT_FDCWD</code>。在这种情况下，路径名在当前工作目录中获取，<code>openat</code>函数在操作上与<code>open</code>函数类似。</li>
</ol>
<h2 id="文件名和路径名截断"><a href="#文件名和路径名截断" class="headerlink" title="文件名和路径名截断"></a>文件名和路径名截断</h2><p>&emsp;&emsp;如果<code>NAME_MAX</code>是14，而我们却试图在当前目录创建一个文件名包含15个字符的新文件，此时会发生什么呢？按照传统，早期的<code>System V</code>版本（如<code>SVR2</code>）允许这种使用方法，但总是将文件名截断为14个字符，而且不给出任何信息，而<code>BSD</code>类的系统则返回出错状态，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。无声无息地截断文件名会引起问题，而且它不仅仅影响到创建新文件。如果<code>NAME_MAX</code>是14，而存在一个文件名恰好就是14个字符的文件，那么以路径名作为其参数的任一函数都无法确定该文件的原始名是什么。其原因就是这些函数无法判断该文件名是否被截断过。</p>
<p>&emsp;&emsp;在<code>POSIX.1</code>中，常量<code>_POSIX_NO_TRUNC</code>决定是要截断过长的文件名或路径名，还是返回一个出错。</p>
<p>&emsp;&emsp;若<code>_POSIX_NO_TRUNC</code>有效，则在整个路径名超过<code>PATH_MAX</code>，或路径名中的任一文件名超过<code>NAME_MAX</code>时，出错返回，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。</p>
<blockquote>
<p>&emsp;&emsp;大多数现代文件系统支持文件名的最大长度可以为255。因为文件名通常比这个限制要短，因此对大多数应用程序来说这个限制还未出现什么问题。</p>
</blockquote>
<h1 id="函数create"><a href="#函数create" class="headerlink" title="函数create"></a>函数create</h1><p>&emsp;&emsp;也可调用<code>create</code>函数创建一个新文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回为只写打开的文件描述符；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此函数等效于：<code>open(path, O_WRONLY | O_CREAT | O_TRUNC, mode)</code>。</p>
<h1 id="函数close"><a href="#函数close" class="headerlink" title="函数close"></a>函数close</h1><p>&emsp;&emsp;可调用<code>close</code>函数关闭一个打开文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关闭一个文件时还会释放该进程加在该文件上的所有记录锁。</p>
<p>&emsp;&emsp;当一个进程终止时，内核自动关闭它所有的打开文件。很多程序都利用了这一功能而不显式地用<code>close</code>关闭打开文件。</p>
<h1 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h1><p>&emsp;&emsp;每个打开文件都有一个与其相关联的“当前文件偏移量”（<code>current file offset</code>）。它通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。按系统默认的情况，当打开一个文件时，除非指定<code>O_APPEND</code>选项，否则该偏移量被设置为0。</p>
<p>&emsp;&emsp;可以调用<code>lseek</code>显式地为一个打开文件设置偏移量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回新的文件偏移量；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对参数<code>offset</code>的解释与参数<code>whence</code>的值有关。</p>
<ul>
<li>若<code>whence</code>是<code>SEEK_SET</code>，则将该文件的偏移量设置为距文件开始处<code>offset</code>个字节。</li>
<li>若<code>whence</code>是<code>SEEK_CUR</code>，则将该文件的偏移量设置为其当前值加<code>offset</code>，<code>offset</code>可为正或负。</li>
<li>若<code>whence</code>是<code>SEEK_END</code>，则将该文件的偏移量设置为文件长度加<code>offset</code>，<code>offset</code>可为正或负。</li>
</ul>
<p>&emsp;&emsp;若<code>lseek</code>成功执行，则返回新的文件偏移量，可以用下列方法确定打开文件的当前偏移量：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">off_t</span> current_pos;</span><br><span class="line">current_pos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;用这种方法也可用来确定所涉及的文件是否可以设置偏移量。如果文件描述符指向的是一个管道、<code>FIFO</code>或网络套接字，则<code>lseek</code>返回-1，并将<code>errno</code>设置为<code>ESPIPE</code>。</p>
<p>&emsp;&emsp;文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。</p>
<p>&emsp;&emsp;文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超出文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。</p>
<blockquote>
<p>&emsp;&emsp;尽管可以实现64位文件偏移量，但是能否创建一个大于2GB（2^31 - 1字节）的文件则依赖于底层文件系统的类型。</p>
</blockquote>
<h1 id="函数read"><a href="#函数read" class="headerlink" title="函数read"></a>函数read</h1><p>&emsp;&emsp;调用<code>read</code>函数从打开文件中读数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如<code>read</code>成功，则返回读到的字节数。如已到达文件的尾端，则返回0。</p>
<p>&emsp;&emsp;有多种情况可使实际读到的字节数少于要求读的字节数：</p>
<ul>
<li>读普通文件时，在读到要求字节数之前已到达了文件尾端。例如，若在到达文件尾端之前有30个字节，而要求读100个字节，则<code>read</code>返回30。下一次再调用<code>read</code>时，它将返回0（文件尾端）。</li>
<li>当从终端设备读时，通常一次最多读一行。</li>
<li>当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。</li>
<li>当从管道或<code>FIFO</code>读时，如若管道包含的字节小于所需的数量，那么<code>read</code>将只返回实际可用的字节数。</li>
</ul>
<p>&emsp;&emsp;读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数。<code>POSIX.1</code>从几个方面对<code>read</code>函数的原型做了更改。经典的原型定义是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* buf, <span class="keyword">unsigned</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，为了与<code>ISO C</code>一致，第二个参数由<code>char*</code>改为<code>void*</code>。在<code>ISO C</code>中，类型<code>void*</code>用于表示通用指针。</li>
<li>其次，返回值必须是一个带符号整型（<code>ssize_t</code>），以保证能够返回正整数字节数、0（表示文件尾端）或-1（出错）。</li>
</ul>
<h1 id="函数write"><a href="#函数write" class="headerlink" title="函数write"></a>函数write</h1><p>&emsp;&emsp;调用<code>write</code>函数向打开文件写数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回已写的字节数；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> coid* buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其返回值通常与参数<code>nbytes</code>相同，否则表示出错。<code>write</code>出错的一个常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制。</p>
<p>&emsp;&emsp;对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时，指定了<code>O_APPEND</code>选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。</p>
<h1 id="IO效率"><a href="#IO效率" class="headerlink" title="IO效率"></a>IO效率</h1><p>&emsp;&emsp;以下程序只使用<code>read</code>和<code>write</code>函数复制一个文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incldue <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>((n = <span class="built_in">read</span>(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != n) &#123;</span><br><span class="line">            ERR_SYS(<span class="string">"write error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_SYS(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于该程序应注意以下几点。</p>
<ul>
<li>它从标准输入读，写至标准输出，这就假定在执行本程序之前，这些标准输入、标准输出已由<code>shell</code>安排好。确实，所有常用的<code>UNIX</code>系统<code>shell</code>都提供一种方法，它在标准输入上打开一个文件用于读，在标准输出上创建（或重写）一个文件。这使得程序不必打开输入和输出文件，并允许用户利用<code>shell</code>的<code>I/O</code>重定向功能。</li>
<li>考虑到进程终止时，<code>UNIX</code>系统内核会关闭进程的所有打开的文件描述符，所以此程序并不关闭输入和输出文件。</li>
<li>对<code>UNIX</code>系统内核而言，文本文件和二进制代码文件并无区别，所以本程序对这两种文件都有效。</li>
</ul>
<p>&emsp;&emsp;最后的问题就是关于如何选取<code>BUFFSIZE</code>值。在回答此问题之前，先让我们用各种不同的<code>BUFFSIZE</code>值来运行此程序。下图显示了用20种不同的缓冲区长度，读516581760字节的文件所得到的结果。</p>
<p>&emsp;&emsp;用以上程序读文件，其标准输出被重新定向到<code>/dev/null</code>上。此测试所用的文件系统是<code>Linux ext4</code>文件系统，其磁盘块长度为4096字节（磁盘块长度由<code>st_blksize</code>表示）。这也证明了下图中系统<code>CPU</code>时间的几个最小值差不多出现在<code>BUFFSIZE</code>为4096及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/UNIX%E6%96%87%E4%BB%B6IO/Linux%E4%B8%8A%E7%94%A8%E4%B8%8D%E5%90%8C%E7%BC%93%E5%86%B2%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%AF%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E7%BB%93%E6%9E%9C.png" alt="Linux上用不同缓冲长度进行读操作的时间结果"></p>
<p>&emsp;&emsp;大多数文件系统为改善性能都采用某种预读技术。当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据，并假想应用很快就会读这些数据。预读的效果可以从上图看出，缓冲区长度小至32字节时的时钟时间与拥有较大缓冲区长度的时钟时间几乎一样。</p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>UNIX文件</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX文件IO（三）</title>
    <url>/2021/12/16/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="函数sync、fsync和fdatasync"><a href="#函数sync、fsync和fdatasync" class="headerlink" title="函数sync、fsync和fdatasync"></a>函数sync、fsync和fdatasync</h1><p>&emsp;&emsp;传统的<code>UNIX</code>系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘<code>I/O</code>都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式被称为延迟写。</p>
<p>&emsp;&emsp;通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上实际文件系统与缓冲区中内容的一致性，<code>UNIX</code>系统提供了<code>sync</code>、<code>fsync</code>和<code>fdatasync</code>三个函数。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>sync</code>只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。</p>
<p>&emsp;&emsp;通常，称为<code>update</code>的系统守护进程周期性地调用（一般每隔30秒）<code>sync</code>函数。这就保证了定期冲洗（<code>flush</code>）内核的块缓冲区。命令<code>sync(1)</code>也调用<code>sync</code>函数。</p>
<p>&emsp;&emsp;<code>fsync</code>函数只对由文件描述符<code>fd</code>指定的一个文件起作用，并且等待写磁盘操作结束才返回。<code>fsync</code>可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。</p>
<p>&emsp;&emsp;<code>fdatasync</code>函数类似于<code>fsync</code>，但它只影响文件的数据部分。而除数据外，<code>fsync</code>还会同步更新文件的属性。</p>
<h1 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h1><p>&emsp;&emsp;<code>fcntl</code>函数可以改变已经打开文件的属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fctnl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，则依赖于cmd；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在以下各个实例中，第3个参数总是一个整数，与上面所示函数原型中的注释部分对应。需要注意的是，该参数亦可以是指向一个结构的指针。</p>
<p>&emsp;&emsp;<code>fcntl</code>函数有以下5种功能。</p>
<ul>
<li>复制一个已有的描述符（<code>cmd = F_DUPFD 或 F_DUPFD_CLOEXEC</code>）。</li>
<li>获取／设置文件描述符标志（<code>cmd = F_GETFD 或 F_SETFD</code>）。</li>
<li>获取／设置文件状态标志（<code>cmd = F_GETFL 或 F_SETFL</code>）。</li>
<li>获取／设置异步<code>I/O</code>所有权（<code>cmd = F_GETOWN 或 F_SETOWN</code>）。</li>
<li>获取／设置记录锁（<code>cmd = F_GETLK、F_SETLK 或 F_SETLKW</code>）。</li>
</ul>
<p>&emsp;&emsp;本系列博客先说明这11种<code>cmd</code>中的前8种（后3种与记录锁有关）。以下将讨论与进程表项中各文件描述符相关联的文件描述符标志以及每个文件表项中的文件状态标志。</p>
<ul>
<li><code>F_DUPFD</code>：复制文件描述符<code>fd</code>。新文件描述符作为函数值返回。它是尚未打开的各描述符中大于或等于第三个参数值（取为整型值）中各值的最小值。新描述符与<code>fd</code>共享同一文件表项。但是，新文件描述符有它自己的一套文件描述符标志，其<code>FD_CLOEXEC</code>文件描述符标志被清除（这表示该描述符在<code>exec</code>时仍保持有效）。</li>
<li><code>F_DUPFD_CLOEXEC</code>：复制文件描述符<code>fd</code>，设置与新描述符关联的<code>FD_CLOEXEC</code>文件描述符标志，返回新文件描述符。</li>
<li><code>F_GETFD</code>：对应于<code>fd</code>的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志<code>FD_CLOEXEC</code>。</li>
<li><code>F_SETFD</code>：对<code>fd</code>设置文件描述符标志。新标志值按第3个参数设置。</li>
</ul>
<blockquote>
<p>&emsp;&emsp;要知道，很多现有的与文件描述符标志有关的程序并不使用常量<code>FD_CLOEXEC</code>，而是将此标志设置为0（系统默认，在<code>exec</code>时不关闭）或1（在<code>exec</code>时关闭）。</p>
</blockquote>
<ul>
<li><code>F_GETFL</code>：对应于<code>fd</code>的文件状态标志作为函数值返回。本系列博客在说明<code>open</code>函数时（具体见“<strong><a href="/2021/12/08/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%B8%80%EF%BC%89/" title="UNIX文件IO（一）">UNIX文件IO（一）</a></strong>”），已描述了文件状态标志。如下表所示。</li>
</ul>
<table>
<thead>
<tr>
<th>文件状态标志</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>O_RDONLY</code></td>
<td>只读打开</td>
</tr>
<tr>
<td><code>O_WRONLY</code></td>
<td>只写打开</td>
</tr>
<tr>
<td><code>O_RDWR</code></td>
<td>读、写打开</td>
</tr>
<tr>
<td><code>O_EXEC</code></td>
<td>只执行打开</td>
</tr>
<tr>
<td><code>O_SEARCH</code></td>
<td>只搜索打开目录</td>
</tr>
<tr>
<td><code>O_APPEND</code></td>
<td>追加写</td>
</tr>
<tr>
<td><code>O_NONBLOCK</code></td>
<td>非阻塞模式</td>
</tr>
<tr>
<td><code>O_SYNC</code></td>
<td>等待写完成（数据和属性）</td>
</tr>
<tr>
<td><code>O_DSYNC</code></td>
<td>等待写完成（仅数据）</td>
</tr>
<tr>
<td><code>O_RSYNC</code></td>
<td>同步读和写</td>
</tr>
<tr>
<td><code>O_FSYNC</code></td>
<td>等待写完成（仅<code>FreeBSD</code>和<code>Mac OS X</code>）</td>
</tr>
<tr>
<td><code>O_ASYNC</code></td>
<td>异步<code>I/O</code>（仅<code>FressBSD</code>和<code>Mac OS X</code>）</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;遗憾的是，5个访问方式标志（前5个）并不各占1位（如前所述，由于历史原因，前3个标志的值分别是0、1和2。这5个值互斥，一个文件的访问方式只能取这5个值之一）。因此首先必须用屏蔽字<code>O_ACCMODE</code>取得访问方式位，然后将结果与这5个值中的每一个相比较。</p>
<ul>
<li><code>F_SETFL</code>：将文件状态标志设置为第3个参数的值。可以更改的标志为上表的后7个。</li>
<li><code>F_GETOWN</code>：获取当前接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程<code>ID</code>或进程组<code>ID</code>。</li>
<li><code>F_SETOWN</code>：设置接收<code>SIGIO</code>和<code>SIGURG</code>信号的进程<code>ID</code>或进程组<code>ID</code>。正的<code>arg</code>指定一个进程<code>ID</code>，负的<code>arg</code>表示等于<code>arg</code>绝对值的一个进程组<code>ID</code>。</li>
</ul>
<p>&emsp;&emsp;<code>fcntl</code>的返回值与命令有关。如果出错，所有命令都返回-1，如果成功则返回某个其他值。</p>
<p>&emsp;&emsp;下列代码所示程序的第1个参数指定文件描述符，并对于该描述符打印其所选择的文件标志说明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        ERR_QUIT(<span class="string">"usage: a.out &lt;descriptor#&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>((val = fcntl(atoi(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_SYS(<span class="string">"fcntl error for fd %d"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">switch</span>(val &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read only"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write only"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read write"</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ERR_DUMP(<span class="string">"unoknown access mode"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_APPEND) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", append"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_NONBLOCK) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", nonblocking"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val &amp; O_SYNC) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> !<span class="meta-keyword">define</span>(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span></span><br><span class="line">        <span class="keyword">if</span>(val &amp; O_FSYNC)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在修改文件描述符标志或文件状态标志时必须谨慎，先要获得现在的标志值，然后按照期望修改它，最后设置新标志值。不能只是执行<code>F_SETFD</code>或<code>F_SETFL</code>命令，这样会关闭以前设置的标志位。</p>
<p>&emsp;&emsp;下列代码是对于一个文件描述符设置一个或多个文件状态标志的函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flags are file statues flags to turn on.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_SYS(<span class="string">"fcntl F_GETFL error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// turn on flags.</span></span><br><span class="line">    val |= flags;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERR_SYS(<span class="string">"fcntl F_SETFL error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果将中间的一条语句改为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// turn off flags.</span></span><br><span class="line">val &amp;= ~flags;</span><br></pre></td></tr></table></figure>

<p>就构成另一个函数，称之为<code>clr_fl</code>（该函数将在之后的例子中用到）。</p>
<p>&emsp;&emsp;如果在每次<code>write</code>前加上以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set_fl(STDOUT_FILENO, O_SYNC);</span><br></pre></td></tr></table></figure>

<p>这就使得每次<code>write</code>都要等待，直至数据已写到磁盘上再返回。在<code>UNIX</code>系统中，通常<code>write</code>只是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。数据库系统则需要使用<code>O_SYNC</code>，这样一来，当它从<code>write</code>返回时就知道数据已确实写到了磁盘上，以免在系统异常时产生数据丢失。</p>
<h1 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h1><p>&emsp;&emsp;较新的系统都提供名为<code>/dev/fd</code>的目录，其目录项是名为0、1、2等的文件。打开<code>/dev/fd/n</code>等效于复制描述符<code>n</code>（假定描述符<code>n</code>是打开的）。</p>
<blockquote>
<p>&emsp;&emsp;<code>dev/fd</code>这一功能是由<code>Tom Duff</code>开发的，它首先出现在<code>Research UNIX</code>系统的第8版中，本系列博客说明的所有4种系统（<code>FreeBSD 8.0</code>、<code>Linux 3.2.0</code>、<code>Mac OS X 10.6.8</code>和<code>Solaris 10</code>）都支持这一功能。它不是<code>POSIX.1</code>的组成部分。</p>
</blockquote>
<p>&emsp;&emsp;在下列函数调用中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"/dev/fd/0"</span>, mode);</span><br></pre></td></tr></table></figure>

<p>大多数系统忽略它所指定的<code>mode</code>，而另一些系统则要求<code>mode</code>必须是所引用的文件（在这里是标准输入）初始打开时所使用的打开模式的一个子集。因为上面的打开等效于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所以描述符0和<code>fd</code>共享同一文件表项。例如，若描述符0先前被打开为只读，那么我们也只能对<code>fd</code>进行读操作。即使系统忽略打开模式，而且下列调用是成功的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fd = <span class="built_in">open</span>(<span class="string">"/dev/fd/0"</span>, O_RDWR);</span><br></pre></td></tr></table></figure>

<p>我们仍然不能对<code>fd</code>进行写操作。</p>
<blockquote>
<p>&emsp;&emsp;<code>Linux</code>实现中的<code>/dev/fd</code>是个例外。它把文件描述符映射成指向底层物理文件的符号链接。例如，当打开<code>/dev/fd/0</code>时，事实上正在打开与标准输入关联的文件，因此返回的新文件描述符的模式与<code>/dev/fd</code>文件描述符的模式其实并不相关。</p>
</blockquote>
<p>&emsp;&emsp;也可以用<code>/dev/fd</code>作为路径名参数调用<code>create</code>，这与调用<code>open</code>时用<code>O_CREAT</code>作为第2个参数作用相同。例如，若一个程序调用<code>create</code>，并且路径名参数是<code>/dev/fd/1</code>，那么该程序仍能工作。</p>
<blockquote>
<p>&emsp;&emsp;注意，在<code>Linux</code>上这么做必须非常小心。因为<code>Linux</code>实现使用指向实际文件的符号链接，在<code>/dev/fd</code>文件上使用<code>create</code>会导致底层文件被截断。</p>
</blockquote>
<p>&emsp;&emsp;某些系统提供路径名<code>/dev/stdin</code>、<code>/dev/stdout</code>和<code>/dev/stderr</code>，这些等效于<code>/dev/fd/0</code>、<code>/dev/fd/1</code>和<code>/dev/fd/2</code>。</p>
<p>&emsp;&emsp;<code>/dev/fd</code>文件主要由<code>shell</code>使用，它允许使用路径名作为调用参数的程序，能用处理其他路径名的相同方式处理标准输入和输出。</p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>UNIX文件</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX标准IO库之缓冲区</title>
    <url>/2021/12/22/UNIX%E6%A0%87%E5%87%86IO%E5%BA%93%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;本文讲述标准<code>I/O</code>库。不仅仅是<code>UNIX</code>，很多其他操作系统都实现了标准<code>I/O</code>库，所以这个库由<code>ISO C</code>标准说明。<code>Single UNIX Specification</code>对<code>ISO C</code>标准进行了扩充，定义了另外一些接口。</p>
<p>&emsp;&emsp;标准<code>I/O</code>库处理很多细节，如缓冲区分配、以及优化的块长度执行<code>I/O</code>等。这些处理使用户不必担心如何选择使用正确的块长度。这使得它便于用户使用，但是如果我们不深入地了解<code>I/O</code>库函数的操作，也会带来一些问题。</p>
<a id="more"></a>

<blockquote>
<p>&emsp;&emsp;标准<code>I/O</code>库是由<code>Dennis Ritchie</code>在1975年左右编写的。它是<code>Mike Lesk</code>编写的可移植<code>I/O</code>库的主要修改版本。令人惊讶的是，35年来，几乎没有对标准<code>I/O</code>库进行修改。</p>
</blockquote>
<h1 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h1><p>&emsp;&emsp;在“<a href="/2021/12/08/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%B8%80%EF%BC%89/" title="UNIX文件IO（一）">UNIX文件IO（一）</a>”等系列博客中，所有<code>I/O</code>函数都是围绕文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的<code>I/O</code>操作。而对于标准<code>I/O</code>库，它们的操作时围绕流进行的。当用标准<code>I/O</code>库打开或创建一个文件时，我们已使一个流与一个文件相关联。</p>
<p>&emsp;&emsp;对于<code>ASCII</code>字符集，一个字符用一个字节表示。对于国际字符集，一个字符可用多个字节表示。标准<code>I/O</code>文件流可用于单字节或多字节（“宽”）字符集。流的定向决定了读、写的字符是单字节还是多字节（“宽”）的。当一个流最初被创建时，它并没有定向。如若在未定向的流上使用一个多字节<code>I/O</code>函数，则将该流的定向设置为宽定向。如若在未定向的流上使用一个单字节<code>I/O</code>函数，则将该流的定向设为字节定向的。只有两个函数可以改变流的定向。<code>freopen</code>函数清除一个流的定向；<code>fwide</code>函数可用于设置流的定向。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流是未定向的，返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE* fp, <span class="keyword">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;根据<code>mode</code>参数的不同值，<code>fwide</code>函数执行不同的工作。</p>
<ul>
<li>如若<code>mode</code>参数值为负，<code>fwide</code>将试图使指定的流是字节定向的。</li>
<li>如若<code>mode</code>参数值为正，<code>fwide</code>将试图使指定的流是宽定向的。</li>
<li>如若<code>mode</code>参数值为0，<code>fwide</code>将不试图设置流的定向，但返回标识该流定向的值。</li>
</ul>
<p>&emsp;&emsp;注意，<code>fwide</code>并不改变已定向流的定向。还应注意的是<code>fwide</code>无出错返回。试想，如若流是无效的，那么将发生什么呢？我们唯一可依靠的是，在调用<code>fwide</code>前先清除<code>errno</code>，从<code>fwide</code>返回时检查<code>errno</code>的值。在本文中，只涉及字节定向流。</p>
<p>&emsp;&emsp;当打开一个流时，标准<code>I/O</code>函数<code>fopen</code>返回一个指向<code>FILE</code>对象的指针。该对象通常是一个结构，它包含了标准<code>I/O</code>库为管理该流所需要的所有信息，包括用于实际<code>I/O</code>的文件描述符、指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数和出错标志等。</p>
<p>&emsp;&emsp;应用程序没有必要检验<code>FILE</code>对象。为了引用一个流，需将<code>FILE</code>指针作为参数传递给每个标准<code>I/O</code>函数。在本文中，称指向<code>FILE</code>对象的指针（类型为<code>FILE*</code>）为文件指针。</p>
<h1 id="标准输入、标准输出和标准错误"><a href="#标准输入、标准输出和标准错误" class="headerlink" title="标准输入、标准输出和标准错误"></a>标准输入、标准输出和标准错误</h1><p>&emsp;&emsp;对一个进程预定义了了3个流，并且这3个流可以自动地被进程使用，它们是：标准输入、标准输出和标准错误。这些流引用的文件与“<a href="/2021/12/08/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%B8%80%EF%BC%89/" title="UNIX文件IO（一）">UNIX文件IO（一）</a>”一文提到的文件描述符<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>所引用的相同。</p>
<p>&emsp;&emsp;这3个标准<code>I/O</code>流通过预定义文件指针<code>stdin</code>、<code>stdout</code>和<code>stderr</code>加以引用。这3个文件指针定义在头文件<code>&lt;stdio.h&gt;</code>。</p>
<h1 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h1><p>&emsp;&emsp;标准<code>I/O</code>库提供缓冲的目的是尽可能低减少使用<code>read</code>和<code>write</code>调用的次数（见“<a href="/2021/12/08/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%B8%80%EF%BC%89/" title="UNIX文件IO（一）">UNIX文件IO（一）</a>”一文中就讨论了在不同缓冲区长度下，执行<code>I/O</code>所需的<code>CPU</code>时间量）。它也对每个<code>I/O</code>流自动地进行缓冲管理，从而避免了应用程序需要考虑这一点所带来的麻烦。遗憾的是，标准<code>I/O</code>库最令人迷惑的也是它的缓冲。</p>
<p>&emsp;&emsp;标准<code>I/O</code>提供了以下3种类型的缓冲。</p>
<ul>
<li>全缓冲。在这种情况下，在填满标准<code>I/O</code>缓冲区后才进行实际<code>I/O</code>操作。对于驻留在磁盘上的文件通常是由标准<code>I/O</code>库实施全缓冲的。在一个流上执行第一次<code>I/O</code>操作时，相关标准<code>I/O</code>函数通常调用<code>malloc</code>获得需使用的缓冲区。</li>
</ul>
<p>&emsp;&emsp;术语冲洗（<code>flush</code>）说明标准<code>I/O</code>缓冲区的写操作。缓冲区可由标准<code>I/O</code>例程自动地冲洗（例如，当填满一个缓冲区时），或者可以调用函数<code>fflush</code>冲洗一个流。值得注意的是，在<code>UNIX</code>环境中，<code>flush</code>有两种意思。在标准<code>I/O</code>库方面，<code>flush</code>意味着将缓冲区中的内容写到磁盘上（该缓冲区可能只是部分填满的）。在终端驱动程序方面，<code>flush</code>表示丢弃已存储在缓冲区中的数据。</p>
<ul>
<li>行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准<code>I/O</code>库执行<code>I/O</code>操作。这允许我们一次输出一个字符（用标准<code>I/O</code>函数<code>fputc</code>），但只有在写一行之后才进行实际<code>I/O</code>操作。当流涉及一个终端时（如标准输入和标准输出），通常使用行缓冲。</li>
</ul>
<p>&emsp;&emsp;对于行缓冲有两个限制。第一，因为标准<code>I/O</code>库用来收集每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行<code>I/O</code>操作。第二，任何时候只要通过标准<code>I/O</code>库要求从（a）一个不带缓冲的流，或者（b）一个行缓冲的流（它从内核请求需要数据）得到输入数据，那么就会冲洗所有行缓冲输出流。在（b）中带了一个在括号中的说明，其理由是，所需的数据可能已在该缓冲区中，它并不要求一定从内核读数据。很明显，从一个不带缓冲的流中输入（即（a）项）需要从内核获得数据。</p>
<ul>
<li>不带缓冲。标准<code>I/O</code>库不对字符进行缓冲存储。例如，若用标准<code>I/O</code>函数<code>fputs</code>写15个字符到不带缓冲的流中，我们就期望这15个字符能立即输出，很可能使用<code>write</code>函数将这些字符写到相关联的打开文件中。</li>
</ul>
<p>&emsp;&emsp;标准错误流<code>stderr</code>通常是不带缓冲的，这就使得出错信息可以尽快地显示出来，而不管它们是否含有一个换行符。</p>
<p>&emsp;&emsp;<code>ISO C</code>要求下列缓冲特征。</p>
<ul>
<li>当且仅当标准输入和标准输出并不指向交互设备时，它们才是全缓冲的。</li>
<li>标准错误绝不会是全缓冲的。</li>
</ul>
<p>&emsp;&emsp;但是，这并没有告诉我们如果标准输入和标准输出指向交互设备时，它们是不带缓冲的还是行缓冲的；以及标准错误是不带缓冲的还是行缓冲的。很多系统默认使用下列类型的缓冲：</p>
<ul>
<li>标准错误是不带缓冲的。</li>
<li>若是指向终端设备的流，则是行缓冲的；否则是全缓冲的。</li>
</ul>
<p>&emsp;&emsp;对任何一个给定的流，如果我们并不喜欢这些系统默认，则可调用下列两个函数中的一个更改缓冲类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回非0。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些函数一定要在流已被打开后调用（这是十分明显，因为每个函数都要求一个有效的文件指针作为它们的第一个参数），而且也应在对该流执行任何一个其他操作之前调用。</p>
<p>&emsp;&emsp;可以使用<code>setbuf</code>函数打开或关闭缓冲机制。为了带缓冲进行<code>I/O</code>，参数<code>buf</code>必须指向一个长度为<code>BUFSIZE</code>的缓冲区（该常量定义在<code>&lt;stdio.h&gt;</code>中）。通常在此之后该流就是全缓冲的，但是如果该流与一个终端设备相关，那么某些系统也可将其设置为行缓冲的。为了关闭缓冲，将<code>buf</code>设置为<code>NULL</code>。</p>
<p>&emsp;&emsp;使用<code>setvbuf</code>，我们可以精确地说明所需的缓冲类型。这是用<code>mode</code>参数实现的：</p>
<ul>
<li><code>_IOFBF</code>，全缓冲。</li>
<li><code>_IOLBF</code>，行缓冲。</li>
<li><code>_IONBF</code>，不带缓冲。</li>
</ul>
<p>&emsp;&emsp;如果指定一个不带缓冲的流，则忽略<code>buf</code>和<code>size</code>参数。如果指定全缓冲或行缓冲，则<code>buf</code>和<code>size</code>可选择地指定一个缓冲区及其长度。如果指定全缓冲或行缓冲，则<code>buf</code>和<code>size</code>可选择地指定一个缓冲区及其长度。如果该流是带缓冲的，而<code>buf</code>是<code>NULL</code>，则标准<code>I/O</code>库将自动地为该流分配适当长度的缓冲区。适当的长度指的是由常量<code>BUFFSIZ</code>所指定的值。</p>
<blockquote>
<p>&emsp;&emsp;某些<code>C</code>函数库实现使用<code>stat</code>结构中的成员<code>st_blksize</code>所指定的值决定最佳<code>I/O</code>缓冲区长度。<code>GNU C</code>函数库就使用这种办法。</p>
</blockquote>
<p>&emsp;&emsp;下表列出了这两个函数的动作，以及它们的各个选项。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th><code>mode</code></th>
<th><code>buf</code></th>
<th>缓冲区及长度</th>
<th>缓冲类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>setbuf</code></td>
<td></td>
<td>非空</td>
<td>长度为<code>BUFSIZ</code>的用户缓冲区<code>buf</code></td>
<td>全缓冲或行缓冲</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>NULL</code></td>
<td>（无缓冲区）</td>
<td>不带缓冲</td>
</tr>
<tr>
<td><code>setvbuf</code></td>
<td><code>_IO_FBF</code></td>
<td>非空</td>
<td>长度为<code>size</code>的用户缓冲区<code>buf</code></td>
<td>全缓冲</td>
</tr>
<tr>
<td></td>
<td><code>_IO_FBF</code></td>
<td><code>NULL</code></td>
<td>适合长度的系统缓冲区<code>buf</code></td>
<td>全缓冲</td>
</tr>
<tr>
<td></td>
<td><code>_IO_LBF</code></td>
<td>非空</td>
<td>长度为<code>size</code>的用户缓冲区<code>buf</code></td>
<td>行缓冲</td>
</tr>
<tr>
<td></td>
<td><code>_IO_LBF</code></td>
<td><code>NULL</code></td>
<td>适合长度的系统缓冲区<code>buf</code></td>
<td>行缓冲</td>
</tr>
<tr>
<td></td>
<td><code>_IO_NBF</code></td>
<td>（忽略）</td>
<td>（无缓冲区）</td>
<td>不带缓冲</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;需要知道的是，如果在一个函数内分配一个自动类型变量类的标准<code>I/O</code>缓冲区，则从该函数返回之前，必须关闭该流。另外，某些实现将缓冲区的一部分用于存放它自己的管理操作信息，所以可以存放在缓冲区中的实际数据字节数少于<code>size</code>。一般而言，应由系统选择缓冲区的长度，并自动地分配缓冲区。在这种情况下关闭此流时，标准<code>I/O</code>库将自动释放缓冲区。</p>
<p>&emsp;&emsp;任何时候，我们都可强制冲洗一个流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回EOF。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此函数使该流所有未写的数据都被传送至内核。作为一种特殊情形，如若<code>fp</code>是<code>NULL</code>，则此函数将导致所有输出流被冲洗。</p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>UNIX标准IO</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX文件IO（二）</title>
    <url>/2021/12/12/UNIX%E6%96%87%E4%BB%B6IO%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h1><p>&emsp;&emsp;UNIX系统支持在不同进程间共享打开文件。在介绍<code>dup</code>函数之前，先要说明这种共享。为此先介绍内核用于所有<code>I/O</code>的数据结构。</p>
<p>&emsp;&emsp;内核使用3种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。</p>
<a id="more"></a>

<ol>
<li>每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与每个文件描述符相关联的是：<ol>
<li>文件描述符标志；</li>
<li>指向一个文件表项的指针。</li>
</ol>
</li>
<li>内核为所有打开文件维持一张文件表。每个文件表项包含：<ol>
<li>文件状态标志（读、写、添写、同步和非阻塞等）；</li>
<li>当前文件偏移量；</li>
<li>指向该文件<code>v</code>节点表项的指针。</li>
</ol>
</li>
<li>每个打开文件（或设备）都有一个<code>v</code>节点结构。<code>v</code>节点包括了文件类型和对此文件进行各种操作函数的指针。对于大多数文件，<code>v</code>节点还包括了该文件的<code>i</code>节点（索引节点）。这些信息是在打开文件时从磁盘上读入内存的，所以，文件的所有相关信息都是随时可用的。例如，<code>i</code>节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。</li>
</ol>
<blockquote>
<p>&emsp;&emsp;<code>Linux</code>没有使用<code>v</code>节点，而是使用了通用<code>i</code>节点结构。虽然两种实现有所不同，但在概念上，<code>v</code>节点和<code>i</code>节点是一样的。两者都指向文件系统特有的<code>i</code>节点结构。</p>
</blockquote>
<p>&emsp;&emsp;本文忽略了那些不影响讨论的实现细节。例如，打开文件描述符表可存放在用户空间（作为一个独立的对应于每个进程的结构，可用换出），而非进程表中。这些表中也可以用多种方式实现，不必一定是数组，例如，可将它们实现为结构的链表。如果不考虑实现细节的话，通用概念是相同的。</p>
<p>&emsp;&emsp;下图显示了一个进程对应的3张表之间的关系。该进程有两个不同的打开文件：一个文件从标准输入打开（文件描述符0），另一个从标准输出打开（文件描述符1）。</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/UNIX%E6%96%87%E4%BB%B6IO/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="打开文件的内核数据结构"></p>
<p>&emsp;&emsp;如果两个独立进程各自打开了同一文件，则有如下图关系。</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/UNIX%E6%96%87%E4%BB%B6IO/%E4%B8%A4%E4%B8%AA%E7%8B%AC%E7%AB%8B%E8%BF%9B%E7%A8%8B%E5%90%84%E8%87%AA%E6%89%93%E5%BC%80%E5%90%8C%E4%B8%80%E6%96%87%E4%BB%B6.png" alt="两个独立进程各自打开同一文件"></p>
<p>&emsp;&emsp;假定第一个进程在文件描述符3上打开该文件，而另一个进程在文件描述符4上打开该文件。打开该文件的每个进程都获得各自的一个文件表项，但对一个给定的文件只有一个<code>v</code>节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使每个进程都有它自己的对该文件的当前偏移量。</p>
<p>&emsp;&emsp;给出了这些数据结构后，现在对前面所述的操作进一步说明。</p>
<ul>
<li>在完成每个<code>write</code>后，在文件表项中的当前文件偏移量即增加所写入的字节数。如果这导致当前文件偏移量超出了当前文件长度，则将<code>i</code>节点表项中的当前文件长度设置为当前文件偏移量（也就是该文件加长了）。</li>
<li>如果用<code>O_APPEND</code>标志打开一个文件，则相应标志也被设置到文件表项的文件状态标志中。每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为<code>i</code>节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。</li>
<li>若一个文件用<code>lseek</code>定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为<code>i</code>节点表项中的当前文件长度（注意，这与用<code>O_APPEND</code>标志打开文件是不同的，见<a href="#原子操作">原子操作</a>）。</li>
<li><code>lseek</code>函数只修改文件表项中的当前文件偏移量，不进行任何<code>I/O</code>操作。</li>
</ul>
<p>&emsp;&emsp;可能有多个文件描述符指向同一文件表项。在讨论<a href="#dup"><code>dup函数</code></a>时，我们就能看到这一点。在<code>fork</code>后也发生同样的情况，此时父进程、子进程各自的每一个打开文件描述符共享同一个文件表项。</p>
<p>&emsp;&emsp;注意，文件描述符标志和文件表项标志在作用范围方面的区别，前者只用于一个进程的一个描述符，而后者则应用于指向该文件表项的任何进程中的所有描述符。在讨论<a href="#fcntl"><code>fcntl函数</code></a>时，将会了解如何获取和修改文件描述符标志和文件状态标志。</p>
<p>&emsp;&emsp;前面所述的一切对于多个进程读取同一文件都能正常工作。每个进程都有它自己的文件表项，其中也有它自己的当前文件偏移量。但是，当多个进程写同一文件时，则可能会产生预想不到的结果。为了说明如何避免这种情况，需要理解原子操作的概念。</p>
<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a><span id="原子操作">原子操作</span></h1><h2 id="追加到一个文件"><a href="#追加到一个文件" class="headerlink" title="追加到一个文件"></a>追加到一个文件</h2><p>&emsp;&emsp;考虑一个进程，它要将数据追加到一个文件尾端。早期的UNIX系统版本并不支持<code>open</code>的<code>O_APPEND</code>选项，所以程序被编写成下列形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(lseek(fd, END_FILE_POS, <span class="number">2</span>) &lt; <span class="number">0</span>) <span class="comment">// position to EOF.</span></span><br><span class="line">    ERR_SYS(<span class="string">"lseek error!"</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">write</span>(fd, buff, <span class="number">100</span>) != <span class="number">100</span>)    <span class="comment">// write.</span></span><br><span class="line">    ERR_SYS(<span class="string">"write error!"</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对单个进程而言，这段程序能正常工作，但若有多个进程同时使用这种方法将数据追加写到同一文件，则会产生问题（例如，若此程序由多个进程同时执行，各自将消息追击到一个日志文件中，就会产生这种情况）。</p>
<p>&emsp;&emsp;假定有两个独立的进程<code>A</code>和<code>B</code>都对同一文件进行追加写操作。每个进程都已打开了该文件，但未使用<code>O_APPEND</code>标志。此时，各数据结构之间的关系如上图所示。每个进程都有它自己的文件表项，但是共享一个<code>v</code>节点表项。假定进程<code>A</code>调用了<code>lseek</code>，它将进程<code>A</code>的该文件当前偏移量设置为1500字节（当前文件尾端处）。然后内核切换进程，进程<code>B</code>运行。进程<code>B</code>执行<code>lseek</code>，也将其对该文件的当前偏移量增加至1600。因为该文件的长度已经增加了，所以内核将<code>v</code>节点中的当前文件长度更新为1600。然后，内核又进行进程切换，使进程<code>A</code>恢复运行。当<code>A</code>调用<code>write</code>时，就从其当前文件偏移量（1500）处开始将数据写入到文件。这样也就覆盖了进程<code>B</code>刚才写入到该文件中的数据。</p>
<p>&emsp;&emsp;问题出在逻辑操作“先定位到文件尾端，然后写”，它使用了两个分开的函数调用。解决方法是使这两个操作对于其他进程而言成为一个原子操作。任何要求多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核有可能会临时挂起进程。</p>
<p>&emsp;&emsp;<code>UNIX</code>系统为这样的操作提供了一种原子操作方法，即在打开文件时设置<code>O_APPEND</code>标志。正如前一章所述，这样做使得内核在每次写操作之前，都将进程的当前偏移量设置到该文件的尾端处，于是在每次写之前就不再需要调用<code>lseek</code>。</p>
<h2 id="函数pread和pwrite"><a href="#函数pread和pwrite" class="headerlink" title="函数pread和pwrite"></a>函数pread和pwrite</h2><p>&emsp;&emsp;<code>Single UNIX Specification</code>包括了<code>XSI</code>扩展，该扩展允许原子性地定位并执行<code>I/O</code>。<code>pthread</code>和<code>pwrite</code>就是这种扩展。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：读到的字节数，若已到文件尾，返回0；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若成功，返回已写的字节数；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;调用<code>pread</code>相当于调用<code>lseek</code>后调用<code>read</code>，但是<code>pread</code>又与这种顺序调用有下列重要区别。</p>
<ul>
<li>调用<code>pread</code>时，无法中断其定位和读操作。</li>
<li>不更新当前文件偏移量。</li>
</ul>
<p>&emsp;&emsp;调用<code>pwrite</code>相当于调用<code>lseek</code>后调用<code>write</code>，但也与它们有类似的区别。</p>
<h2 id="创建一个文件"><a href="#创建一个文件" class="headerlink" title="创建一个文件"></a>创建一个文件</h2><p>&emsp;&emsp;对<code>open</code>函数的<code>O_CREAT</code>和<code>O_EXCL</code>选项进行说明时，我们已见到另一个有关原子操作的例子。当同时指定这两个选项，而该文件又已经存在时，<code>open</code>将失败。前文曾提到检查文件是否存在和创建文件这两个操作是作为一个原子操作执行的。如果没有这样一个原子操作，那么可能会编写下列程序段：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((fd == <span class="built_in">open</span>(pathname, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == ENOENT) &#123;</span><br><span class="line">        <span class="keyword">if</span>((fd = create(path, mode)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ERR_SYS(<span class="string">"create error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ERR_SYS(<span class="string">"open error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果在<code>open</code>和<code>create</code>之间，另一个进程创建了该文件，就会出现问题。若在这两个函数调用之间，另一个进程创建了该文件，并且写入了一些数据，然后，原来进程执行这段程序中的<code>create</code>，这时，刚由另一个进程写入的数据就会被擦去。如若将这两者合并在一个原子操作中，这种问题也就不会出现。</p>
<p>&emsp;&emsp;一般而言，原子操作指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。</p>
<h1 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h1><p>&emsp;&emsp;下面两个函数都可以用来复制一个现有的文件描述符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两函数的返回值：若成功，返回新的文件描述符；若出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由<code>dup</code>返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于<code>dup2</code>，可以用<code>fd2</code>参数指定新文件描述符的值。如果<code>fd2</code>已经打开，则先将其关闭。如若<code>fd</code>等于<code>fd2</code>，则<code>dup2</code>返回<code>fd2</code>，而不关闭它。否则，<code>fd2</code>的<code>FD_CLOEXEC</code>文件描述符标志就被清除，这样<code>fd2</code>在进程调用<code>exec</code>时是打开状态。</p>
<p>&emsp;&emsp;这些函数返回的新文件描述符与参数<code>fd</code>共享同一个文件表项，如下图所示。</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/UNIX%E6%96%87%E4%BB%B6IO/dup%E5%90%8E%E7%9A%84%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="dup后的内核数据结构"></p>
<p>&emsp;&emsp;在此图中，我们假定进程启动时执行了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">newfd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>当此函数开始执行时，假定一下个可用的描述符是3（这是非常可能的，因为0，1和2都由<code>shell</code>打开）。因为两个描述符指向同一个文件表项，所以它们共享同一文件状态标志（读、写、追加等）以及同一当前文件偏移量。</p>
<p>&emsp;&emsp;每个文件描述符都有它自己的一套文件描述符标志。例如，新描述符的执行时关闭标志总是由<code>dup</code>函数清除。</p>
<p>&emsp;&emsp;复制一个描述符的另一种方法是使用<code>fcntl</code>函数，实际上，调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dup(fd);</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fcntl(fd, F_DUPFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>而调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">dup2(fd, fd2);</span><br></pre></td></tr></table></figure>

<p>等效于</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">close</span>(fd2);</span><br><span class="line">fcntl(fd, F_DUPFD, fd2);</span><br></pre></td></tr></table></figure>

<p>在后一种情况下，<code>dup2</code>并不完全等同于<code>close</code>加上<code>fnctl</code>。它们之间的区别具体如下。</p>
<ul>
<li><code>dup2</code>是一个原子操作，而<code>close</code>和<code>fcntl</code>包括两个函数调用。有可能在<code>close</code>和<code>fcntl</code>之间调用了信号捕获函数，它可能修改了文件描述符。如果不同的线程改变了文件描述符的话也会出现相同的问题。</li>
<li><code>dup2</code>和<code>fcntl</code>有一些不同的<code>errno</code>。</li>
</ul>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>UNIX文件</tag>
      </tags>
  </entry>
  <entry>
    <title>linux软件包安装管理</title>
    <url>/2021/03/08/linux%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;软件厂商在他们的系统上面编译好了我们用户需要的软件，然后将这个编译好的并可执行的软件直接发布给用户安装。不同的linux发行版使用不同的打包系统，一般而言，大多数发行版分别属于两大包管理技术阵营：Debian的“*.deb”，和Red Hat的“*.rpm”。也有一些例外，但大多数会使用这两个基本系统中的一个。</p>
<a id="more"></a>

<h1 id="dpkg与apt的关系"><a href="#dpkg与apt的关系" class="headerlink" title="dpkg与apt的关系"></a>dpkg与apt的关系</h1><p>&emsp;&emsp;dpkg（debian packager）是debian的底层包管理工具，主要用于对已下载到本地和已安装的软件包进行管理。其软件包的命名规则：</p>
<p>格式为：<code>Package_Version-Build_Architecture.deb</code></p>
<ul>
<li>软件包名称：Package</li>
<li>版本：Version</li>
<li>修订号：Build</li>
<li>平台：Architecture</li>
</ul>
<p>&emsp;&emsp;虽然在使用dpkg时，已经解决了软件安装过程中的大量问题，但是当依赖关系不满足时，仍然需要手动解决，而apt工具解决了这样的问题，linux distribution先将软件放置到对应的服务器中，然后分析软件的依赖关系，并且记录下来，然后当客户端有安装软件需求时，通过清单列表与本地的dpkg已存在的软件数据相比较，就能从网络端获取所有需要的具有依赖属性的软件了。</p>
<h2 id="apt的工作原理"><a href="#apt的工作原理" class="headerlink" title="apt的工作原理"></a>apt的工作原理</h2><p>&emsp;&emsp;ubuntu采用集中式的软件仓库机制，将各式各样的软件包分门别类地存放在软件仓库中，进行有效地组织和管理。然后，将软件仓库置于许许多多的镜像服务器中，并保持基本一致。这样，所有的ubuntu用户随时都能获得最新版本的安装软件包。因此，对于用户，这些镜像服务器就是他们的软件源。</p>
<p>&emsp;&emsp;然而，由于每位用户所处的网络环境不同，不可能随意地访问各镜像站点。为了能够有选择地访问，在ubuntu系统中，使用软件源配置文件/etc/apt/sources.list列出最合适访问的镜像站点地址。</p>
<p>例1:apt-get的更新过程：</p>
<ul>
<li>执行apt-get update</li>
<li>程序分析/etc/apt/sources.list</li>
<li>自动连网寻找list中对应的列表文件，如果有更新则下载之，存入/var/lib/apt/lists/目录</li>
<li>然后apt-get install相应的包，下载并安装</li>
</ul>
<p>&emsp;&emsp;即使这样，软件源配置文件也只是告知Ubuntu系统可以访问的镜像站点地址，但那些镜像站点具体都拥有什么软件资源并不清楚。若每安装一个软件包，就在服务器上寻找一遍，效率是很低的。因而，就有必要为这些软件资源列个清单（建立索引文件），以便本地主机查询。</p>
<p>&emsp;&emsp;用户可以使用“apt-get update”命令刷新软件源，建立更新软件包列表。在Ubuntu Linux中，“apt-get update”命令会扫描每一个软件源服务器，并为该服务器所具有软件包资源建立索引文件，存放在本地的/var/lib/apt/lists/目录中。 使用apt-get执行安装、更新操作时，都将依据这些索引文件，向软件源服务器申请资源。因此，在计算机设备空闲时，经常使用“apt-get update”命令刷新软件源，是一个好的习惯。</p>
<p>例2:apt-get install原理：</p>
<ul>
<li>扫描本地存放的软件包更新列表（由“apt-get update”命令刷新更新列表，也就是/var/lib/apt/lists/），找到最新版本的软件包</li>
<li>进行软件包依赖关系检查，找到支持该软件正常运行的所有软件包</li>
<li>从软件源所指的镜像站点中，下载相关软件包</li>
<li>解压软件包，并自动完成应用程序的安装和配置</li>
</ul>
<h2 id="apt相关文件"><a href="#apt相关文件" class="headerlink" title="apt相关文件"></a>apt相关文件</h2><ul>
<li>/var/lib/dpkg/available：文件的内容是软件包的描述信息，该软件包括当前系统所使用的Debian安装源中的所有软件包，其中包括当前系统中已安装和未安装的软件包</li>
<li>/etc/apt/sources.list：记录软件源的地址</li>
<li>/var/cache/apt/archives：已经下载的软件包都存放在这里（使用apt-get install安装软件包时，软件包的临时存放路径）</li>
<li>/var/lib/apt/lists：使用apt-get update命令会从/etc/apt/sources.list中下载软件列表，并保存到该目录</li>
</ul>
<h1 id="dpkg命令"><a href="#dpkg命令" class="headerlink" title="dpkg命令"></a>dpkg命令</h1><table>
<thead>
<tr>
<th>命令行</th>
<th>用途</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>dpkg -i</td>
<td>安装软件包</td>
<td>比如手动下载的文件</td>
</tr>
<tr>
<td>dpkg -R</td>
<td>安装一个目录下所有的软件包</td>
<td></td>
</tr>
<tr>
<td>dpkg –unpack</td>
<td>释放软件包</td>
<td>不进行配置，可以和-R一起用</td>
</tr>
<tr>
<td>dpkg -r</td>
<td>删除软件包（保留其配置文件）</td>
<td></td>
</tr>
<tr>
<td>dpkg -P</td>
<td>删除软件包（完全删除，包括其配置文件）</td>
<td></td>
</tr>
<tr>
<td>dpkg -l</td>
<td>显示已安装软件包列表</td>
<td></td>
</tr>
<tr>
<td>dpkg -L</td>
<td>显示与软件包关联的文件</td>
<td></td>
</tr>
<tr>
<td>dpkg -c</td>
<td>显示软件包内文件列表</td>
<td></td>
</tr>
<tr>
<td>dpkg –configure</td>
<td>重新配置和释放软件包</td>
<td></td>
</tr>
<tr>
<td>dpkg -s</td>
<td>报告指定包的状态信息</td>
<td></td>
</tr>
<tr>
<td>dpkg –get-selections</td>
<td>取得软件包的当前状态</td>
<td></td>
</tr>
</tbody></table>
<p>&emsp;&emsp;关于软件包的信息，当键入<code>dpkg -l</code>时，如以下示例：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/dpkg-l-options.png" alt="示例"></p>
<p>&emsp;&emsp;如上图，每条记录对应一个软件包，每条记录的第一、二、三个字符，就是软件包的状态标识，后边依次是软件包名称、版本号和简单描述。</p>
<p>1）第一个字符为期望值，包括：</p>
<table>
<thead>
<tr>
<th>状态标识</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>u</td>
<td>（Unkown）状态未知，意味着软件包未安装，并且用户也未发出安装请求</td>
</tr>
<tr>
<td>i</td>
<td>（Install）用户请求安装软件包</td>
</tr>
<tr>
<td>r</td>
<td>（Remove）用户请求卸载软件包（保留配置信息）</td>
</tr>
<tr>
<td>p</td>
<td>（Purge）用户请求清除软件包（彻底清除）</td>
</tr>
<tr>
<td>h</td>
<td>（Hold）用户请求保持软件包版本锁定</td>
</tr>
</tbody></table>
<p>2）第二个字符是软件包当前状态，包括：</p>
<table>
<thead>
<tr>
<th>状态标识</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>n</td>
<td>（Not）软件包未安装</td>
</tr>
<tr>
<td>i</td>
<td>（Inst）软件包安装并完成配置</td>
</tr>
<tr>
<td>c</td>
<td>（Conf-files）软件包以前安装过，现在删除了，但是它的配置文件还留在系统中</td>
</tr>
<tr>
<td>u</td>
<td>（Unpacked）软件包被解包，但还未配置</td>
</tr>
<tr>
<td>f</td>
<td>（Half-conf）试图配置软件包，但是失败了</td>
</tr>
<tr>
<td>h</td>
<td>（Half-inst）软件包安装，但是没有成功</td>
</tr>
<tr>
<td>w</td>
<td>（Trig-await）触发器等待</td>
</tr>
<tr>
<td>t</td>
<td>（Trig-pend）触发器未决</td>
</tr>
</tbody></table>
<p>3）第三个字符标识错误状态，第一种状态标识没有问题，为空。其他情况则为：</p>
<table>
<thead>
<tr>
<th>状态标识</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>软件包被强制保持，因为有其它软件包依赖需求，无法升级</td>
</tr>
<tr>
<td>r</td>
<td>Reinst-required，软件包被破坏，可能需要重新安装才能正常使用（包括删除）</td>
</tr>
<tr>
<td>x</td>
<td>软件包被破坏，并且被强制保持</td>
</tr>
</tbody></table>
<h1 id="apt-get命令"><a href="#apt-get命令" class="headerlink" title="apt-get命令"></a>apt-get命令</h1><p>下载，安装</p>
<table>
<thead>
<tr>
<th>命令行</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>apt-get update</td>
<td>更新源</td>
</tr>
<tr>
<td>apt-get dist-upgrade</td>
<td>升级系统到相应的发行版（根据source.list的配置）</td>
</tr>
<tr>
<td>apt-get upgrade</td>
<td>更新所有已经安装的软件包</td>
</tr>
<tr>
<td>apt-get install [package_name]</td>
<td>安装软件包（加上–reinstall重新安装）</td>
</tr>
<tr>
<td>apt-get install [package_name=version]</td>
<td>安装指定版本的软件包</td>
</tr>
<tr>
<td>apt-get -f install</td>
<td>安装依赖（一般跟在安装包之后）</td>
</tr>
</tbody></table>
<p>删除，卸载</p>
<table>
<thead>
<tr>
<th>命令行</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>apt-get remove [package_name]</td>
<td>删除已安装的软件包（保留配置文件），不会删除依赖软件包</td>
</tr>
<tr>
<td>apt-get –purge remove [package_name]</td>
<td>删除已安装的软件包（不保留配置文件）</td>
</tr>
<tr>
<td>apt-get autoremove</td>
<td>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装的），保留配置文件</td>
</tr>
</tbody></table>
<p>清理缓存</p>
<table>
<thead>
<tr>
<th>命令行</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>apt-get autoclean</td>
<td>定期运行这个命令来清除那些已经卸载的软件包的.deb文件。APT的底层包是dpkg，而dpkg安装软件包时，会将*.deb放在/var/cache/apt/archives/中。此命令只会删除该目录中已经过期的deb</td>
</tr>
<tr>
<td>apt-get clean</td>
<td>会将/var/cache/apt/archives/所有的deb删掉</td>
</tr>
</tbody></table>
<h1 id="apt-cache命令"><a href="#apt-cache命令" class="headerlink" title="apt-cache命令"></a>apt-cache命令</h1><table>
<thead>
<tr>
<th>命令行</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>apt-cache depends</td>
<td>了解该包使用哪些依赖</td>
</tr>
<tr>
<td>apt-cache redepends</td>
<td>查看该包被哪些包依赖</td>
</tr>
<tr>
<td>apt-cache search</td>
<td>搜索软件包，可以按关键字查找</td>
</tr>
<tr>
<td>apt-cache show</td>
<td>查询软件包的详情，不管是否已经安装</td>
</tr>
<tr>
<td>apt-cache showpkg</td>
<td>显示软件包的大致信息</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux细枝末节</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>pkg-config</title>
    <url>/2020/09/18/pkg-config/</url>
    <content><![CDATA[<hr>
<h1 id="pkg-config详解"><a href="#pkg-config详解" class="headerlink" title="pkg-config详解"></a>pkg-config详解</h1><h2 id="什么是pkg-config"><a href="#什么是pkg-config" class="headerlink" title="什么是pkg-config"></a>什么是pkg-config</h2><p>&emsp;&emsp;Pkg-config是一个linux下的命令，用于获取某一个库／模块的所有编译相关的信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg-config opencv --libs --cflags</span><br></pre></td></tr></table></figure>

<p>结果是解析出了所有该库的头文件以及链接库</p>
<a id="more"></a>

<h2 id="为什么要有pkg-config"><a href="#为什么要有pkg-config" class="headerlink" title="为什么要有pkg-config"></a>为什么要有pkg-config</h2><p>&emsp;&emsp;就上述列子来看，所有用到opencv的其他程序，在编译时，只需要写出<code>pkg-config opencv --libs --cflags</code>，而不需要自己去找opencv的头文件以及库文件在哪。</p>
<p>&emsp;&emsp;如果你写了一个库，不管是静态的还是动态的，要提供给第三方使用，那除了给人家库／头文件，最好也写一个pc文件（package configure是库配置文件，保存在PKG_CONFIG_PATH = xxx。pc文件保存了该库的头文件、库所在的路径信息。GCC等编译器编译时，比如编译某个工程用到glib-2.0这个库，pkg-config会按照PKG_CONFIG_PATH中的路径进行搜索glib-2.0.pc，然后把glib-2.0.pc作为参数传给GCC，那么GCC就可以找到该库了），这样别人使用就方便很多，不用自己再动手写依赖了你哪些库，只需要敲一个<code>pkg-config [YOUR_LIB] --libs --cflag</code>。</p>
<h2 id="pkg-config的信息从哪里来"><a href="#pkg-config的信息从哪里来" class="headerlink" title="pkg-config的信息从哪里来"></a>pkg-config的信息从哪里来</h2><p>&emsp;&emsp;有两种途径：</p>
<ol>
<li>取系统的/usr/lib下的所有*.pc文件。</li>
<li>PKG_CONFIG_PATH环境变量所指向的路径下的所有*.pc文件。</li>
</ol>
<p>&emsp;&emsp;这些pc文件什么时候有的？</p>
<p>&emsp;&emsp;都是在你安装某个库／模块的时候添加的。比如你往系统里面安装opencv时，就会在/usr/lib64/pkgconfig目录下，放一个opencv.pc。比如我个人电脑上就没有pc文件，那么pc文件到底写了什么？</p>
<p>&emsp;&emsp;以我本人的电脑为例，在/usr/lib64/pkgconfig目录下有一个lua.pc文件，其内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">V&#x3D;5.1</span><br><span class="line">R&#x3D;5.1.4</span><br><span class="line">prefix&#x3D;&#x2F;usr</span><br><span class="line">exe_prefix&#x3D;$&#123;prefix&#125;</span><br><span class="line">libdir&#x3D;&#x2F;usr&#x2F;lib64</span><br><span class="line">includedir&#x3D;$&#123;prefix&#125;&#x2F;include</span><br><span class="line"></span><br><span class="line">Name: Lua</span><br><span class="line">Description: An Extensible Extension Language</span><br><span class="line">Version: $&#123;R&#125;</span><br><span class="line">Requires: </span><br><span class="line">Libs: -llua -lm -ldl</span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br></pre></td></tr></table></figure>

<p>当我在本地电脑上面输入如下命令行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg-config lua --libs --cflags</span><br></pre></td></tr></table></figure>

<p>显示出如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-llua -lm -ldl</span><br></pre></td></tr></table></figure>

<h2 id="如何添加自己的pc文件"><a href="#如何添加自己的pc文件" class="headerlink" title="如何添加自己的pc文件"></a>如何添加自己的pc文件</h2><p>&emsp;&emsp;如上文所说，有2种方式：</p>
<ol>
<li><p>把你的pc文件，直接放在/usr/lib64/pkgconfig…默认路径下。</p>
</li>
<li><p>把你的pc文件的路径写到PKG_CONFIG_PATH环境变量里。比如，你可以在/etc/.bashrc或者/home/[your count]/.bashrc的文件末尾添加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$PGK_CONFIG_PATH:/home/[your count]/[your project]/lib/pkgconfig</span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p>那么，pkg-config就会到该目录下寻找*.pc文件。</p>
<p>那么这个pc文件何时生效呢？</p>
<p>如果是/usr/lib64/pkgconfig下，立马生效！！！</p>
<p>如果在环境变量里，只要先source ~/.bashrc一下，让环境变量生成，也立马生效。</p>
</li>
</ol>
<h2 id="如何自己写pkg-config的pc文件"><a href="#如何自己写pkg-config的pc文件" class="headerlink" title="如何自己写pkg-config的pc文件"></a>如何自己写pkg-config的pc文件</h2><p>&emsp;&emsp;其实很简单，只需要拿别人的pc文件改一改就行了。</p>
<p>&emsp;&emsp;pc文件的所有参数：</p>
<ul>
<li><p>Name：该模块的的名字，比如你的pc名字是xxx.pc，那么名字最好也是xxx。</p>
</li>
<li><p>Description：模块的简单描述。<code>pkg-config --list-all</code>该命令可以查看到所有的模块信息，该命令的结果，每个模块的名字后面就是description。</p>
</li>
<li><p>URL：用户可以通过该URL获得更多的信息，或者下载信息。也是辅助的，可要可不要。</p>
</li>
<li><p>Version：版本号。</p>
</li>
<li><p>Requires：该模块有没有依赖其他模块。一般没有。</p>
</li>
<li><p>Requires.private：该模块有没有依赖其他模块，并且还不需要第三方知道的。一般也没有。</p>
</li>
<li><p>Conflicts：有没有和别的模块冲突。常用于版本冲突。比如，Confilcts: opencv &lt; 1.0.0，表示和opencv模块的1.0.0以下的版本有冲突。</p>
</li>
<li><p>Cflags：这个就很重要了。pkg-config的参数<code>--cflags</code>就指向这里。主要用于写本模块的头文件路径。</p>
</li>
<li><p>Libs：也很重要，pkg-config的参数<code>--libs</code>就指向这里。主要用于写本模块的库／依赖库的路径。</p>
</li>
<li><p>Libs.private：本模块依赖的库，但不需要第三方知道。</p>
</li>
</ul>
<p>其实必须写的只有5个：Name、Description、Version、Cflags、Libs。</p>
<p>举个例子。一个动态库，一个静态库。</p>
<p>例子1:动态库的pc文件。</p>
<p>假设我写了libfoo.so，我的库会被安装到/usr/local/lib/，头文件会放到/usr/local/include/。那么pc文件可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prefix&#x3D;&#x2F;usr&#x2F;local</span><br><span class="line">exe_prefix&#x3D;$&#123;prefix&#125;</span><br><span class="line">includedir&#x3D;$&#123;prefix&#125;&#x2F;include</span><br><span class="line">libdir&#x3D;$&#123;prefix&#125;&#x2F;lib</span><br><span class="line"></span><br><span class="line">Name: foo</span><br><span class="line">Description: The foo library</span><br><span class="line">Version: 1.0.0</span><br><span class="line">Cflags: -I$&#123;includedir&#125;&#x2F;</span><br><span class="line">Libs: -L$&#123;libdir&#125; -lfoo</span><br></pre></td></tr></table></figure>

<p>例子2:静态库的pc文件</p>
<p>静态库链接动态库时，如何使用该静态库，如果我有个静态库libXXX.a，它依赖了很多其他动态库libAA.so，libBB.so，那么第三方程序要使用libXXX.a时，编译时还得链接libAA.so，libBB.so。为了让第三方程序不用操心我这个libXXX.a到底依赖了什么，可以为我的libXXX.a写一个pc文件。路径位于工程的文件下的lib/pkgconfig/。之后唯一需要做的就是把这些pc文件的路径，写到PKG_CONFIG_PATH。</p>
<p>在/home/parallels/.bashrc内添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PKG_CONFIG_PATH=$PKG_CONFIG_PATH:[your path]</span><br><span class="line">export PKG_CONFIG_PATH</span><br></pre></td></tr></table></figure>

<p>然后<code>source /home/parallels/.bashrc</code>，最后就可以使用了！</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>placement new与placement delete一定要成双成对</title>
    <url>/2020/12/02/placement%20new%E4%B8%8Eplacement%20delete%E4%B8%80%E5%AE%9A%E8%A6%81%E6%88%90%E5%8F%8C%E6%88%90%E5%AF%B9/</url>
    <content><![CDATA[<hr>
<h1 id="运行期系统对于正常形式new／delete所做出的决策"><a href="#运行期系统对于正常形式new／delete所做出的决策" class="headerlink" title="运行期系统对于正常形式new／delete所做出的决策"></a>运行期系统对于正常形式new／delete所做出的决策</h1><p>&emsp;&emsp;当你写一个像这样的new表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget* pw = <span class="keyword">new</span> Widget;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;共有两个函数被调用：一个是用以分配内存的operator new，一个是Widget的default构造函数。</p>
<p>&emsp;&emsp;假设其中第一个函数调用成功，第二个函数抛出异常。那么这种情况下，第一步内存分配的空间必须取消并恢复原状，否则会造成内存泄漏。但是由于Widget构造函数抛出异常，pw尚未被赋值，那么客户手上自然就没有指针指向应该被归还的内存。</p>
<a id="more"></a>

<p>&emsp;&emsp;C++运行期系统会调用第一步所调用的operator new的相应operator delete版本，前提当然是它必须知道哪一个（因为可能有多个）operator delete该被调用。在上述情况下，我们面对的是拥有正常签名式的new和delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//global作用域中的正常签名式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//class作用域中典型的签名式</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因此，当你使用正常形式的new和delete，运行期系统很自然地可以找出那个“知道如何取消new所作所为并恢复原状”的delete。</p>
<h1 id="非正常形式的new浮现出的问题"><a href="#非正常形式的new浮现出的问题" class="headerlink" title="非正常形式的new浮现出的问题"></a>非正常形式的new浮现出的问题</h1><p>&emsp;&emsp;然而，当你开始声明非正常形式的operator new，也就是带有附加参数的operator new，“究竟哪一个delete伴随这个new”的问题便浮现了。</p>
<p>&emsp;&emsp;举个例子，假设你写了一个class专属的operator new，要求接受一个ostream，用来志记（log）相关分配信息，同时又写了一个正常形式的class专属operator delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="built_in">std</span>::ostream&amp; logStream)</span> </span></span><br><span class="line"><span class="function">            <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;  <span class="comment">//非正常形式的new</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* pMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function">            <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//正常的class专属delete</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个设计有点问题，但现在我们可以先绕开这个问题。简要的讨论以下概念。</p>
<h1 id="什么是placement-new"><a href="#什么是placement-new" class="headerlink" title="什么是placement new"></a>什么是placement new</h1><p>&emsp;&emsp;什么是placement new：如果operator new接受的参数除了一定会有的那个size_t类型参数之外还有其他的，这个便是所谓的placement new。因此上述的operator new是一个placement版本。在众多的placement new版本中特别有用的一个是“接受一个指针指向对象该被构造之处”，这样的operator new长相如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">void</span>* pMemory)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个版本的new已被纳入C++标准程序库，你只要#include &lt;new&gt;就可以使用它。这个new的用途之一是负责在vector的未使用空间上创建对象。它同时也是最早的placement new版本。实际上它正是这个函数的命名依据：一个特定位置上进行new操作。</p>
<p>&emsp;&emsp;大多数情况下，当人谈及placement new，往往指的是“唯一额外实参是个void*”这个特定版本。</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>template元编程</title>
    <url>/2020/11/22/template%E5%85%83%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="template元编程"><a href="#template元编程" class="headerlink" title="template元编程"></a>template元编程</h1><p>&emsp;&emsp;TMP（template metaprogrammming）模版元编程是编写template-base C++程序并执行于编译期的过程。所谓TMP是以C++写成、执行于C++编译器内的程序。一旦TMP程序结束执行，其输出，也就是从template具现出来的若干C++源码，便会被编译。</p>
<p>&emsp;&emsp;C++并非是为TMP而设计，TMP是被发现而不是被发明出来的。当template加入C++时TMP底层特性也就被引进了。对某些人而言唯一需要注意的是如何以熟练巧妙的方式使用TMP。</p>
<p>&emsp;&emsp;TMP有两个强大的作用。第一，它让某些事情变得更加容易。如果没有它，那些事情将是十分困难的，甚至是不可能的。第二，由于template metaprograms执行于C++编译期，因此可将工作从运行期转移至编译期。这将导致一个结果，某些错误原本通常在运行期才能侦测到，现在可在编译期找出来。另一个结果是，使用TMP的C++程序可能在每一方面都更高效：较小的可执行文件、较短的运行期、较少的内存需求，然而将工作从运行期转移至编译期的另一个结果是，编译时间变长了。</p>
]]></content>
  </entry>
  <entry>
    <title>中国网游发展史之千禧年初</title>
    <url>/2021/12/01/%E4%B8%AD%E5%9B%BD%E7%BD%91%E6%B8%B8%E5%8F%91%E5%B1%95%E5%8F%B2%E4%B9%8B%E5%8D%83%E7%A6%A7%E5%B9%B4%E5%88%9D/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;雅达利的兴衰和约翰卡马克的传奇故事，这些故事虽然精彩，但是我们都没有经历。我的意思是没有在正确的时间玩过那些改变了游戏历史的游戏。对于我们中国人来说，经历过游戏禁令的90后来说，我们所经历的游戏发展史大多都是小霸王-街机-光碟PC-PC单机-PC网游-PC单机，就这么简单。当然了，这里不代表所有人。虽然我们玩的我们所经历的，大多都是别人玩剩下的。但这，对于我们来说，同样精彩。同样给我们留下了不可磨灭的记忆。所以，我就以一个普通家庭90后的角度，来讲述一个中国人的游戏发展史。</p>
<a id="more"></a>

<h2 id="PC时代背景"><a href="#PC时代背景" class="headerlink" title="PC时代背景"></a>PC时代背景</h2><p>&emsp;&emsp;我接触电脑算是比较早的了，因为小时候父母做生意没时间照顾我，记得小学2年级还是3年级就把我送到了那种贵族寄宿学校，学校开设了微机课，当时还有DOS系统，打开电脑以后就只有黑屏加一堆看不懂的英文，输入相应的指令才能进入电脑里安装过的程序，大概是这样吧，反正挺复杂的。后来因为种种原因，父母把我接回湖北老家。虽然人回来了，但网瘾的种子已经埋下，“网瘾少年”的不归路也正式开始了。</p>
<p>&emsp;&emsp;新鲜事物对人对吸引力是无穷无尽的，电脑作为一个划时代的产物更像是一个口袋装满糖果的恶魔让我深陷其中无法自拔。WINDOWS系统的各种屏保都能玩一下午的，相信不止我一个吧。你们不要小看当时所谓的网瘾啊，现在这个手机也能运行3D游戏的时代，游戏已经不再是新鲜事物了，你要说你现在还有网瘾——不可能！只有经历过那个时代的人，才能深刻体会到什么是真正的网瘾。你可能体会过三天三夜持续游戏，但你体会过三天三夜甚至一周玩游戏全程都保持非常亢奋的状态吗？当时的网瘾不夸张的说可以用着魔这两个词来形容。摸到键盘和鼠标的那一刻就可以深刻体会到肾上腺素激增和多巴胺分泌颅内高潮的快感，一会不玩，浑身难受。现在，网瘾基本就不存在了，顶多可以说是自制力差，贪玩。</p>
<p>&emsp;&emsp;emmm，扯远了，回来以后对电脑当然也是念念不忘了，但那个年代，电脑这个东西对于一般人完全就是奢侈品，当时，我这的同龄人都还在玩FC和街机，有的根本不知道电脑为何物。而当时的网吧也不叫网吧，叫电脑房。因为电脑高昂的价格，上网费用也高的离谱，三块钱一小时，那个年代的三块钱可不是一个小数目。但电脑作为一种新兴的高科技产品，在它刚起步的时候很多成年人还没有意识到电脑强大的游戏功能，当时也有很多成年人去参加电脑补习班，学的就是打字复制粘贴，现在看起来智障都能无师自通的东西。</p>
<p>&emsp;&emsp;得益于初期电脑良好的口碑，我可以明目张胆的问父母要钱去网吧，emmm，不对，是去电脑房。当时的网吧还没有发达的管理系统，上网和下机的时间都是网管拿本子记下来的，到时间再过去提醒你该下机了，时间也没有那么精确，所以我每次都能玩一个半小时或者将近两个小时，周围都是18岁左右的或者一些成年人，我一个小学生，他们也没有跟我斤斤计较，告诉我超时间了就放我走了。当时玩的都是什么呢？红色警戒、帝国时代和cs等等游戏，当然了，还有QQ。对，你没有看错，QQ。我当时还小，也才刚刚注册过QQ（这还是我爸公司员工帮我注册的）。大多都是16岁到20多岁的，特别是女孩一到网吧啥也不干，就只戴着耳机玩QQ，现在你可能体会不到啊。但对于当时的人来说，这种新型的社交方式也一样有着无穷的吸引力，而且很多人连基本的操作都不会，有不会打开QQ的，有不知道自己密码的，有不会选择聊天对象的。这些鸡毛蒜皮的小事都得麻烦网管，再加上记录上下机时间，当时的网管可真不容易啊。</p>
<p>&emsp;&emsp;网吧在那个时代的意义也不仅仅是玩游戏和聊QQ，那个时候可以让人们娱乐的东西并不多，喜欢动漫的，有钱的买光碟，没钱的看漫画，就连看各种电影都要租碟才可以。网吧出现以后，一台电脑这些问题全解决了。当然了，去网吧看电影，看动漫，这种奢侈的事情是不适合小孩子的。我当时玩的最多的就是红色警戒了，因为那个年代游戏比较少，中文版的游戏就更少了，本来红色警戒在当时最火的游戏类型之一RTS游戏中就是门槛最低最简单易懂的了，比如没有人口限制，后来又加入了各种MOD，像共和国之辉。基于上述种种原因，所以这款游戏才在中国火到如此地步，但最终都投入到了CS的怀抱中。</p>
<p>&emsp;&emsp;在网游热潮来临之前，网吧除了玩QQ的和看电影的，几乎都是CS，至少在我们这是这样的，但这种现状没维持多久就被网游打破了，大概是从石器时代开始 ，在这之前也有很多话时代的游戏因水土不服并未掀起太大的波澜。1999年，网络创世纪进入中国，这是中国第一款图形网络游戏，在这之前几乎都是文字网游。这款游戏创建了网络游戏的框架，确立了网络游戏的规则，这些规则和框架大多被沿用至今。</p>
<h1 id="2000千禧年"><a href="#2000千禧年" class="headerlink" title="2000千禧年"></a>2000千禧年</h1><h2 id="鼻祖"><a href="#鼻祖" class="headerlink" title="鼻祖"></a>鼻祖</h2><p>&emsp;&emsp;2000年7月中国历史上第一款自主研发的图形网络游戏——万王之王，正式上线。在那个到处都是呼哈哈嘿的年代，这款国产网游居然有中文配音，你敢信？万王之王也是首款进入了韩国市场的网游。当年的韩国作为网游界的一哥还是二哥？向中国输出了大量网络游戏，但你可能不知道的是，首先打入对方市场的是中国。这款游戏就是万王之王。</p>
<p>&emsp;&emsp;早期游戏的死亡惩罚是非常可怕的，万王之王也一样，它的死亡惩罚是掉光你所有携带的金币和装备外加一点所有属性，所以每当发生国战的时候，你只需要捡捡尸体就可以发家致富了。</p>
<h2 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h2><p>&emsp;&emsp;韩国（进入中国）的第一款网游——黑暗之光，由宇智科通代理引入中国。当时的韩国网游公司认为中国基本没有多少可玩的网络游戏，竞争对手也只有万王之王，其他的都是一些文字网游，所以游戏才做了一半就强行将它推向市场。后果可想而知，国内宁愿玩文字网游也不玩你这破游戏。宇智科通也自此销声匿迹。</p>
<h2 id="中国网游时代的来临"><a href="#中国网游时代的来临" class="headerlink" title="中国网游时代的来临"></a>中国网游时代的来临</h2><p>&emsp;&emsp;时间来到了2001年，2001年是中国网游市场真正开始走向正规的时代。部分举足轻重的互联网公司，网易，盛大，也开始崭露头角。</p>
<p>&emsp;&emsp;2001年1月，石器时代由北京华义代理引入中国。这是日系网游第一次进入中国，后来也因为石器时代，正式形成欧日韩三国鼎立的网游环境。很多人说这款游戏死于外挂，这不尽然，我认为这不如说是华义自己作死的。其实这款游戏进入中国以后没过多久，日方就将源代码也卖给了华义。后边各种坑爹道具都是华义自己运作的，不管外挂也就罢了，甚至很多变态道具就是为了迎合外挂而推出的。他们在意的是如何快速敛财，并没有考虑过游戏可以活多久。</p>
<p>&emsp;&emsp;2001年3月，中国大陆第一款原创网络游戏——第四世界，问世了。<img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E4%B8%AD%E5%9B%BD%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%8F%91%E5%B1%95%E5%8F%B2/%E7%AC%AC%E5%9B%9B%E4%B8%96%E7%95%8C.png" alt="第四世界">默默无闻的推向市场，默默无闻的退场，鲜有人知，第一款游戏就搞成这样，真是讽刺。</p>
<p>&emsp;&emsp;2001年4月，千年由亚联代理引入中国。千年，传奇，红月，在当时并称三大网游。千年死与外挂和复制物品；红月死于游戏内容空洞属性变态，甚至还出现了1000级的概念，秒杀一词也是从红月开始出现的；最后活下来的只有传奇了。当然了，传奇在当时也一样面临外挂问题，也有复制物品的bug。韩国游戏的漏洞有多大，看看现在的吃鸡就知道了。但传奇相比于其他两款游戏更简单，更易上手，这也许就是它活下来的原因吧。如果你说宣传力度，千年可一点都不比传奇差。</p>
<p>&emsp;&emsp;2001年5月，联众世界出现了，这个软件在当时到底有多火呢？我可以这么说，那时每个上班族的电脑里几乎都有一个联众世界，大多都是25岁以上的玩家，还都不会打字，只会打kkkkkkk。然后又陆续引进了龙族、红月、碰碰i时代、三国世纪和金庸群侠传。龙族因为其强大的外挂功能最终导致死亡，那龙族的外挂到底猖獗到什么程度呢？连修改单机游戏数据的修改器都可以拿来修改这款网游，那还玩个P啊。<img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E4%B8%AD%E5%9B%BD%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%8F%91%E5%B1%95%E5%8F%B2/%E9%BE%99%E6%97%8F.png" alt="龙族">)金庸群侠传也是一款好游戏，<img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E4%B8%AD%E5%9B%BD%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E5%8F%91%E5%B1%95%E5%8F%B2/%E9%87%91%E5%BA%B8%E7%BE%A4%E4%BE%A0%E4%BC%A0.png" alt="金庸群侠传">很多设计理念即使放到现在也是非常超前了，但早期网游的通病——外挂泛滥。而没有外挂手动练级的话，简直就是地狱一般的折磨。那这外挂，你管还是不管呢？这是一个问题。不过这款游戏至今仍在运营，其他的我就不多说了。</p>
<p>&emsp;&emsp;接下来就是真正进入大众视野的网游了。</p>
<p>&emsp;&emsp;2001年11月，中国出现了两款划时代的网络游戏，网易自主研发的大话西游1和盛大代理的传奇。</p>
<h2 id="传奇给中国市场带来的变化"><a href="#传奇给中国市场带来的变化" class="headerlink" title="传奇给中国市场带来的变化"></a>传奇给中国市场带来的变化</h2><p>&emsp;&emsp;2001年11月，韩国wemade公司开发的游戏——传奇，由盛大代理引入中国，这款游戏不仅引爆了中国网游的热潮，还让中国网游从萌芽期一举进入到发展期，并且让陈天桥成为了中国最年轻的首富。在盛大拿到传奇的代理权之前，这家公司因为动画产业的失败一直处于烧钱等死的状态。2001年初，陈天桥用他仅剩的30万美金拿下了传奇在中国的独家代理权，就连服务器和宽带都是陈天桥用这个合同给忽悠过来的，而之前一只投资盛大的中华网，却不能接受盛大的突然转型而提出撤资，后来估计肠子都悔青了。盛大与wemade之间的代理纠纷就不多说了，接下来就聊一聊，这个贯穿了端游页游手游三个时代的传奇游戏，为什么可以火到如此地步？传奇经久不衰的原因在我看来要从5个方面来讲：背景，跟风，玩法，情怀和私服。</p>
<p>&emsp;&emsp;先说背景，在传奇之前，几乎没有多少可玩的网游，选择也比较少。个别可以入眼的游戏也因为早期的互联网公司缺乏游戏运营经验，并没有让玩家满意，所以传奇的出现就让那个没有什么选择的时代有了一个唯一的选择。千年，龙族，红月的玩家迅速涌入到传奇，仅仅用了一年的时间，同时在线人数就达到了70万。而且那时候没人会上游戏门户网站，也不会有人去主动了解游戏，“大家都在玩传奇，我当然也要玩啦”。所以很多人是因为玩传奇才学会上网，是因为传奇才学会网上冲浪。在情怀的驱使下，就算有更好的游戏，在他们心里依旧比不上传奇。当然了，这只是其中的一点，如果仅仅是因为这个原因，那就太肤浅了。</p>
<p>&emsp;&emsp;接下来就是玩法，简单粗暴的设定，简单粗暴的技能，学习成本基本为零，人人都能上手，打怪掉宝，杀人夺宝，就是这么简单。设定上虽然简单，但游戏体验上却没有那么简单。当时的游戏打怪奖励几乎就只有经验值，但传奇可不一样，这款游戏几乎每一个怪都有可能给你惊喜，这就让原本非常无聊的打怪玩法变得非常有成就感。也许下一个怪就有可能让你走上人生巅峰，装备一直在提升，属性一直在增长，这种数字上的增长也给人一种无限的满足感。简单一点说就是有盼头。再者说，当年可没人觉得打怪无聊，给人当代练都玩的美滋滋。</p>
<p>&emsp;&emsp;还有就是探险，老玩家跟新玩家是完全不一样的游戏体验，在那个搜索引擎根本搜不到攻略的时代，新玩家出了城以后，根本不知道自己身处何方，漫无目的的跑，漫无目的的打，漫无目的的提升装备，在一片沙漠中，突然看到一座寺庙，在一片森林中突然看到一个山洞，被祖玛侍卫捶死，被巨型昆虫包围。那种探险的感觉给予了玩家无限的神秘感。老玩家的话，那就是pk了，这也是传奇的核心玩法，为什么吃鸡现在这么火，就是因为这个杀人舔包的设定。再加上当时古惑仔的热播，还有坏蛋小说，现实中讲那种义气，是要付出代价的，但游戏中就不一样了。这就为那个时代的年轻人提供了一个平台，为了朋友，为了帮会，抛头颅洒热血，谁被欺负了一呼百应，这种强大的归属感，也埋下了情怀的种子。这款游戏还有一个平民乐趣，就是捡漏。比如说攻打一个公会的时候，可能会被暴的血本无归，也可能会发一笔横财。</p>
<p>&emsp;&emsp;最后就是私服了，有人说传奇死于私服，其实私服说它是mod也不过分，每个私服的玩法都不一样，不过也是万变不离其宗的，但游戏体验确实有微妙的不同，当年有仿盛大版本的，有合体版的，还有什么仙剑版的，说的明白点，就像那种因为各种mod经久不衰的单机游戏一样，没有私服传奇，就没有传奇的今天。贪玩蓝月这些页游则是在传奇的基础上进一步简化，传奇但精髓已经舍弃，只是包裹着传奇外衣的糖衣炮弹，没有探索玩法，也没有了每只怪都有惊喜的激励机制，有的只是靠人民币所换来的虚荣心。现在的网游本身已经没有什么新鲜感了，就算是新游戏也是画面较好的老三样，相比区别不大画面好一些的新网游，还不如选择承载了自己青春的情怀游戏。</p>
<blockquote>
<p>由于本人并未玩到传奇等这些元老级网络游戏，因此，以上玩法以及游玩经历的讲述均来自于与我本人一同开发过游戏的前辈的口中。特此@AlexOldZhang，@清白，@HotFixxxxx，@H好。</p>
</blockquote>
]]></content>
      <categories>
        <category>中国网游发展史</category>
      </categories>
      <tags>
        <tag>游戏博物馆</tag>
      </tags>
  </entry>
  <entry>
    <title>中国网游发展史之腾讯进军网游产业</title>
    <url>/2021/12/06/%E4%B8%AD%E5%9B%BD%E7%BD%91%E6%B8%B8%E5%8F%91%E5%B1%95%E5%8F%B2%E4%B9%8B%E8%85%BE%E8%AE%AF%E8%BF%9B%E5%86%9B%E7%BD%91%E6%B8%B8%E4%BA%A7%E4%B8%9A/</url>
    <content><![CDATA[<hr>
<h1 id="曲折坎坷的2003年"><a href="#曲折坎坷的2003年" class="headerlink" title="曲折坎坷的2003年"></a>曲折坎坷的2003年</h1><p>&emsp;&emsp;2003年1月，骑士online正式公测，由搜狐代理运营。这是一款大型3D角色扮演类游戏，自公测以来一直深受众多玩家们的喜爱，但在那个网游飞速发展的年代，骑士online也不可避免的走向了衰竭。为了留住玩家，搜狐在2006年改变了运营策略，将游戏转为道具收费的模式。这样的转变也起到了良好的效果，大量老玩家纷纷回到了骑士online的怀抱。值得一提的是搜狐就骑士online这款游戏与韩方签订了4年合约，但转为免费模式的经济效益并没有达到搜狐预期的效果，所以续约这事也就自然而然的谈崩了。</p>
<a id="more"></a>

<p>但纸总是包不住火的，早在2006年8月的时候网上便已流传出关于骑士online即将停止运营的消息，众多玩家因为担心骑士online的前景去官方论坛讨说法。搜狐顶不住压力，第二天就在游戏的官方网站上发布了一则公告，大体内容是这样的：“望所有玩家坚定对《骑士online》这款产品的信心，我们不但不会停止对《骑士online》的运营，还会把他做得更加精彩”。可在这则公告发布不到三个月的时间搜狐却又发布了一则公告，大概内容是这样的：“为保障广大中国区玩家的利益，经搜狐游戏与韩方的协商决定，骑士online的服务器运行时间延长到2007年3月20日”。这则公告字里行间好像都在为玩家考虑，良心啊，别着急，更良心的还在后面。传言是8月底，辟谣也是8月底，3个月以后，也就是11月底又突然公布游戏即将停运。那么这3个月里都发生了什么呢？9月底也就是谣言出现的一个月以后，搜狐为了稳定玩家的情绪，推出了一个活动，叫什么“十一黄金周，骑士伴你行”，说要提前更新新版本，新装备，新技能，新任务，又推出了各种氪金活动并表示骑士online前途一片光明。后边的事，大家应该都可以猜到了，这明显就是典型的商业欺诈。而且这款游戏因为转为免费运营以后人气也不低，说关就关了，关之前还把这么多玩家当猴耍了，这谁受得了，在看到即将停服的消息以后，大量玩家涌入了315网站进行投诉。最后。。。也是不了了之了，毕竟你在进入网游之前都会接受一个你看都不会看的协议，知道那个吧，每个网游都有的，而且当时网络环境也没有现在这么发达，要是放到现在，我举个例子，魔兽世界要是昨天刚刚不限量卖一波无敌，幽灵虎，凤凰等各种坐骑，今天就遗憾的通知大家游戏停运了，相信玩家会直接把暴雪都给爆破了。值得一提的是，现在还可以通过steam平台找到这款游戏，欧服台服仍在运营。</p>
<p>&emsp;&emsp;同在1月推出的网游还有游戏新干线代理的仙境传说，这款游戏一入眼就给人一种早期日式单机游戏的感觉。Q萌的画风，Q萌的表情包，还有其强大的社交功能，都让这款游戏成为了很多人心目中的经典之作。游戏的画面采用2D人物然后是伪3D建模，在当时的Q版网游中这款游戏的画面也是最顶尖的一款，再加上他生动形象的表情包和电视广告的投放，俘获了一大批女孩子的芳心。早期的网游大多都是刷刷刷，玩法基本就是肝，但那个时期的玩家，说难听点，没什么见识，就算是无聊的机械式刷怪也可以刷他个三天三夜。还有什么公会战之类的pvp玩法就不说了，总之这款游戏的亮点在我看来就是初步形成了休闲网游的雏形。要说哪款游戏的外挂最变态，RO说第二，没人敢说第一，他是脱机外挂的鼻祖，玩过传奇的应该都听说过脱机外挂这玩意吧，就是直接跳过游戏的客户端，用外挂登陆游戏从而实现一台电脑30个账号同时运行。你以为这种外挂就很夸张了吗？别着急，RO还有服务器托管的外挂，电脑都不用开，这用现在的说法应该就是云外挂了吧。</p>
<p>&emsp;&emsp;2003年2月，网星代理了大宇制作的轩辕剑online，这款网游并没有达到单机轩辕剑的高度，品质不够优秀，网游的制作经验也比较匮乏。虽然是3D建模，但画质相比于同期的韩国网游相差太多了，还不如做成2D。职业分化也非常严重，8个职业各具特色，但基本没有独立的生存能力，甚至连小怪都打不过，也许大宇认为网游就应该这样吧。其他地方也都普普通通，跟同期的韩游完全没有可比性，唯一不普通的地方就是点卡了，轩辕剑online的收费在当时是价格最高的网游，迷之自信。</p>
<p>&emsp;&emsp;2003年2月，上海育碧代理了宇宙神作无尽的任务，魔兽初期的成功就是因为借鉴了这款游戏的优点。</p>
<p>&emsp;&emsp;2003年3月，由亚联游戏代理百战天虫，玩法就是现在的弹弹堂了，百战天虫应该就是这个模式的鼻祖吧。当时很多玩家厌倦了刷刷刷单游戏模式，休闲网游也在这时开始崛起。</p>
<p>&emsp;&emsp;2003年4月，天人互娱代理魔剑online，很多资深网游玩家对这款游戏的评价都非常的高，但天人互娱是一个单机游戏发行商，没有什么网游运营经验，这导致国服bug多，服务器也不稳定，而且游戏模式过于超前无法被玩家接受，所以仅仅一年的时间国服就停止运营了。这款游戏的整个世界都可以由玩家自己来建设城邦，甚至摧毁敌人城邦，而且这不是什么SLG游戏，是真正的大型角色扮演游戏。</p>
<p>&emsp;&emsp;腾讯看到各大互联网公司都靠网游赚的盆满钵满终于坐不住了，随后老马带着腾讯团队直奔上海拜访了陈天桥也就是盛大的CEO。大家整天黑腾讯，现在知道腾讯是跟谁学的了吧。随后又去美国观摩了E3展会，2003年5月，随着QQ游戏平台的发布，腾讯也顺势代理了凯旋，开始进军网游产业。</p>
]]></content>
      <categories>
        <category>中国网游发展史</category>
      </categories>
      <tags>
        <tag>游戏博物馆</tag>
      </tags>
  </entry>
  <entry>
    <title>traits class与类型信息之间的妙用</title>
    <url>/2020/11/21/traits%20class%E4%B8%8E%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A6%99%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h1 id="traits-class与类型信息之间的妙用"><a href="#traits-class与类型信息之间的妙用" class="headerlink" title="traits class与类型信息之间的妙用"></a>traits class与类型信息之间的妙用</h1><p>&emsp;&emsp;STL主要由“用以表现容器、迭代器和算法”的template构成，但也覆盖若干工具性template，其中一个名为advance，用来将某个迭代器移动某个给定距离：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来advance做了iter+=d的动作，但是只有random access（随机访问）迭代器才支持+=操作。面对其他威力不是那么强大的迭代器种类，advance必须反复执行++或–，共d次。</p>
<a id="more"></a>

<p>&emsp;&emsp;简单回顾一下，STL一共有5种迭代器种类，对应于它们支持的操作。Input迭代器只能向前移动，一次一步，客户只可读取（不能写）它们所指的东西，而且只能读取一次。Output迭代器情况类似，只能向前移动，一次一步，客户只可写它们所指的东西，而且只能写一次。Forward迭代器威力就要强大的多了。这种迭代器可以做前述两种分类所能做的每一件事，而且可以读或写其所指物一次以上。Bidrectional迭代器比上一个分类威力更大。它除了可以向前移动还可以向后移动。最有威力的迭代器当属Random access迭代器。这种迭代器可以执行“迭代器算术”，也就是它可以在常量时间内向前或向后跳跃任意距离，因为random access迭代器正是以内置（原始）指针为榜样，而内置指针也可被当作random access迭代器使用。vector，deque和string提供的迭代器都是这一分类。</p>
<p>&emsp;&emsp;对于这5种分类，C++标准库分别提供专属的卷标（tag struct）加以确认：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidrectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidrectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些struct之间的继承关系是有效的的is-a关系：所有的forward迭代器都是input迭代器，一次类推。很快我们就会看到这个继承关系的威力。</p>
<p>&emsp;&emsp;现在回到advance函数。我们已经知道STL迭代器有着不同的能力，实现advance的策略之一是采用“最低但最普及”的迭代器能力，以循环反复递增或递减迭代器。然而这种做法耗费线性时间。我们知道random access迭代器支持迭代器算术运算，只耗费常量时间，因此如果我们遇到这种迭代器，我们希望运用其优势。期望以这种方式实现advance：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(iter is a <span class="built_in">random</span> access iterator) &#123;</span><br><span class="line">        iter += d;  <span class="comment">//针对random access迭代器使用迭代器算术运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种做法首先必须要判断iter是否为random access迭代器，也就是说需要知道类型IterT是否为random access迭代器分类。换句话说我们需要取得类型的某些信息。这也就是traits提供给你的一个技术：它们允许你在编译期间取得某些类型信息。</p>
<p>&emsp;&emsp;traits并不是C++关键字，也不是一个预先定义好的组件；它们是一种技术，也是一个C++程序员共同遵守的协议。这个技术的要求之一是，它必须在内置类型和用户自定义类型上表现一致。举个例子，如果上述advance收到的实参是一个指针（例如const char*）和一个int，上述advance仍然能够有效运作，这意味着trait技术必须也能够实施于内置类型如指针身上。</p>
<p>&emsp;&emsp;“trait必须能够实施于内置类型”意味“类型内的嵌套信息”这样的“小伎俩”无法发挥作用，因为我们无法将信息嵌套于原始指针内。因此类型的traits信息必须位于类型之外。标准技术是把它放进一个template及其一个或多个特化版本中。这样的template在标准程序库中有若干个，其中针对迭代器者被命名为iterator_traits：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>;</span>  <span class="comment">//template，用来处理迭代器分类的相关信息</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;习惯上trait总是被实现为struct，但它们却又往往被称为trait class。</p>
<p>&emsp;&emsp;iterator_traits的运作方式是，针对每一个类型IterT，在struct iterator_traits&lt;IterT&gt;内一定声明了某个typedef名为iterator_category。这个typedef用来确认IterT的迭代器分类。</p>
<p>&emsp;&emsp;iterator_traits以两个部分来实现上述运作方式。首先它要求每一个“用户自定义的迭代器类型”必须嵌套一个typedef，名为iterator_category，用来确认适当的卷标结构（tag struct）。例如deque的迭代器可随机访问，所以一个针对deque迭代器而设计的class看起来会是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; ... &gt;  <span class="comment">//略写template参数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">                ...</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;list的迭代器可以双向行进，所以它们应该是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; ... &gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">                ...</span><br><span class="line">        &#125;;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至于iterator_traits，则只是用来响应iterator class的嵌套式typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> IterT::iterator_category iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这对于用户自定义类型倒是挺合理的，但对指针（也是一种迭代器）行不通，因为指针不可能嵌套typedef。iterator_traits的第二部分如下，专门用来对付指针。</p>
<p>&emsp;&emsp;为了支持指针迭代器，iterator_traits特别针对指针类型提供了一个偏特化版本。由于指针的行为与random access迭代器类似，所以iterator_traits为指针指定的迭代器类型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;IterT*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，你应该知道如何设计并实现一个traits class了：</p>
<ul>
<li>确认若干你希望将来可取得的类型相关信息。例如对迭代器而言，我们希望将来可取得其分类（category）。</li>
<li>为该信息选择一个名称（例如iterator_category）。</li>
<li>提供一个template和一组特化版本（例如上述所说的iterator_traits），内含你希望支持的类型相关信息。</li>
</ul>
<p>&emsp;&emsp;好，现在有了iterator_traits（实际上是std::iterator_traits，因为它是C++标准程序库的一部分），我们可以对advance实现先前的伪码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::iterator_category)</span><br><span class="line">       == <span class="keyword">typeid</span>(<span class="built_in">std</span>::random_access_iterator_tag))</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;虽然看起来挺合理的，但其实它并达不到我们的期望。首先它会导致编译问题，这个问题将在下一次文章中进行讨论。现在更加重要的问题是，IterT类型在编译期获知，所以iterator_traits&lt;IterT&gt;::iterator_category也可以在编译期间确定。但if语句却是在运行期才进行核对。为什么将可在编译期完成的事拖延到运行期才做呢？这不仅浪费时间，也造成可执行文件膨胀。</p>
<p>&emsp;&emsp;我们真正想要的是一个“条件式”（也就是可以履行if…else语句的职责）用来进行“编译期核对卷标类型”的动作。正好C++给我们提供了这个“桥梁”，那就是重载。</p>
<p>&emsp;&emsp;当你重载某个函数f，你必须详细描述出各个重载件的参数类型。当你调用f，编译器便根据传来的实参选择最适当的重载件。编译器认为“如果这个重载件最匹配传递过来的实参，就调用这个f；如果那个重载件最匹配，就调用那个f；如果第三个f最匹配，就调用第三个f”依此类推。这正是一个针对类型而发生的“编译期条件语句”。以下是这个技术的代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">std</span>::random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    iter += d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">std</span>::bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &gt;= <span class="number">0</span>) &#123; <span class="keyword">while</span> (d--) ++iter; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">while</span> (d++) --iter; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doAdvance</span><span class="params">(IterT&amp; iter, DistT d,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">std</span>::input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Negative distance"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(d--) ++iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于forward_iterator_tag继承自input_iterator_tag，所以上述doAdvance的input_iterator_tag版本也能够处理forward迭代器。这是iterator_tag struct继承关系带来的一个好处。</p>
<p>&emsp;&emsp;现在有了这些doAdvance重载版本，advance需要做的只是调用它们并额外传递一个对象，后者必须带有适当的迭代器分类。于是编译器运用重载解析机制调用适当的实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT, <span class="keyword">typename</span> DistT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">advance</span><span class="params">(IterT&amp; iter, DistT d)</span> </span>&#123;</span><br><span class="line">    doAdvance(iter, d,</span><br><span class="line">              <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们可以总结如何使用一个traits class了：</p>
<ul>
<li>建立一组重载函数（身份像劳工）或函数模版（例如doAdvance），彼此间的差异只在于各自的traits参数。令每个函数的实现码与其接受的traits信息相对应。</li>
<li>建立一个控制函数（身份像工头）或函数模版（例如advance），它调用上述那些“劳工函数”并传递traits class所提供的信息。</li>
</ul>
<blockquote>
<ul>
<li>traits class使得“类型相关信息”在编译期可用。它们以template和“template特化”来实现。</li>
<li>整合重载技术后，traits class有可能在编译期对类型执行“if…else”测试。</li>
</ul>
</blockquote>
<p>魔兽世界／6年／专精猎人，参与过大秘境竞速，有过名次奖励。<br>天涯明月刀／2年／专精神威，在本服务器第一的工会担任主t。<br>炉石传说／7年／基本每个月传说，本校炉石传说社团的创建人，自发组织过众多的校内比赛，本社团的一名团员参与并拿到黄金公开赛的亚军。<br>风暴英雄／6年／内测排名段位1，本校风暴英雄社团的创建人，组织了校队参加了风暴英雄的第一个比赛——雷锋杯，进入了32强。<br>阴阳师／4年／屯屯鼠，全图鉴，大名士低保人士。<br>神界原罪2/1年／全成就。<br>塞尔达：荒野之息／至今仍在玩。<br>宝可梦全系列／2008年至今，卡带收藏者。<br>守望先锋／2年／刚出那会，士兵76世界前500强。</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>wait函数簇</title>
    <url>/2021/05/11/wait%E5%87%BD%E6%95%B0%E7%B0%87/</url>
    <content><![CDATA[<hr>
<h1 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h1><p>&emsp;&emsp;当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是个异步事件（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。对于这种信号的系统默认动作是忽略它。当进程调用wait或waitpid时，会发生什么？</p>
<ul>
<li>如果所有子进程都还在运行，则阻塞。</li>
<li>如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，则立即出错返回。</li>
</ul>
<a id="more"></a>

<p>&emsp;&emsp;如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在随机时间点调用wait，则进程可能会阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回进程ID；若出错，返回0或-1</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这两个函数区别如下： </p>
<ul>
<li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一选项，可使调用者不阻塞。</li>
<li>waitpid并不等待在其调用之后的第一个终止子进程，它有若干选项，可以控制它所等待的进程。</li>
</ul>
<p>&emsp;&emsp;如果子进程已经终止，并且是一个僵死进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。如调用者阻塞而且它有多个子进程，则在其某一子进程终止时，wait就立即返回。因为wait返回终止子进程的进程ID，所以它总能了解是哪一个子进程终止了。</p>
<p>&emsp;&emsp;这两个函数的参数statloc是一个整型指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在它所指的单元内。如果不关心终止状态，则可将该参数指定为空指针。</p>
<p>&emsp;&emsp;依据传统，这两个函数返回的整型状态是由实现定义的。其中某些位表示退出状态（正常返回），其他位则指示信号编号（异常返回），有一位指示是否产生了core文件等。POSIX.1规定，终止状态用定义在<code>&lt;sys/wait.h&gt;</code>中的各个宏来查看。有4个互斥的宏可用来取得进程终止的原因，它们的名字都以WIF开始。基于这4个宏中哪一个值为真，就可选用其他宏来取得退出状态、信号编号等。这4个互斥的宏如下：</p>
<table>
<thead>
<tr>
<th>宏</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WIFEXITED(status)</td>
<td>若为正常终止子进程返回的状态，则为真。对于这种情况可执行WEXITSTATUS(status)，获取子进程传送给exit或_exit参数的低8位</td>
</tr>
<tr>
<td>WIFSIGNALED(status)</td>
<td>若为异常终止子进程返回的状态，则为真（接收到一个不捕捉的信号）。对于这种情况，可执行WTERMSIG(status)，获取使子进程终止的信号编号。另外，有些实现（非Single UNIX Specification）定义宏WCOREDUMP(status)，若已产生终止进程的core文件，则它返回真</td>
</tr>
<tr>
<td>WIFSTOPPED(status)</td>
<td>若为当前暂停子进程的返回的状态，则为真。对于这种情况，可执行WSTOPSIG(status)，获取使子进程暂停的信号编号</td>
</tr>
<tr>
<td>WIFCONTINUED(status)</td>
<td>若在作业控制暂停后已经继续的子进程返回了状态，则为真（POSIX.1的XSI扩展；仅用于waitpid）</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;如果一个进程有几个子进程，那么只要有一个子进程终止，wait就返回。如果要等待一个指定的进程终止（如果知道要等待进程的ID），那么该怎么做呢？在早期的UNIX版本中，必须调用wait，然后将其返回的进程ID和所期望的进程ID相比较。如果终止进程不是所期望的，则将该进程ID和终止进程保存起来，然后再次调用wait。反复这样做，直到所期望的进程终止。下一次又想等待一个待定进程时，先查看已终止的进程列表，若其中已有要等待的进程，则获取相关信息；否则调用wait。其实，我们需要的是等待一个特定进程的函数。POSIX定义了waitpid函数以提供这种功能（以及其他一些功能）。</p>
<p>&emsp;&emsp;对于waitpid函数中pid参数的作用如下：</p>
<ul>
<li>pid = -1：等待任一子进程。此种情况下，waitpid与wait等效。</li>
<li>pid &gt; 0 ：等待进程ID与pid相等的子进程。</li>
<li>pid = 0 ：等待组ID等于调用进程组ID的任一子进程。</li>
<li>pid &lt; -1：等待组ID等于pid绝对值的任一子进程。</li>
</ul>
<p>&emsp;&emsp;waitpid函数返回终止进程的进程ID，并将该子进程的终止状态存放在由statloc指向的存储单元中。对于wait，其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返回另一种出错）。但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错。</p>
<p>&emsp;&emsp;option参数使我们能进一步控制waitpid的操作。此参数或者是0，或者是以下常量按位或运算的结果。</p>
<blockquote>
<p>FreeBSD 8.0和Solaris 10支持另一个非标准的可选常量WNOWAIT，它使系统将终止状态已由waitpid返回的进程保持在等待状态，这样它可被再次等待。</p>
</blockquote>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WCONTINUED</td>
<td>若实现支持作业控制，那么由pid指定的任一子进程在停止后已经继续，但其状态尚未报告，则返回其状态（POSIX.1的XSI扩展）</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>若由pid指定的子进程并不是立即可用的，则waitpid不阻塞，此时其返回值为0</td>
</tr>
<tr>
<td>WUNTRACED</td>
<td>若某实现支持作业控制，而由pid指定的任一子进程已处于停止状态，并且其状态自停止以来还未报告过，则返回其状态。WIFSTOPPED宏确定返回值是否对应于一个停止的子进程</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;&emsp;waitpid函数提供了wait函数没有提供的3个功能：</p>
<ol>
<li>waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态。</li>
<li>waitpid提供了一个wait的非阻塞版本。有时希望获取一个子进程的状态，但不想阻塞。</li>
<li>waitpid通过WUNTRACED和WCONTINUED选项支持作业控制。</li>
</ol>
<h1 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h1><p>&emsp;&emsp;Single UNIX Specification包括了另一个取得进程终止状态的函数——waitid，此函数类似于waitpid，但提供了更多的灵活性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span>* infop, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">// 返回值：若成功，返回0；若出错，返回-1</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与waitpid相似，waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将与进程ID或进程组ID组合成一个参数。id参数的作用与idtype的值相关。该函数支持的idtype类型列在下表：</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>P_PID</td>
<td>等待一特定进程：id包括要等待子进程的进程ID</td>
</tr>
<tr>
<td>P_PGID</td>
<td>等待一特定进程组中的任一子进程：id包括要等待子进程的进程组ID</td>
</tr>
<tr>
<td>P_ALL</td>
<td>等待任一子进程：忽略id</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;options参数是以下各标志的按位或运算。这些标志指示调用者关注哪些状态变化。</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WCONTINUED</td>
<td>等待一进程，它以前曾被停止，此后又已继续，但其状态尚未报告</td>
</tr>
<tr>
<td>WEXITED</td>
<td>等待已退出的进程</td>
</tr>
<tr>
<td>WNOHANG</td>
<td>如无可用的子进程退出状态，立即返回而非阻塞</td>
</tr>
<tr>
<td>WNOWAIT</td>
<td>不破坏子进程退出状态。该子进程退出状态可由后续的wait、waitid或waitpid调用取得</td>
</tr>
<tr>
<td>WSTOPPED</td>
<td>等待一进程，它已经停止，但其状态尚未报告</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;WCONTINUED、WEXITED或WSTOPPED这3个常量之一必须在options参数中指定。</p>
<p>&emsp;&emsp;infop参数是指向siginfo结构的指针。该结构包含了造成子进程状态改变有关信号的详细信息。</p>
<h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>&emsp;&emsp;大多数UNIX系统实现提供了另外两个函数wait3和wait4。历史上，这两个函数是从UNIX系统的BSD分支沿袭下来的。它们提供的功能比POSIX.1函数wait、waitpid和waitid所提供的功能要多一个，这与附加参数有关。该参数允许内核返回由终止进程及其所有子进程使用的资源概况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个函数返回值：若成功，返回进程ID；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="keyword">int</span>* statloc, <span class="keyword">int</span> options, struct rusage* rusage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* statloc, <span class="keyword">int</span> options, struct rusage* rusage)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信息的次数等。    </p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>线程进程</tag>
      </tags>
  </entry>
  <entry>
    <title>为“异常安全”而努力是值得的</title>
    <url>/2020/08/11/%E4%B8%BA%E2%80%9C%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E2%80%9D%E8%80%8C%E5%8A%AA%E5%8A%9B%E6%98%AF%E5%80%BC%E5%BE%97%E7%9A%84/</url>
    <content><![CDATA[<hr>
<h1 id="为“异常安全”而努力是值得的"><a href="#为“异常安全”而努力是值得的" class="headerlink" title="为“异常安全”而努力是值得的"></a>为“异常安全”而努力是值得的</h1><p>&emsp;&emsp;异常安全有几分像是……呃……怀孕。但等等，在我们完成求偶之前，实在无法确实地谈论生育。</p>
<p>&emsp;&emsp;假设有个class用来表现夹带背景图案的GUI菜单。这个class希望用语多线程环境，所以它有个互斥器作为并发控制之用：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span></span>;  <span class="comment">//改变背景图像</span></span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;       <span class="comment">//互斥器</span></span><br><span class="line">    Image* bgImage;    <span class="comment">//目前的背景图像</span></span><br><span class="line">    <span class="keyword">int</span> imageChanges;  <span class="comment">//背景图像被改变的次数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是PrettyMenu的changeBackground函数的一个可能实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    lock(&amp;mutex);                 <span class="comment">//取得互斥器</span></span><br><span class="line">    <span class="keyword">delete</span> bgImage;               <span class="comment">//摆脱旧的背景图像</span></span><br><span class="line">    ++imageChanges;               <span class="comment">//修改图像变更次数</span></span><br><span class="line">    bgImage = <span class="keyword">new</span> Image(imgSrc);  <span class="comment">//安装新的背景图像</span></span><br><span class="line">    unlock(&amp;mutex);               <span class="comment">//释放互斥器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从“异常安全性”的观点来看，这个函数很糟。“异常安全”有两个条件，而这个函数没有满足其中任何一个条件。</p>
<p>&emsp;&emsp;当异常被抛出时，带有异常安全性的函数会：</p>
<ul>
<li><strong>不泄漏任何资源</strong>。上述代码没有做到这一点，因为一旦“new Image(imgSrc)”导致异常，对unlock的调用就绝不会执行。于是互斥器就永远被把持住了。</li>
<li><strong>不允许数据破坏</strong>。如果“new Image(imgSrc)”抛出异常，bgImage就是指向一个已被删除的对象，imageChanges也已被累加，而其实并没有新的图像被成功安装起来。</li>
</ul>
<p>&emsp;&emsp;解决资源泄漏的问题很容易，因为之前的“<a href="/2020/07/27/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/" title="以对象管理资源">以对象管理资源</a>”讨论过如何以对象管理资源，而在“<a href="/2020/07/28/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA/" title="在资源管理类中小心copying行为">在资源管理类中小心copying行为</a>”也导入了Lock class作为一种“确保互斥器被及时释放”的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">delete</span> bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = <span class="keyword">new</span> Image(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于“管理资源类”如Lock者，一个最棒的事情是，它们通常使函数更短。你看，不再需要调用unlock了不是吗？有个一般性规则是这么说的：较少的码就是较好的码，因为出错机会比较少，而且一旦有所改变，被误解的机会也比较少。</p>
<p>&emsp;&emsp;把资源泄漏抛诸脑后，现在我们可以专注解决数据的的败坏了。此刻我们需要做个抉择，但是在我们能够抉择之前，必须先面对一些用来定义选项的术语。</p>
<ul>
<li><p><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而破坏，所有对象都处于一种内部前后一致的状态（例如所有的class约束条件都继续获得满足）。然而程序的现实状态恐怕不可预测。举个例子，我们可以撰写changeBackground使得一旦有异常被抛出时，PrettyMenu对象可以继续拥有原背景图像，或是令它拥有某个缺省背景图像，但客户无法预期哪一种情况。如果想知道，他们恐怕必须调用某个成员函数以得知当时的背景图像是什么。</p>
</li>
<li><p><strong>强烈保证</strong>：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。</p>
<p>&emsp;&emsp;和这种提供强烈保证的函数共事，比如刚才说的那种只提供基本承诺的函数共事，容易多了，因为在调用一个提供强烈保证的函数后，程序状态只有两种可能：如预期般地到达函数成功执行后的状态，或回到函数被调用前的状态。与此成对比的是，如果调用一个只提供基本承诺的函数，而真的出现异常，程序有可能处于任何状态——只要那是个合法状态。</p>
</li>
<li><p><strong>不抛掷保证</strong>，承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用于内置类型身上的所有操作都提供nothrow保证。这是异常安全码中一个必不可少的关键基础材料。</p>
<p>&emsp;&emsp;如果我们假设，函数带着“空白的异常明细”者必为nothrow函数，似乎合情合理，其实不尽然。举个例子，考虑以下函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//空白的异常明细</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这并不是说doSomething绝不会抛出异常，而是说如果doSomething抛出异常，将是严重错误，会有你意想不到的函数被调用。实际上实际上doSomething也许完全没有提供任何异常保证。函数的声明式并不能够告诉你是否它是正确的、可移植的或高效的，也不能够告诉它是否提供任何异常安全性保证。所有那些性质都由函数的实现决定，无关乎声明。</p>
</li>
</ul>
<p>&emsp;&emsp;异常安全码必须提供上述三种保证之一。如果它不这样做，它就不具备异常安全性。因此，我们的抉择是，该为我们所写的每一个函数提供哪一种保证？除非面对不具异常安全性的传统代码，否则你应该只在一种情况下才不提供任何异常安全保证：你那“天才班”需求分析团队确认你的应用程序有“泄漏资源”并“在执行过程中带着败坏数据”的需要。</p>
<p>&emsp;&emsp;一般而言你应该会想提供可实施之最强烈保证。从异常安全性的观点视之，nothrow函数很棒，但我们很难在C part of  C++领域中完全没有调用任何一个可能抛出异常的函数。任何使用动态内存的东西如果无法找到足够内存以满足需求，通常便会抛出一个bad_alloc异常。是的，可能的话请提供nothrow保证，但对大部分函数而言，抉择往往落在基本保证和强烈保证之间。</p>
<p>&emsp;&emsp;对changeBackground而言，提供强烈保证几乎不困难。首先改变PrettyMenu的bgImage成员变量的类型，从一个类型为Image*的内置指针改为一个“用于资源管理”的智能指针。坦白说，这个好构想纯粹只是帮助我们防止资源泄漏。它对“强烈之异常安全保证”的帮助仅仅只是强化了“<a href="/2020/07/27/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/" title="以对象管理资源">以对象管理资源</a>”的论点：以对象（例如智能指针）管理资源是良好设计的根本。以下代码中我使用shared_ptr。</p>
<p>&emsp;&emsp;第二，我们重新排列changeBackground内的语句次序，使得在更换图像之后才累加imageChanges，一般而言这是个好策略：不要为了表示某件事情发生而改变对象状态，除非那件事情真的发生了。</p>
<p>&emsp;&emsp;下面是结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    bgImage.reset(<span class="keyword">new</span> Image(imgSrc));  <span class="comment">//以“new Image”的执行结果设定bgImage内部指针</span></span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意，这里不再需要手动delete旧图像，因为这个动作已经由智能指针内部处理掉了。此外，删除动作只发生在新图像被成功创建之后。更正确地说，shared_ptr::reset函数只有在其参数被成功生成之后才会被调用。delete只在reset函数内被使用，所以如果从未进入那个函数也就绝对不会使用delete。也请注意，以对象管理资源再次缩减了changeBackground的长度。</p>
<p>&emsp;&emsp;如我之前所言，这两个改变几乎足够让changeBackground提供强烈的异常安全保证。美中不足的是参数imgSrc。如果Image构造函数抛出异常，有可能输入流的读取记号已被移走，而这样的搬移对程序其余部分是一种可见的状态改变。所以changeBackground在解决这个问题之前只提供基本的异常安全保证。</p>
<p>&emsp;&emsp;然而，让我们把它放在一旁，佯装changeBackground的确提供了强烈保证。有个一般化的设计策略很典型地回导致强烈保证，很值得熟悉它。这个策略被称为copy and swap。原则很简单：为你打算修改的对象（原件）做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍然保持未改变状态。待所有改变都成功后，再将修改过的那个副本和原对象在一个不抛出异常的操作中置换。</p>
<p>&emsp;&emsp;实现上通常是将所有“隶属对象的数据”从原对象放进另一个对象内，然后赋予原对象一个指针，指向那个所谓的实现对象（即副本）。这种手法常被称为pimpl idiom。对PrettyMenu而言，典型写法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PMImpl</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Image&gt; bgImage;</span><br><span class="line">    <span class="keyword">int</span> imageChange;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrettyMenu</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrettyMenu::changeBackground</span><span class="params">(<span class="built_in">std</span>::istream&amp; imgSrc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="function">Lock <span class="title">m1</span><span class="params">(&amp;mutex)</span></span>;  <span class="comment">//获得mutex的副本数据</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; <span class="title">pNew</span><span class="params">(<span class="keyword">new</span> PMImpl(*pImpl))</span></span>;</span><br><span class="line">  </span><br><span class="line">    pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc));  <span class="comment">//修改副本</span></span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    </span><br><span class="line">    swap(pImpl, pNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此例之中我选择让PMImpl成为一个struct而不是一个class，这是因为PrettyMenu的数据封装性已经由于“pImpl是private”而获得了保证。如果令PMImpl为一个class，虽然一样好，有时候却不太方便（但也保持了面向对象纯度）。如果你要，也可以将PMImpl嵌套于PrettyMenu内，但打包问题（例如“独立撰写异常安全码”）是我们这里所挂虑的事。</p>
<p>&emsp;&emsp;“copy-and-swap”策略是对对象状态做出“全有或全无”改变的一个很好办法，但一般而言它并不保证整个函数有强烈的异常安全性。为了解原因，让我吗考虑changeBackground的一个抽象概念：someFunc。它使用copy-and-swap策略，但函数内还包含对另外两个函数f1和f2的调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...    <span class="comment">//对local状态做一份副本</span></span><br><span class="line">    f1();</span><br><span class="line">    f2();</span><br><span class="line">    ...    <span class="comment">//对修改后的状态置换过来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;很明显，如果f1或f2的异常安全性必“强烈保证”低，就很难让someFunc成为“强烈异常安全”。举个例子，假设f1只提供基本保证，那么为了让someFunc提供强烈保证，我们必须写出代码获得调用f1之前的整个程序状态、捕捉f1的所有可能异常、然后恢复原状态。</p>
<p>&emsp;&emsp;如果f1和f2都是“强烈异常安全”，情况并不就此好转。毕竟如果f1圆满结束，程序状态在任何方面都可能有所改变，因此如果f2随后抛出异常，程序状态和someFunc被调用前并不相同，甚至当f2没有改变任何东西时也是如此。</p>
<p>&emsp;&emsp;问题出在“连带影响”。如果函数只操作局部性状态，便相对容易地提供强烈保证。但是当函数对“非局部性数据”有连带影响时，提供强烈保证就困难得多。举个例子，如果调用f1带来的影响是某个数据库被改动了，那就很难让someFunc具备强烈安全性。一般而言在“数据库修改动作”送出之后，没有什么做法可以取消并恢复数据库旧观，因为数据库的其它客户很可能已经看到这一笔新数据。</p>
<p>&emsp;&emsp;这些议题想必会阻止你为函数提供强烈保证——即使你想那么做。另一个主题是效率。copy-and-swap的关键在于“修改对象数据的副本，然后在一个不抛异常的函数中将修改后的数据和原件置换”，因此必须为每一个即将被改动的对象做出一个副本，那得耗用你可能无法（或不愿意）供应的时间和空间。没错，大家都希望提供“强烈保证”：当它可被实现时你的确应该提供它，但“强烈保证”并非在任何时候都显得实际。</p>
<p>&emsp;&emsp;当“强烈保证”不切实际时，你就必须提供“基本保证”。现实中你或许会发现，你可以为某些函数提供强烈保证，但效率和复杂度带来的成本会使它对许多人而言摇摇欲坠。只要你曾经付出适当的心力试图提供强烈保证，万一实际不可行，使你退而求其次地只提供基本保证，任何人都不该因此责难你。对许多函数而言，“异常安全性之基本保证”是一个绝对通情达理的选择。</p>
<p>&emsp;&emsp;这令我想到怀孕，一位女性若非怀孕，就是没怀孕。不可能说她“部分怀孕”。同样的道理，一个软件系统要不就具备异常安全性，要不就全然否定，没有所谓的“局部异常安全性”。如果系统内有一个函数不具备异常安全性，整个系统就不具备异常安全性，因为调用那个（不具备异常安全性的）函数有可能导致资源泄漏或数据结构败坏。不幸的是许多老旧C++代码并不具备异常安全性，所以今天许多系统仍然不能够说是“异常安全”的，因为它们并入了一些并非“异常安全”的代码。</p>
<p>&emsp;&emsp;没有理由让这种情况永垂不朽。当你撰写新码或修改旧码时，请仔细想想如何让它具备异常安全性。首先是“以对象管理资源”，那可阻止资源泄漏。然后是挑选三个“异常安全保证”中的某一个实施于你所写的每一个函数身上。你应该挑选“现实可施作”条件下的最强烈等级，只有当你的函数调用了传统代码，才别无选择地将它设为“无任何保证”。将你的决定写成文档，这一来是为你的函数用户着想，二来是为将来的维护者着想。函数的“异常安全性保证”是其可见接口的一部分，所以你应该慎重选择，就像选择函数接口的其它任何部分一样。</p>
<p>&emsp;&emsp;四十年前，满载goto的代码被视为一种美好实践，而今我们却致力于写出结构化控制流。二十年前，全局数据被视为一种美好实践，而今我们却致力于数据的封装。十年前，撰写“未将异常考虑在内”的函数被视为一种美好实践，而今我们致力于写出“异常安全码”。</p>
<blockquote>
<p>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</p>
<p>“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</p>
<p>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>为多态基类声明virtual析构函数</title>
    <url>/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="为多态基类声明virtual析构函数"><a href="#为多态基类声明virtual析构函数" class="headerlink" title="为多态基类声明virtual析构函数"></a>为多态基类声明virtual析构函数</h1><p>&emsp;&emsp;有许多种做法可以记录时间，因此，设计一个TimeKeeper base class和一些derived classes作为不同的计时方法，相当合情合理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicClock</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;  <span class="comment">//原子钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterClock</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;  <span class="comment">//水钟</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WristWatch</span>:</span> <span class="keyword">public</span> TimeKeeper &#123; ... &#125;;  <span class="comment">//腕表</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;许多客户只想在程序中使用时间，不想操心时间如何计算等细节，这时候我们可以设计factory函数，返回指针指向一个计时对象。Factory函数会“返回一个base class指针，指向新生成的derived class对象”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TimeKeeper* <span class="title">getTimeKeeper</span><span class="params">()</span></span>;  <span class="comment">//返回一个指针，指向一个</span></span><br><span class="line">                              <span class="comment">//TimeKeeper派生类的动态分配对象</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为遵守factory函数的规矩，被getTimeKeeper()返回的对象必须位于heap，因此为了避免泄漏内存和其它资源，将factory函数返回的每一个对象适当地delete掉很重要：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TimeKeeper* ptk = getTimeKeeper();  <span class="comment">//从TimeKeeper继承体系</span></span><br><span class="line">                                    <span class="comment">//获得一个动态分配对象。</span></span><br><span class="line">...                                 <span class="comment">//运用它...</span></span><br><span class="line"><span class="keyword">delete</span> ptk;                         <span class="comment">//释放它，避免资源泄漏。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码有一个根本性弱点：纵使客户把每一件事都做对了，仍然没办法知道程序是如何行动的。</p>
<p>&emsp;&emsp;问题出在getTimeKeeper返回的指针指向一个derived class对象，而那个对象却经由一个base class指针被删除，而目前的base class有个non-virtual析构函数。这将引来灾难，因为C++明确指出，当derived class对象经由一个base class指针被删除，而该base class带着一个non-virtual析构函数，其结果将是未定义的——实际执行时通常发生的是对象的derived成分没被销毁。如果getTimeKeeper返回指针指向一个AtomicClock对象，其内的AtomicClock成分（也就是声明于AtomicClock class内的成员变量）很可能没被销毁，而AtomicClock的析构函数也未能执行起来。然而其base class成分（也就是TimeKeeper这一部分）通常会被销毁，于是形成了一个诡异的“局部销毁”对象。这可是形成资源泄漏、败坏的数据结构、在调试器上浪费许多时间的绝佳途径喔。</p>
<p>&emsp;&emsp;消除这个问题的做法很简单：给base class一个virtual析构函数。此后删除derived class对象就会如我们所愿。没错，它会销毁整个对象，包括所有的derived class成分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeKeeper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    <span class="keyword">virtual</span> ~TimeKeeper();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">TimeKeeper* ptk = getTimeKeeper();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ptk;  <span class="comment">//现在，行为正确</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;像TimeKeeper这样的base class除了析构函数之外通常还有其它virtual函数，因为virtual函数的目的是允许derived class的实现得以自定义。例如TimeKeeper就可能拥有一个virtual getCurrentTime，它在不同的derived classes中有不同的实现代码。任何class只要带有virtual函数都几乎确定应该也有一个virtual析构函数。</p>
<p>&emsp;&emsp;如果class不含virtual函数，通常意味着它并不是被用作base class。当class不被用作base class，令其析构函数为virtual往往是个馊主意。考虑一个用来表示二维空间坐标的class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xCoord, <span class="keyword">int</span> yCoord);</span><br><span class="line">    ~Point();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果int占用32bits，那么Point对象可能塞入一个64-bit缓存器中。更有甚者，这样一个Point对象可被当作一个“64-bit量”传给其他语言如C或FORTRAN编写的函数。然而当Point的析构函数是virtual，形势发生了变化。</p>
<p>&emsp;&emsp;欲实现出virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数该被调用。这份信息通常是由一个所谓vptr（virtual table pointer）指针指出。vptr指向一个由函数指针构成的数组，称为vtbl（virtual table）；每一个带有virtual函数的class都有一个相应的vtbl。当对象调用某一virtual函数。实际被调用的函数取决于该对象的vptr所指的那个vtbl——编译器在其中寻找适当的函数指针。</p>
<p>&emsp;&emsp;virtual函数的实现细节不重要。重要的是如果Point class内含virtual函数，其对象的体积会增加：在32-bit计算机体系结构中将占用64bits（为了存放两个ints）至96bits（两个ints加上vptr）；在64-bits计算机体系结构中可能占用64-128bits，因为指针在这样的计算机结构中占64bits。因此，为Point添加一个vptr会增加其对象大小达50%～100%！Point对象不再能够塞入一个64-bit缓存器，而C++的Point对象也不再和其他语言（如C）内的相同声明有着一样的结构（因为其他语言的对应物应该没有vptr），因此也就不再可能把它传递至（或接受自）其他语言所写的函数，除非我们明确补偿vptr——这属于实现细节，也因此不再具有移植性。</p>
<p>&emsp;&emsp;因此，无端地将所有classes的析构函数声明为virtual，就像从未声明它们为virtual一样，都是错误的。许多人的心得是：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。</p>
<h1 id="切勿将STL容器、标准string等class当作base-class"><a href="#切勿将STL容器、标准string等class当作base-class" class="headerlink" title="切勿将STL容器、标准string等class当作base class"></a>切勿将STL容器、标准string等class当作base class</h1><p>&emsp;&emsp;即使class完全不带virtual函数，被“non-virtual析构函数问题”给咬伤还是有可能的。举个例子，标准string不含任何virtual函数，但有时候程序员会错误地把它当作base class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialString</span>:</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">string</span> &#123;  <span class="comment">//馊主意！std::string有个</span></span><br><span class="line">    ...                                    <span class="comment">//non-virtual析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;乍看之下似乎无害，但如果我们在程序任意某处无意间将一个pointer-to-SpecialString转换为一个pointer-to-string，然后将转换的那个string指针delete掉，我们将立刻被流放到“行为不正确”的荒地上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SpecialString* pss = <span class="keyword">new</span> SpecialString(<span class="string">"Impending Doom"</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* ps;</span><br><span class="line">...</span><br><span class="line">ps = pss;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;  <span class="comment">//未定义！实际中的*ps的SpecialString资源会泄漏，</span></span><br><span class="line">            <span class="comment">//因为SpecialString析构函数没被调用。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;包括所有STL容器如vector，list，set，tr1::unordered_map等等，如果我们企图继承一个标准容器或任何其他“带有non-virtual析构函数”的class，拒绝这个诱惑吧！很不幸C++没有提供类似Java的final classes或C#的sealed classes那样的“禁止派生”机制。</p>
<p>&emsp;&emsp;有时候令class带一个pure virtual析构函数，可能颇为便利。pure virtual函数导致abstract class——也就是不能被实体化的class。也就是说，我们不能为这种类型创建对象。然而有时候我们希望拥有抽象class，但手上没有任何pure virtual函数，怎么办？由于抽象class总是企图被当作一个base class来用，而又由于base class应该有个virtual析构函数，并且由于pure virtual函数会导致抽象class，因此解法很简单：为我们希望它成为抽象的那个class声明一个pure virtual析构函数。下面是个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span> &#123;</span>  <span class="comment">//AWOV = "Abstract w/o to Virtuals"</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;  <span class="comment">//声明pure virtual析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个class有一个pure virtual函数，所以它是个抽象class，又由于它有个virtual析构函数，所以我们不需要担心析构函数的问题，然而这里有个窍门：我们必须为这个pure virtual析构函数提供一份定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AWOV::~AWOV() &#123;&#125;  <span class="comment">//pure virtual析构函数的定义</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;析构函数的运作方式是，最深层派生的那个class其析构函数最先被调用，然后是其每一个base class的析构函数被调用。编译器会在AWOV的derived class的析构函数中创建一个对～AWOV的调用动作，所以我们必须为这个函数提供一份定义。如果不这样做，编译器会发出抱怨。</p>
<p>&emsp;&emsp;“给base class一个virtual析构函数”，这个规则只适用于polymorphic（带有多态性质的）base class身上。这种base class的设计目的是为了用来“通过base class接口处理derived class对象”。TimeKeeper就是一个polymorphic base class，因为我们希望处理AtomicClock和WaterClock对象，纵使我们只有TimeKeeper指针指向它们。</p>
<p>&emsp;&emsp;并非所有base class的设计目的都是为了多态用途。例如标准string和STL容器都不被设计作为base class使用，更别提多态了。某些class的设计目的是作为base class使用，但不是为了多态用途。这样的class如input_iterator_tag等，它们并非被设计用来“经由base class接口处理derived class对象”，因此它们不需要virtual析构函数。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li><p>Polymorphic（带多态性质的）base class应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。</p>
</li>
<li><p>Class的设计目的如果不是作为base class使用，或不是为了具备多态性，就不该声明virtual析构函数。</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>了解C++默默编写并调用哪些函数</title>
    <url>/2020/07/20/%E4%BA%86%E8%A7%A3C++%E9%BB%98%E9%BB%98%E7%BC%96%E5%86%99%E5%B9%B6%E8%B0%83%E7%94%A8%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="了解C-默默编写并调用哪些函数"><a href="#了解C-默默编写并调用哪些函数" class="headerlink" title="了解C++默默编写并调用哪些函数"></a>了解C++默默编写并调用哪些函数</h1><p>&emsp;&emsp;对于一个class来说，如果我们自己没有声明，编译器就会为它声明（编译器版本的）一个copy构造函数，一个copy assignment操作符和一个析构函数。此外如果我们没有声明任何构造函数，编译器也会为我们声明一个default构造函数。所有这些函数都是public和inline。因此，如果我们写下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这就好像写下这样的代码：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Empty() &#123; ... &#125;</span><br><span class="line">    Empty(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">    ~Empty() &#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    Empty <span class="keyword">operator</span>=(<span class="keyword">const</span> Empty&amp; rhs) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只要当这些函数被需要（被调用）时，它们才会被编译器创建出来。程序中需要它们是很平常的事。下面代码造成上述每一个函数被编译器产出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Empty e1;  <span class="comment">//default构造函数</span></span><br><span class="line">           <span class="comment">//析构函数</span></span><br><span class="line"><span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;  <span class="comment">//copy构造函数</span></span><br><span class="line">e2 = e1;       <span class="comment">//copy assignment操作符</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;default构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码，像是调用base class和non-static成员变量的构造函数和析构函数。注意，编译器产出的析构函数是个non-virtual，除非这个class的base class自身声明有virtual析构函数（这种情况下这个函数的虚属性主要来自base class）。</p>
<p>&emsp;&emsp;至于copy构造函数和copy assignment操作符，编译器创建的版本只是单纯地将来源对象的每一个non-static成员变量拷贝到目标对象。考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NamedObject(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> T&amp; value);</span><br><span class="line">    NamedObject(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    T objectValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于其中声明了一个构造函数，编译器于是不再为它创建default构造函数。</p>
<p>&emsp;&emsp;NamedObject既没有声明copy构造函数，也没有声明copy assignment操作符，所以编译器会为它创建那些函数（如果它们被调用的话）。现在，看看copy构造函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">no1</span><span class="params">(<span class="string">"Smallest Prime Number"</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">no2</span><span class="params">(no1)</span></span>;  <span class="comment">//调用copy构造函数</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编译器生成的copy构造函数必须以no1.nameValue和no1.objectValue为初值设定no2.nameValue和no2.objectValue。两者之中，nameValue的类型是string，而标准string有个copy构造函数，所以no2.nameValue的初始化方式是调用string的copy构造函数并以no1.nameValue为实参。另一个成员NamedObject&lt;int&gt;objectValue的类型是int，这是个内置类型，所以no2.objectValue会以“拷贝no1.objectValue内的每一个bits”来完成初始化。</p>
<p>&emsp;&emsp;编译器为NamedObject&lt;int&gt;所生成的copy assignment操作符，其行为基本上与copy构造函数如出一辙，但一般而言只有当生成的代码合法且有适当机会证明它有意义，其表现才会如我先前所说。万一两个条件有一个不符合，编译器会拒绝为class生成operator=。</p>
<p>&emsp;&emsp;举个例子，假设NameObject定义如下，其中nameValue是个reference to string，objectValue是个const T：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NamedObject(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value);</span><br><span class="line">    ...</span><br><span class="line">   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    <span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑下面会发生什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">newDog</span><span class="params">(<span class="string">"Alice"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">oldDog</span><span class="params">(<span class="string">"Bob"</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(newDog, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">NamedObject&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(oldDog, <span class="number">36</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p = s;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;赋值之后p.nameValue应该指向s.nameValue所指的那个string吗？也就是说reference自身可被改动吗？如果可以，那可就不得了了，因为C+并不允许“让reference改指向不同对象”。换一个想法，p.nameValue所指的那个string对象该被修改，进而影响“持有pointers或references而且指向该string”的其它对象吗？也就是对象不被直接牵扯到赋值操作内？编译器生成的copy assignment操作符究竟该如何做呢？</p>
<p>&emsp;&emsp;面对这个难题，C++的响应是拒绝编译那一行赋值动作。如果我们打算在一个“内含reference成员”的class内支持赋值操作，我们必须自己定义copy assignment操作符。面对“内含const成员”的classes，编译器的反应也一样。更改const成员是不合法的，所以编译器不知道如何在它自己生成的赋值函数内面对它们。最后还有一种情况：如果某个base class将copy assignment操作符声明为private，编译器将拒绝为其derived classes生成一个copy assignment操作符。毕竟编译器为derived classes所生成的copy assignment操作符想象中可以处理base class成分，但它们当然无法调用derived classes无权调用的成员函数。编译器两手一摊，无能为力。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li>编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>了解typename的双重意义</title>
    <url>/2020/11/14/%E4%BA%86%E8%A7%A3typename%E7%9A%84%E5%8F%8C%E9%87%8D%E6%84%8F%E4%B9%89/</url>
    <content><![CDATA[<hr>
<h1 id="了解typename的双重意义"><a href="#了解typename的双重意义" class="headerlink" title="了解typename的双重意义"></a>了解typename的双重意义</h1><p>&emsp;&emsp;提一个问题：以下template声明式中，class和typename有什么不同？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Widget</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Widget</span>;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;答案：没有不同。当我们说明template类型参数，class和typename的意义完全相同。某些程序员始终比较喜欢class，因为可以少打几个字。其他人（包括我）比较喜欢typename，因为它暗示参数并非一定得是个class类型。少数开发人员在接受任何类型时使用typename，而在只接受用户自定义类型时保留旧式的class。然而从C++的角度来看，说明template参数时，不论使用关键字class或typename，意义完全相同。</p>
<a id="more"></a>

<p>&emsp;&emsp;然而C++并不总是把class和typename视为等价。有时候你一定得使用typename。为了解其时机，我们必须先谈谈你可以在template内指涉的两种名称。</p>
<p>&emsp;&emsp;假设我们有个template function，接受一个STL兼容容器为参数，容器内持有的对象可被赋值为int。进一步假设这个函数仅仅只是打印其第二元素值。这是一个无聊的函数，以无聊的方式实现，而且如稍后所言，它甚至不能通过编译。但请暂时漠视那些事，下面是实践这个愚蠢想法的一种方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;                 <span class="comment">//这不是有效的C++代码</span></span><br><span class="line">    <span class="keyword">if</span>(container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.<span class="built_in">begin</span>())</span></span>;  <span class="comment">//取得第一元素的迭代器</span></span><br><span class="line">        ++iter;                                     <span class="comment">//将iter移往第二元素</span></span><br><span class="line">        <span class="keyword">int</span> value = *iter;                          <span class="comment">//将该元素复制到某个int</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value;                         <span class="comment">//打印那个int</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我在代码中特别强调两个local变量iter和value。iter的类型是C::const_iterator，实际是什么必须取决于template参数C。template内出现的名称如果相依于某个template参数，称之为从属名称。如果从属名称在class内呈嵌套状，我们称它为嵌套从属名称。C::const_iterator就是这样一个名称。实际上它还是个嵌套从属类型名称，也就是个嵌套从属名称并且指涉某类型。</p>
<p>&emsp;&emsp;print2nd内的另一个local变量是value，其类型是int。int是一个并不依赖任何template参数的名称。这样的名称是谓非从属名称。我不知道为什么不叫独立名称。如果你和我一样认为术语“non-dependent”令人憎恶，你我之间起了共鸣。但毕竟“non-dependent”已被定为这一类名称的术语，所以请和我一样，眨眨眼然后顺从它吧。</p>
<p>&emsp;&emsp;嵌套从属名称有可能导致解析困难。举个例子，假设我们令print2nd更愚蠢些，这样起头：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    C::const_iterator* x;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来好像我们声明x为一个local变量，它是个指针，指向一个C::const_iterator。但它之所以被那么认为，只因为我们“已经知道”C::const_iterator是个类型。如果C::const_iterator不是个类型呢？如果C有个static成员变量而碰巧被命名为const_iterator，或如果x碰巧是个global变量名称呢？那样的话上述代码就不再是声明一个local变量，而是一个相乘动作：C::const_iterator乘以x。当然啦，这听起来有点疯狂，但却是可能的，而撰写C++解析器的人必须操心所有可能的输入，甚至是这么疯狂的输入。</p>
<p>&emsp;&emsp;在我们知道C是什么之前，没有任何办法可以知道C::const_iterator是否为一个类型。而当编译器开始解析template print2nd时，尚未确认C是什么东西。C++有个规则可以解析此一歧义状态：如果解析器在template中遭遇一个嵌套从属名称，它便假设这名称不是个类型，除非你告诉它是，所以缺省情况下嵌套从属名称不是类型。此规则有个例外，稍后我会提到。</p>
<p>&emsp;&emsp;把这些记在心上，现在再次看看print2nd起始处：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function">C::const_iterator <span class="title">iter</span><span class="params">(container.<span class="built_in">begin</span>())</span></span>;  <span class="comment">//这个名称被假设为非类型</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在应该很清楚为什么这不是有效的C++代码了吧。iter声明式只有在C::const_iterator是个类型时才合理，但我们并没有告诉C++说它是，于是C++假设它不是。若要矫正这个形势，我们必须告诉C++说C::const_iterator是个类型。只要紧临它之前放置关键字typename即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;  <span class="comment">//现在，这是合法的C++代码了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2nd</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(container.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">typename</span> C::const_iterator <span class="title">iter</span><span class="params">(container.<span class="built_in">begin</span>())</span></span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般性规则很简单：任何时候当你想要在template中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字typename。（再提醒一次，很快我会谈到一个例外。）</p>
<p>&emsp;&emsp;typename只被用来验明嵌套从属名称：其他名称不该有它存在。例如下面这个function template，接受一个容器和一个“指向该容器”的迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;            <span class="comment">//允许使用“typename”（或“class”） </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp; container,       <span class="comment">//不允许使用“typename”</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">typename</span> C::iterator iter)</span></span>;  <span class="comment">//一定要使用“typename”</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述的C并不是嵌套从属类型名称（它并非嵌套于任何“取决于template参数”的东西内），所以声明container时并不需要以typename为前导，但C::iterator是个嵌套从属类型名称，所以必须以typename为前导。</p>
<p>&emsp;&emsp;“typename必须作为嵌套从属类型名称的前缀词”这一规则的例外是，typename不可以出现在base class list内的嵌套从属类型名称之前，也不可在member initialization list（成员初值列）中作为base class修饰符。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span><span class="params">(<span class="keyword">int</span> x)</span> : Base&lt;T&gt;::<span class="title">Nested</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的不一致性真令人恼恨，但一旦你有了一些经验，勉勉强强还能接受它。</p>
<p>&emsp;&emsp;让我们看看最后一个typename例子，那是你将在真实程序中看到的代表性例子。假设我们正在撰写一个function template，它接受一个迭代器，而我们打算为该迭代器指涉的对象做一份local复件temp。我们可以这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::<span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;别让std::iterator_traits&lt;IterT&gt;::value_type惊吓了你，那只不过是标准traits class的一种运用，相当于说“类型为IterT之对象所指之物的类型”。这个语句声明一个local变量（temp），使用IterT对象所指物的相同类型，并将temp初始化为iter所指物。如果IterT是vector&lt;int&gt;::iterator，temp的类型就是int。如果IterT是vector&lt;string&gt;::iterator，temp的类型就是string。由于std::iterator_traits&lt;IterT&gt;::value_type是个嵌套从属类型名称，所以我们必须在它之前放置typename。</p>
<p>&emsp;&emsp;如果你认为std::iterator_traits&lt;IterT&gt;::value_type读起来不畅快，想象一下打那么长的字又是什么光景。如果你像大多数程序员一样，认为多打几次这些字实在很恐怖，那么你应该会想建立一个typedef。对于traits成员名称如value_type。普遍的习惯是设定typedef名称用以代表某个traits成员名称，于是常常可以看到类似这样的local typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">workWithIterator</span><span class="params">(IterT iter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;IterT&gt;::value_type value_type;</span><br><span class="line">    <span class="function">value_type <span class="title">temp</span><span class="params">(*iter)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多程序员最初认为把“typedef typename”并列颇不和谐，但它实在是指涉“嵌套从属类型名称”的一个合理附带结果。你很快会习惯它，毕竟你有强烈的动机——你希望多打几次typename std::iterator_traits&lt;IterT&gt;::value_type吗？</p>
<p>&emsp;&emsp;作为结语，我应该提出，typename相关规则在不同的编译器上有不同的实践。某些编译器接受的代码原本该有typename却遗漏了；原本不该有typename却出现了；还有少数编译器（通常是较旧版本）根本就拒绝typename。这意味typename和“嵌套从属类型名称”之间的互动，也许会在移植性方面带给你某种温和的头疼。</p>
<blockquote>
<ul>
<li>声明template参数时，前缀关键字class和typename可互换。</li>
<li>请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class修饰符。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>令operator=返回一个reference to *this</title>
    <url>/2020/07/25/%E4%BB%A4operator=%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAreference%20to%20*this/</url>
    <content><![CDATA[<hr>
<h1 id="令operator-返回一个reference-to-this"><a href="#令operator-返回一个reference-to-this" class="headerlink" title="令operator=返回一个reference to *this"></a>令operator=返回一个reference to *this</h1><p>&emsp;&emsp;关于赋值，有趣的是我们可以把它们写成连锁形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样有趣的是，赋值采用右结合律，所以上述连锁赋值被解析为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = (y = (z = <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里1先被赋值给z，然后其结果再被赋值给y，然后其结果再被赋值给x。</p>
<a id="more"></a>

<p>&emsp;&emsp;为了实现“连锁赋值，赋值操作符必须返回一个reference指向操作符的左侧实参。这是我们为class实现赋值操作符时应该遵循的协议：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//返回类型是个reference，指向当前对象</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;                       <span class="comment">//返回左侧对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//这个协议适用于+=，-=，*=等等</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">int</span> rhs) &#123;             <span class="comment">//此函数也适用，</span></span><br><span class="line">        ...                                  <span class="comment">//即使此操作符的参数类型不符合协定</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意，这只是个协议，并无强制性。如果不遵循它，代码一样可以通过编译。然而这份协议被所有内置类型和标准程序库提供的类型如string，vector，complex，tr1::shared_ptr或即将提供的类型共同遵守。因此除非我们有一个标新立异的好理由，不然还是从众吧。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li>令赋值操作符返回一个reference to *this。</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>以对象管理资源</title>
    <url>/2020/07/27/%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<hr>
<h1 id="以对象管理资源"><a href="#以对象管理资源" class="headerlink" title="以对象管理资源"></a>以对象管理资源</h1><p>&emsp;&emsp;假设我们使用一个用来塑模投资行为的程序库，其中各式各样的投资类型继承自一个root class Investment：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span> ... &#125;;  <span class="comment">//投资类型体系中的root class</span></span><br></pre></td></tr></table></figure>

<p>进一步假设，这个程序库系通过一个工厂函数供应我们某特定的Investment对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;  <span class="comment">//返回指针，指向Investment继承体系内的动态分配对象。</span></span><br><span class="line">                                 <span class="comment">//调用者有责任删除它，这里为了简化，刻意不写参数。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如上注释所述，createInvestment的调用端使用了函数返回的对象后，有责任删除之。现在考虑有个f函数履行了这个责任：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Investment* pInv = createInvestment();  <span class="comment">//调用factory函数</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">delete</span> pInv;                            <span class="comment">//释放pInv所指对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这看起来妥当，但若干情况下f可能无法删除它得自createInvestment的投资对象——或许因为“…”区域内的一个过早的return语句。如果这样一个return被执行起来，控制流就绝不会触及delete语句。类似情况还可能发生在很多其他地方。</p>
<p>&emsp;&emsp;为确保createInvestment返回的资源总是被释放，我们需要将资源放进对象内，当控制流厉害f，该对象的析构函数会自动释放那些资源。把资源放进对象内，我们便可依赖C++的“析构函数自动调用机制”确保资源被释放。</p>
<p>&emsp;&emsp;我们可以使用“引用计数型智能指针”（RCSP）。所谓RCSP也是个智能指针，持续追踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源。RCSP提供的行为类似垃圾回收，不同的是RCSP无法打破环状引用（例如两个其实已经没被使用的对象彼此互指，因而好像还处于“被使用”状态）。</p>
<p>&emsp;&emsp;C++标准库中的shared_ptr就是个RCSP，所以我们可以这样写f：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//调用factory函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;  <span class="comment">//经由share_ptr析构函数自动删除pInv</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;share_ptr在其析构函数内做delete而不是delete[]动作。这意味着在动态分配而得的array身上使用shared_ptr是个馊主意。尽管如此，可叹的是，那么做仍能通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>])</span></span>;  <span class="comment">//馊主意！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们或许会惊讶地发现，并没有针对“C++动态分配数组”而设计的类似shared_ptr这样的东西。这是因为vector和sting几乎总是可以取代动态分配而得的数组。如果你们还是认为拥有针对数组而设计、类似shared_ptr这样的class较好，看看Boost吧。在那儿我们会很高兴地发现boost::scoped_array和boost::shared_array class，它们都提供我们想要的行为。</p>
<blockquote>
<p>为防止资源泄漏，务必使用shared_ptr这类智能指针，它们在构造函数中获得资源并在析构函数中释放资源。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>了解隐式接口和编译期多态</title>
    <url>/2020/11/14/%E4%BA%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<hr>
<h1 id="了解隐式接口和编译期多态"><a href="#了解隐式接口和编译期多态" class="headerlink" title="了解隐式接口和编译期多态"></a>了解隐式接口和编译期多态</h1><p>&emsp;&emsp;面向对象编程世界总是以显式接口和运行期多态解决问题。举个例子子，给定这样（无意义）的class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Widget();</span><br><span class="line">        <span class="keyword">virtual</span> ~Widget();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>; </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;和这样（也是无意义）的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(Widget&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">Widget <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以这样说doProcessing内的w：</p>
<ul>
<li>由于w的类型被声明为Widget，所以w必须支持Widget接口。我们可以在源码中找出这个接口（例如在Widget的.h文件中），看看它是什么样子，所以我称此为一个显式接口，也就是它在源码中明确可见。</li>
<li>由于Widget的某些成员函数是virtual，w对那些函数的调用将表现出运行期多态，也就是说将于运行期根据w的动态类型决定究竟调用哪一个函数。</li>
</ul>
<p>&emsp;&emsp;Template及泛型编程的世界，与面向对象有根本上的不同。在此世界中显式接口和运行期多态仍然存在，但重要性降低。反倒是隐式接口和编译期多态移到前头了。若想知道那是什么，看看当我们将doProcessing从函数转变成函数模版时发生什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在我们怎么说doProcessing内的w呢？</p>
<ul>
<li>w必须支持哪一种接口，系由template中执行于w身上的操作来决定。本例看来w的类型T好像必须支持size,normalize和swap成员函数、copy构造函数（用以建立temp）、不等比较（用来比较smeNasty-Widget）。我们很快会看到这并非完全正确，但对目前而言足够真实。重要的是，这一组表达式（对此template而言必须有效编译）便是T必须支持的一组隐式接口。</li>
<li>凡涉及w的任何函数调用，例如operator&gt;和operator!=，有可能造成template具现化，使这些调用得以成功。这样的具现行为发生在编译期。“以不同的template参数具现化function template”会导致调用不同的函数，这便是所谓的编译期多态。</li>
</ul>
<p>&emsp;&emsp;纵使你从未用过template，应该不陌生“运行期多态”和“编译期多态”之间的差异，因为它类似于“哪一个重载函数该被调用”（发生在编译期）和“哪一个virtual函数该被绑定”（发生在运行期）之间的差异。显式接口和隐式接口的差异就比较新颖，需要更多更贴近的说明和解释。</p>
<p>&emsp;&emsp;通常显示接口由函数的签名式（也就是函数名称、参数类型、返回类型）构成。例如Widget class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Widget();</span><br><span class="line">        <span class="keyword">virtual</span> ~Widget();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其public接口由一个构造函数、一个析构函数、函数size，normalize，swap及其参数类型、返回类型、常量性构成。当然也包括编译器产生的copy构造函数和copy assignment操作符。另外也可以包括typedef。</p>
<p>&emsp;&emsp;隐式接口就完全不同了。它并不基于函数签名式，而是由有效表达式组成。再次看看doProcessing template一开始的条件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;T（w的类型）的隐式接口看起来好像有这些约束：</p>
<ul>
<li>它必须提供一个名为size的成员函数，该函数返回一个整数值。</li>
<li>它必须支持一个operator!=函数，用来比较两个T对象。这里我们假设someNastyWidget的类型是T。</li>
</ul>
<p>&emsp;&emsp;真要感谢操作符重载带来的可能性，这两个约束都不需要满足。是的，T必须支持size成员函数，然而这个函数也可能从base class继承而得。这个成员函数不需返回一个整数值，甚至不需返回一个数值类型。就此而言，它甚至不需要返回一个定义由operator&gt;的类型！它唯一需要做的是返回一个类型为X的对象，而X对象加上一个int（10的类型）必须能够调用一个operator&gt;。这个operator&gt;不需要非得取得一个类型为X的参数不可，因为它也可以取得类型Y的参数，只要存在一个隐式转换能够将类型X的对象转换为类型Y的对象！</p>
<p>&emsp;&emsp;同样道理，T并不需要支持operator!=，因为以下这样也是可以的：operator!=接受一个类型为X的对象和一个类型为Y的对象，T可被转换为X而someNastyWidget的类型可被转换为Y，这样就可以有效调用operator!=。</p>
<p>&emsp;&emsp;（偷偷告诉你，以上分析并未考虑这样的可能性：operator&amp;&amp;被重载，从一个连接词改变为或许完全不同的某种东西，从而改变上述表达式的意义。）</p>
<p>&emsp;&emsp;当人们第一次以此种方式思考隐式接口，大多数的他们会感到头疼。但真的不需要阿司匹林来镇痛。隐式接口仅仅是由一组有效表达式构成，表达式自身可能看起来很复杂，但它们要求的约束条件一般而言相当直接又明确。例如一下条件式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(w.<span class="built_in">size</span>() &gt; <span class="number">10</span> &amp;&amp; w != someNastyWidget) ...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于函数size，operator&gt;，operator&amp;&amp;或operator!=身上的约束条件，我们很难就此说得太多，但整体确认表达式约束条件却很容易。if语句的条件式必须是个布尔表达式，所以无论涉及什么实际类型，无论“w.size() &gt; 10 &amp;&amp; w != someNastyWidget”导致什么，它都必须与bool兼容。这是template doProcessing加诸于其类型参数T的隐式接口的一部分。doProcessing要求其他隐式接口：copy构造函数、normalize和swap也都必须对T型对象有效。</p>
<p>&emsp;&emsp;加诸于template参数身上的隐式接口，就像加诸于class对象身上的显式接口一样真实，而且两者都在编译期完成检查。就像你无法以一种“与class提供之显式接口矛盾”的方式来使用对象（代码将通不过编译），你也无法在template中使用“不支持template所要求之隐式接口”的对象（代码一样通不过编译）。</p>
<blockquote>
<ul>
<li>class和template都支持接口和多态。</li>
<li>对class而言接口是显式的，以函数签名为中心。多态则是通过virtual函数发生于运行期。</li>
<li>对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>光栅图像</title>
    <url>/2022/05/01/%E5%85%89%E6%A0%85%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<hr>
<h1 id="什么是光栅图像"><a href="#什么是光栅图像" class="headerlink" title="什么是光栅图像"></a>什么是光栅图像</h1><p>&emsp;&emsp;大多数计算机图形的图像是通过光栅显示器来展现给用户的，光栅显示器以一个由像素（<code>Pixel</code>）组成的矩阵来显示图像，可以将像素看成点块，由众多这样的点块进行排列组合构成一个图像。例如在平板电脑或者电视的显示器中，矩阵中的一小块发光像素，可以被单独设置为三种不同的颜色（红、蓝和绿色），通过组合不同强度的红光、蓝光和绿光可以得到不同的颜色，因此可以以这种方式来创建任意一个图像。大多数打印机，如激光打印机和喷墨打印机，也是光栅设备，它们是基于扫描的：没有像素的物理网格，但是图像是通过在网格上的特定点位沉积墨水来进行排列组合的。</p>
<a id="more"></a>

<p>&emsp;&emsp;光栅在图像输入设备中也很常见。数码相机包含一个由感光像素组成的图像传感器，每个像素记录落在它上面的光的颜色和强度。桌面扫描器包含一个线性的像素矩阵，它在被扫描的页面上扫过，每秒进行多次测量以产生一个像素网格。</p>
<p>&emsp;&emsp;各类设备中普遍存在光栅，光栅图像也是存储和处理图像的最常见方式。一个光栅图像可以看作为一个存储每个图像的像素值的2D数组，其通常存储着三个数字，这些数字分别代表着三种基本颜色：红、蓝和绿色。几乎所有的数码照片，从高端相机拍摄的艺术风景到手机拍摄的快照，都以光栅数据（也称为位图数据）表示。</p>
<p>&emsp;&emsp;但是通常我们并不希望总是以这种方式来显示图像，我们可能会想要改变图像的大小、方向、颜色或者是显示粘贴在一个移动的三维表面上的图像。即使是在电视中，显示器的像素也很少与所显示的图像相同。</p>
<p>&emsp;&emsp;除了使用像素数组之外，还有其他表现图像的方法，例如矢量数据。矢量图像是通过对存储图形的相关描述来表现的，以直线或曲线为界限的颜色区域，而不参考任何特定的像素网格，其通常用于可以分解成简单线条、曲线和形状的图像。本质上，这相当于存储显示图像的指令，而不是存储显示图像所需的像素。矢量图像的主要优点是它们与分辨率无关，可以在高分辨率设备上很好地显示。相应的缺点是它们必须被栅格化才能显示。矢量图像通常用于文本、图表、机械绘图和其他应用中，在这些应用中，清晰度和精度非常重要，不需要摄影图像和复杂的阴影。</p>
<p>&emsp;&emsp;我们知道光栅图像是一个较大的矩阵像素点块，每个像素点块都存储着一个数字来表现对应的颜色。对于计算机来说，我们需要将这些像素数据抽象为不依赖于任何设备的实例。当我们评估或生成计算机图像时，需要使用一个类似二极管的光线，任何光线从该设备输入时（或被吸收或被发射），</p>
]]></content>
      <categories>
        <category>计算机图形基础</category>
      </categories>
      <tags>
        <tag>计算机图形</tag>
      </tags>
  </entry>
  <entry>
    <title>以独立语句将new对象置入智能指针</title>
    <url>/2020/07/30/%E4%BB%A5%E7%8B%AC%E7%AB%8B%E8%AF%AD%E5%8F%A5%E5%B0%86new%E5%AF%B9%E8%B1%A1%E7%BD%AE%E5%85%A5%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<hr>
<h1 id="以独立语句将new对象置入智能指针"><a href="#以独立语句将new对象置入智能指针" class="headerlink" title="以独立语句将new对象置入智能指针"></a>以独立语句将new对象置入智能指针</h1><p>&emsp;&emsp;假设我们有个函数涌来揭示处理程序的优先权，另一个函数用来在某动态分配所得的Widget上进行某些带有优先权的处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑调用processWidget：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;上述代码可不能通过编译。shared_ptr构造函数需要一个原始指针，但该构造函数是个explicit构造函数，无法进行隐式转换，将得自“newWidget”的原始指针转换为processWidget所要求的shared_ptr。如果写成这样就可以通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然而上述调用却可能泄露资源。</p>
<p>&emsp;&emsp;编译器产出一个processWidget调用码之前，必须首先核算即将被传递的各个实参。上述第二个实参只是一个单纯的对priority函数的调用，但第一个实参std::shared_ptr&lt;Widget&gt;(new Widget)由两部分组成：</p>
<ul>
<li>执行“new Widget”表达式</li>
<li>调用shared_ptr构造函数</li>
</ul>
<p>也是在调用processWidget之前，编译器必须创建代码，做一下三件事：</p>
<ul>
<li>调用priority</li>
<li>执行“new Widget”</li>
<li>调用shared_ptr构造函数</li>
</ul>
<p>&emsp;&emsp;C++编译器以什么样的次序完成这些事情呢？弹性很大。这和其他语言如Java和C#不同，那两种语言总是以特定次序完成函数参数的核算。可以确定的是“new Widget”一定执行于shared_ptr构造函数被调用之前，因为这个表达式的结果还要被传递作为shared_ptr构造函数的一个实参，但对priority的调用则可以排在第一或第二或第三执行。如果编译器选择以第二顺位执行它（说不定可以因此产生更高效的代码，谁知道呢），最终获得这样的操作序列：</p>
<ol>
<li>执行“new Widget”</li>
<li>调用priority</li>
<li>调用shared_ptr构造函数</li>
</ol>
<p>&emsp;&emsp;现在我们想想，万一对priority的调用导致异常，会发生什么事？在此情况下“new Widget”返回的指针将遗失，因为它尚未被置入shared_ptr内，后者是我们期盼用来防卫资源泄漏的武器。没错，在对processWidget的调用过程可能引发资源泄漏。</p>
<p>&emsp;&emsp;避免这类问题的办法很简单：使用分离语句，分别写出（1）创建Widget，（2）将它置入一个智能指针内，然后再把哪个智能指针传给processWidget：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>;</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以独立语句将new对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用friend non-member function来完成template中的类型转换机能</title>
    <url>/2020/11/19/%E4%BD%BF%E7%94%A8friend%20non-member%20function%E6%9D%A5%E5%AE%8C%E6%88%90template%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E8%83%BD/</url>
    <content><![CDATA[<hr>
<h1 id="使用friend-non-member-function来完成template中的类型转换机能"><a href="#使用friend-non-member-function来完成template中的类型转换机能" class="headerlink" title="使用friend non-member function来完成template中的类型转换机能"></a>使用friend non-member function来完成template中的类型转换机能</h1><p>&emsp;&emsp;“<a href="/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/" title="若所有参数皆需类型转换，请为此采用non-member函数">若所有参数皆需类型转换，请为此采用non-member函数</a>”这个条款讨论过为什么只有non-member函数才有能力“在所有实参身上实施隐式类型转换”。由于此文也是以它作为基础的延伸，所以强烈建议你先熟稔那个例子，本文将对那个例子进行一系列的改动，对Rational和operator*模版化：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Rational(<span class="keyword">const</span> T&amp; numerator = <span class="number">0</span>,</span><br><span class="line">                 <span class="keyword">const</span> T&amp; denominator = <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> T <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就像“<a href="/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/" title="若所有参数皆需类型转换，请为此采用non-member函数">若所有参数皆需类型转换，请为此采用non-member函数</a>”一样，我们希望template版本支持混合式算术运算，所以我们期望以下代码可以顺利通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational&lt;<span class="keyword">int</span>&gt; <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = oneHalf * <span class="number">2</span>;  <span class="comment">//错误！无法通过编译。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;奇怪了，为什么non-template版本的可以通过编译，而这里却不行呢？模版化的Rational内的某些东西似乎和non-template版本不同。non-template版本中，编译器知道我们尝试调用什么函数（就是接受两个Rational参数的那个operator*啦），但是这里编译器不知道我们想要调用哪个函数。反而，它们自己倒是试图去想出什么函数被名为operator*的template具现化出来。它们知道（与其说“知道”倒不如说是“自认为”）自己应该可以具现化某个“名为operator*并接受两个Rational&lt;T&gt;参数”的函数，但为了完成这个目标，必须先算出T是什么，问题是它们没有这个能耐。</p>
<p>&emsp;&emsp;编译器为了推导出T，它们会将operator*调用行为中的实参类型分别纳入考虑范围内。</p>
<p>&emsp;&emsp;operator*的第一实参被声明为Rational&lt;T&gt;，而传递给operator*的第一实参（oneHalf）的类型是Rational&lt;int&gt;，所以T一定是int。但是其他参数的推导则没有这么顺利。operator*的第二实参被声明为Rational&lt;T&gt;，但是传递给operator*的第二实参类型是int，编译器如何才能根据这个推算出T？或许你以为编译器会这样工作：编译器使用Rational&lt;int&gt;的non-explicit构造函数将2转换为Rational&lt;int&gt;，进而将T推导为int。错！编译器不会如你所愿，因为在template实参推导过程中从不将隐式类型转换函数纳入考虑。这样的转换虽然在函数调用中确实被使用，但是在能够调用一个函数前，首先必须知道那个函数存在。而为了知道它，必须先为相关的function template推导出参数类型（然后才可以将适当的函数具现化出来）。然而template实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。这也正是C++与其他语言不同的地方，就像“<a href="/2020/07/17/%E8%A7%86C++%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/" title="视C++为一个语言联邦">视C++为一个语言联邦</a>”所说的那样，我们现在处于template part of C++领域内，有着不同的规则。</p>
<p>&emsp;&emsp;令人兴奋的是，class template并不倚赖template实参推导（后者只施行于function template身上），所以编译器总是能够在class Rational&lt;T&gt;具现化时得知T。那么你应该会自然而然的想到一个点子：声明operator*为class Rational&lt;T&gt;的一个friend函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">        <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                                 <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                            <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在对operator*的混合式调用可以通过编译了，因为当对象oneHalf被声明为一个Rational&lt;int&gt;，class Rational&lt;int&gt;于是被具现化出来，而作为过程的一部分，friend函数operator*（接受Rational&lt;int&gt;参数）也就被自动声明出来。后者身为一个函数而非函数模版，因此编译器可在调用它时使用隐式转换函数（例如Rational的non-explicit构造函数），而这便是混合式调用之所以“成功”的原因。</p>
<p>&emsp;&emsp;但是这里的“成功”并不完全成功，因为虽然这段代码通过编译，却无法连接。混合式代码通过了编译，因为编译器知道我们要调用哪个函数（就是接受一个Rational&lt;int&gt;以及又一个Rational&lt;int&gt;的那个operator*），但是那个函数只被声明于Rational内，并没有被定义出来。我们试图令次class外部的operator* template提供定义式，但是行不通——如果我们自己声明了一个函数（这也是Rational template内的行为），就有责任定义那个函数。既然我们没有提供定义式，连接器当然找不到它！</p>
<p>&emsp;&emsp;或许最简单的可行办法就是将operator*函数本体合并至其声明式内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">friend</span> </span><br><span class="line">        <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                                 <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> Rational(lhs.numberator() * rhs.numberator(),</span><br><span class="line">                            lhs.denominator() * rhs.denominator());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在对operator*对混合式调用可以编译连接并执行了。</p>
<p>&emsp;&emsp;这项技术的一个趣味点是，我们虽然使用了friend，却与friend的传统用途“访问class点non-public成分”毫不相干。为了让类型转换可能发生于所有实参身上，我们需要一个non-member函数（“<a href="/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/" title="若所有参数皆需类型转换，请为此采用non-member函数">若所有参数皆需类型转换，请为此采用non-member函数</a>”）；为了令这个函数被自动具现化，我们需要将它声明在class内部；而在class内部声明non-member函数的唯一办法就是：令它成为一个friend。</p>
<p>&emsp;&emsp;定义于class内的函数都会暗自成为inline，包括像operator*这样的friend函数。你也可以将这样的inline声明所带来的冲击最小化，做法就是令operator*不做任何事情，只调用一个定义于class外部的辅助函数。在本例之中，这样做并没有太大意义，因为operator*已经是个单行函数了，但是对于更复杂的函数而言，这样做也许更有价值。“令friend函数调用辅助函数”的做法值得我们接下来好好探究一番。</p>
<p>&emsp;&emsp;“Rational是个template”也就意味着上述的辅助函数通常也是个template，所以定义了Rational的头文件代码应该长这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Rational</span>;</span>  <span class="comment">//声明Rational template</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rational&lt;T&gt; <span class="title">doMultiply</span><span class="params">(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span></span>;  <span class="comment">//声明helper template</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">friend</span></span><br><span class="line">        <span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,</span><br><span class="line">                                    <span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> doMultiply(lhs, rhs);  <span class="comment">//令friend调用helper</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多编译器实际上会强迫你把所有template定义式放进头文件内，所以你或许需要在头文件内定义doMultiply。</p>
<blockquote>
<ul>
<li>当我们编写一个class template，而它所提供的“与此template相关的”函数支持“所有参数的隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于c与c++中空指针的细节</title>
    <url>/2021/08/19/%E5%85%B3%E4%BA%8Ec%E4%B8%8Ec++%E4%B8%AD%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<hr>
<h1 id="NULL，’-0’，”0”，”-0”"><a href="#NULL，’-0’，”0”，”-0”" class="headerlink" title="NULL，’\0’，”0”，”\0”"></a>NULL，’\0’，”0”，”\0”</h1><p>&emsp;&emsp;本质来说，NULL，0，’\0’都是一样的，都为0值。虽然它们的值都是0，但是含义却不尽相同。</p>
<h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>&emsp;&emsp;虽然值是0，但是它的含义却不一样，或者可以这样说，它的类型不一样。NULL是指针类型，不过它是空指针，即值为0。</p>
<a id="more"></a>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将其进行编译：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ gcc -o null null.c</span><br></pre></td></tr></table></figure>

<p>会出现以下错误：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/2021-08-19%20%E4%B8%8A%E5%8D%8811.55.19.png" alt="编译结果"></p>
<p>它给了我们一个警告，提示尝试将指针转换为整数。这也验证了我们前面的说法。</p>
<!--more-->

<p>&emsp;&emsp;实际上NULL通常是如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL (void*)0</span></span><br></pre></td></tr></table></figure>

<p>所以，如果要给一个指针类型初始化，那么你给它一个NULL，使得能够明显的看到这是一个指针。当然，在C++中，它的定义变成如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure>

<p>所以在C++中，更推荐使用nullptr，而不是NULL。</p>
<h2 id="‘-0’"><a href="#‘-0’" class="headerlink" title="‘\0’"></a>‘\0’</h2><p>&emsp;&emsp;\是转义符号，’\0’用单引号包含起来，再加上转义，实际上也就是0了，只不过它代表的是字符。如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">char</span> b = <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行结果就是如下了：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ gcc -o null null.c</span><br><span class="line">./null</span><br><span class="line">a = <span class="number">0</span>, b = <span class="number">48</span></span><br></pre></td></tr></table></figure>

<p>我们最常见到的就是它作为字符串的结束符。所以经常会看到下面这样的写法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">16</span>];</span><br><span class="line">...</span><br><span class="line">str[<span class="number">15</span>] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure>

<p><code>printf</code>以及<code>strcmp</code>都是遇到’\0’结束。</p>
<h2 id="“0”"><a href="#“0”" class="headerlink" title="“0”"></a>“0”</h2><p>&emsp;&emsp;用双引号包括起来的0是字符串，结尾处有一个我们看不到的’\0’。</p>
<h2 id="“-0”"><a href="#“-0”" class="headerlink" title="“\0”"></a>“\0”</h2><p>&emsp;&emsp;这也是字符串，只不过是两个空字符。使用strlen计算字符串长度为0。</p>
<h1 id="建议在C-中使用nullptr而不是NULL"><a href="#建议在C-中使用nullptr而不是NULL" class="headerlink" title="建议在C++中使用nullptr而不是NULL"></a>建议在C++中使用nullptr而不是NULL</h1><p>&emsp;&emsp;在stddef.h可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说，在C++中，NULL不过也是0罢了，把它当作空指针只是一个无可奈何的选择。那么为什么在C++和C中不一样呢？因为C++中不能将<code>void*</code>类型的指针隐式转换成其他指针类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="literal">NULL</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span> i2 = <span class="literal">nullptr</span>; <span class="comment">// nope</span></span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="literal">NULL</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="literal">nullptr</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么使用nullptr"><a href="#为什么使用nullptr" class="headerlink" title="为什么使用nullptr"></a>为什么使用nullptr</h2><p>&emsp;&emsp;nullptr并非整数类型，甚至不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std::nullptr_t。</p>
<p>&emsp;&emsp;为什么作为指针的语义，我们应该使用nullptr，而不是NULL。考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p is pointer"</span> &lt;&lt; p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"num is int"</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述代码编译后，编译会报错，提示二义性，按照“重载函数规则”，两个都可以匹配，因此最终报错。如果我们使用nullptr却不会报错。</p>
<p>&emsp;&emsp;除此之外，在C++模版中它还有更好的表现，考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> P&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(F f, P p)</span> </span>&#123;</span><br><span class="line">    f(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>* i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(foo, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上述代码进行编译后：</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/2021-08-19%20%E4%B8%8B%E5%8D%887.56.32.png" alt="编译结果"></p>
<p>编译报错了，很显然NULL被推导为long int，而不是空指针，因而导致函数类型不匹配而报错。但是如果我们使用nullptr就不会有上述问题。</p>
<p>&emsp;&emsp;最后，指针被定义空指针时，该指针指向的地址是什么呢？空指针在C／C++中占有特殊的地址，通常它是用来判断一个指针的有效性的。空指针一般定义为0。现代操作系统都会保留从0开始的一块内存，至于这块内存有多大，视不同的操作而定。一旦程序试图访问这块内存，系统就会触发一个异常／信号。操作系统为什么要保留一块内存，而不是一个字节的内存呢？这是因为内存管理都是按页进行管理的，根本就无法单纯保留一个字节，而至少保留一个页面。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GNU make工具的汇总（1）</title>
    <url>/2020/09/11/%E5%85%B3%E4%BA%8EGNU%20make%E5%B7%A5%E5%85%B7%E7%9A%84%E6%B1%87%E6%80%BB%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="关于GNU-make工具的汇总（1）"><a href="#关于GNU-make工具的汇总（1）" class="headerlink" title="关于GNU make工具的汇总（1）"></a>关于GNU make工具的汇总（1）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;对于这个话题，想必是每一个Linux程序员的苦手。不像Windows ，Mac等有自己完整的一套编译工具链IDE等，可以一键构建好自己的工程，Linux下的工程构建更多的是需要自己手动来完成，尽管目前已然有许多自动化构建工具，但是掌握好这么一个可以了解到一个工程构建的全部流程的优秀工具对于我们Linux程序员来说是百利而无一害的。不会使用GUN make来构建和管理自己的工程，应该不算是一个合格的程序员，至少不是一个合格的Unix程序员。</p>
<p>&emsp;&emsp;在Unix环境下，使用GNU make工具能够“比较容易”地构建一个属于自己的工程，整个工程最后只需要一个命令就可以完成编译，链接以及执行。在此之前，我们则需要编写一个或者多个Makefile文件，这个环节也是整个过程最难的地方。</p>
<p>&emsp;&emsp;所要完成的Makefile文件描述了整个工程的编译、链接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建那些库文件以及如何创建这些库文件、如何最后产生我们想要得可执行文件。尽管看起来可能是很复杂的事情，但是为工程编写 Makefile 的好处是能够使用一行命令来完成“自动化编译”，一旦提供一个（通常对于一个工程来说会是多个）正确的 Makefile。编译整个工程你所要做的唯一的一件事就是在 shell 提示符下输入 make 命令。整个工程完全自动编译，极大提高了效率。</p>
<p>&emsp;&emsp;make是一个命令工具，它负责解释Makefile中的指令（应该说是规则）。在Makefile文件中描述了整个工程所需文件的编译顺序、编译规则。Makefile有自己的语法规则，书写格式，就像C语言有自己的语法一样。而且更棒的是在Makefile中可以使用系统shell所提供的任何命令来完成自己想要的工作。Makefile在绝大多数的IDE开发环境中都在使用。</p>
<p>&emsp;&emsp;本文以及后续所有关于Makefile的blog都将采用C语言的源程序。</p>
<h2 id="关于学习GNU-make工具，你所需要掌握的知识"><a href="#关于学习GNU-make工具，你所需要掌握的知识" class="headerlink" title="关于学习GNU make工具，你所需要掌握的知识"></a>关于学习GNU make工具，你所需要掌握的知识</h2><p>&emsp;&emsp;在我们开始讨论Makefile之前，首先要明确几个基本概念（这里不对它们作详细的解释，本系列blog主要针对于GUN make工具）：</p>
<ul>
<li>编译：将高级语言转换为计算机可识别的机器指令。转换后的指令虽然可以被计算机识别，但是还不能被执行。编译时，编译器检查高级语言的语法、函数和变量的声明是否正确。只有所有的语法正确、相关变量定义正确，编译器才会编译出中间目标文件。通常，一个高级语言的源文件都可对应一个目标文件。目标文件在Linux中默认后缀为“.o”（如“func.c”的目标文件为“func.o”）。</li>
<li>链接：将多个.o文件，或者.o文件和库文件链接为可被操作系统执行的可执行程序（Linux下可执行文件的格式为：ELF）。链接器不检查函数所在的源文件，只检查所有.o文件中定义的符号。将.o文件中的函数和其他.o和库文件中的相关符号进行合并，对所有文件中的符号进行重定位，并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用GUN的“ld”工具。</li>
<li>静态库：又称为“文档文件（Archive File）。它是多个.o文件的集合。Linux中静态文件的后缀为“.a”。静态库中的各个成员没有特殊的存在格式，仅仅是一个.o文件的集合。通常使用“ar”工具维护和管理静态库。</li>
<li>共享库：也是多个.o文件的集合，但是这些.o文件是由编译器按照一种特殊的方式生成（Linux中，共享库文件格式通常为“ELF”格式。共享库已经具备了可执行的条件）。模块中各个成员的地址（变量引用和函数调用）都是相对地址。使用此共享库的程序在运行时，共享库被动态加载到内存并和主程序在内存中进行链接。多个可执行程序可共享库文件的代码段（多个程序可以共享代码，不共享数据）。另外共享库的成员对象可被执行（由libdl.so提供支持）。</li>
</ul>
<h2 id="GNU-make介绍"><a href="#GNU-make介绍" class="headerlink" title="GNU make介绍"></a>GNU make介绍</h2><p>&emsp;&emsp;此前说过，在执行make之前，我们需要一个或多个Makefile文件来告诉make该做什么以及怎么做。通常make工具主要被用来进行工程编译和程序链接。</p>
<p>&emsp;&emsp;当使用make工具进行编译时，工程中以下几种文件在执行make时将会被编译（或者重新编译）：</p>
<ol>
<li>所有的源文件没有被编译过，则对各个C源文件进行编译并进行链接，生成最终的可执行程序；</li>
<li>每一个在上次执行make之后修改过的C源文件在本次执行make时将会被重新编译；</li>
<li>头文件在上一次执行make之后被修改，则所有包含此头文件的C源文件在本次执行make时将会被重新编译。</li>
</ol>
<h3 id="Makefile规则介绍"><a href="#Makefile规则介绍" class="headerlink" title="Makefile规则介绍"></a>Makefile规则介绍</h3><p>&emsp;&emsp;一个简单的Makefile描述规则组成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGET...:PREREQUISITES...</span></span><br><span class="line">  COMMAND</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;target：规则的目标。通常是最后需要生成的文件名或者是为了实现这个目的而必需的中间过程文件名。可以是.o文件、也可以是最后的可执行程序的文件名等。另外，目标也可以是一个make执行动作的名称，比如“clean”，我们称这样的目标是“伪目标”。</p>
<p>&emsp;&emsp;prerequisites：规则的依赖。生成规则目标所需的文件名列表。通常一个目标依赖于一个或者多个文件。</p>
<p>&emsp;&emsp;command：规则的命令行。是规则所要执行的动作（任何shell命令或者是可在shell下执行的程序）。它限定了make执行这条规则所需要的动作。</p>
<p>&emsp;&emsp;一个规则可以有多个命令行。每一条命令占一行。注意：每一个命令行必须以“TAB”字符开始，“TAB”字符告诉make此行是一个命令行。</p>
<p>&emsp;&emsp;一个目标可以没有依赖而只有动作（指定的命令）。比如Makefile中的目标“clean”，此目标没有依赖，只有命令。它所定义的命令通常用来删除make过程中产生的中间文件（进行清理工作）。</p>
<h3 id="一个简单的示例"><a href="#一个简单的示例" class="headerlink" title="一个简单的示例"></a>一个简单的示例</h3><p>&emsp;&emsp;现在，我们来编写一个最为简单的Makefile，此示例由2个头文件，4个C源文件组成，并且最终将生成可执行文件“sample”。示例如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample Makefile</span></span><br><span class="line"><span class="section">sample: main.o func1.o func2.o func3.o</span></span><br><span class="line">    cc -o sample main.o func1.o func2.o func3.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.c header1.h</span></span><br><span class="line">    cc -c main.c</span><br><span class="line"><span class="section">func1.o: func1.c header1.h header2.h</span></span><br><span class="line">    cc -c func1.c</span><br><span class="line"><span class="section">func2.o: func2.c header1.h header2.h</span></span><br><span class="line">    cc -c func2.c</span><br><span class="line"><span class="section">func3.o: func3.c header1.h header2.h</span></span><br><span class="line">    cc -c func3.c</span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm sample main.o func1.o \</span><br><span class="line">    func2.o func3.o</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编写Makefile时，可以将一个较长行使用反斜线来分解多行，这样可以使我们的Makefile容易阅读。但需要注意的是：反斜线之后不能有空格。在完成这个Makefile之后，为了创建可执行程序“sample”，所要做的就是在包含此Makefile的目录下输入命令“make”。删除在此目录下之前使用“make”生成的文件（包括那些中间文件），也只需要输入命令“make clean”就可以了。</p>
<p>&emsp;&emsp;在这个Makefile中，我们的目标就是可执行文件“sample”和那些中间.o文件；依赖就是冒号后面的那些.c文件和.h文件。所有的.o文件既是依赖文件又是目标。</p>
<h3 id="make如何工作"><a href="#make如何工作" class="headerlink" title="make如何工作"></a>make如何工作</h3><p>&emsp;&emsp;当在shell提示符下输入“make”命令后。make读取当前目录下的Makefile文件，并将Makefile文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在我们的示例中，第一个规则就是sample所在的规则。规则描述了“sample”的依赖关系，并定义了链接.o文件生成目标“sample”的命令；make在执行这个命令之前，首先处理目标“sample”的所有的依赖文件的更新规则。对这些.o文件为目标的规则处理有以下三种情况：</p>
<ol>
<li>目标.o文件不存在，使用其描述规则创建它；</li>
<li>目标.o文件存在，目标.o文件所依赖的.c源文件、.h头文件中的任何一个比目标.o文件更新（在上一次make之后被修改）。则根据规则重新编译生成它；</li>
<li>目标.o文件存在，目标.o文件比它的任何一个依赖文件更新（它的依赖文件在上一次make之后没有被修改）。则什么都不做。</li>
</ol>
<p>&emsp;&emsp;这些.o文件所在的规则之所以会被执行，是因为这些.o文件出现在“终极目标”的依赖列表中。在Makefile中一个规则的目标如果不是“终极目标”所依赖的（或者不是“终极目标”的依赖文件所依赖的），那么这个规则将不会被执行，除非明确指定执行这个规则（例如“make clean”）。</p>
<p>&emsp;&emsp;完成了对.o文件的创建或者更新之后，make程序将处理终极目标“sample”所在的规则，分为以下三种情况：</p>
<ol>
<li>目标“sample”文件不存在，则执行规则以创建目标“sample”；</li>
<li>目标“sample”文件存在，其依赖文件中有一个或者多个文件比它更新，则根据规则重新链接生成“sample”；</li>
<li>目标“sample”文件存在，它比它的任何一个依赖文件都更新，则什么也不做。</li>
</ol>
<h3 id="指定变量"><a href="#指定变量" class="headerlink" title="指定变量"></a>指定变量</h3><p>&emsp;&emsp;对于上述示例中的终极目标“sample”所在的规则中，.o文件列表出现了两次，并且当遇到大量.o文件时，这就会给维护以及修改带来很大的不便。</p>
<p>&emsp;&emsp;为了避免这个问题，在实际工作中，大家普遍比较认可的做法是，使用一个变量（比如“OBJECT”或者“object”或者其他名称）来作为所有.o文件列表的替代。在使用这些文件列表的地方，使用此变量来代替。在上述Makefile中我们可以添加这样一行：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o func1.o func2.o func3.o</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;“objects”作为一个变量，它代表所有的.o文件列表。在定义了此变量后，我们就可以在需要使用这些.o文件列表的地方使用“$(objects)”来表示它，而不需要罗列所有的.o文件。因此上述示例的规则可以这样写：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = main.o func1.o func2.o func3.o</span><br><span class="line"><span class="section">sample: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o sample <span class="variable">$(objects)</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<h3 id="自动推导规则"><a href="#自动推导规则" class="headerlink" title="自动推导规则"></a>自动推导规则</h3><p>&emsp;&emsp;在使用make编译.c源文件时，编译.c源文件规则的命令可以不用明确给出，这是因为make本身存在一个默认规则，能够自动完成对.c文件的编译并生成对应的.o文件。在Makefile中我们只需要给出需要重建的目标文件名（一个.o文件），make会自动为这个.o文件寻找适合的依赖文件（对应的.c文件。对应指的是：文件名除后缀外，其余都相同的两个文件），而且使用正确的命令来重建这个目标文件。</p>
<p>&emsp;&emsp;这样，在编写Makefile时，我们就可以省略掉描述.c和.o文件依赖关系的规则，而只需要给出那些特定的规则描述（.o目标需要的.h文件）。因此上述示例可以写成：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample Makefile</span></span><br><span class="line">objects = main.o func1.o func2.o func3.o</span><br><span class="line"></span><br><span class="line"><span class="section">sample: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o sample <span class="variable">$(objects)</span></span><br><span class="line">		</span><br><span class="line"><span class="section">main.o: header1.h </span></span><br><span class="line"><span class="section">func1.o: header1.h header2.h</span></span><br><span class="line"><span class="section">func2.o: header1.h header2.h</span></span><br><span class="line"><span class="section">func3.o: header1.h header2.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line">    rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<h3 id="清除工作目录过程文件"><a href="#清除工作目录过程文件" class="headerlink" title="清除工作目录过程文件"></a>清除工作目录过程文件</h3><p>&emsp;&emsp;之前提到的清除当前目录下编译过程中产生的临时文件的规则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在实际应用中，我们将上述规则写成如下形式：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm sample <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这两个实现有两点不同：1.通过“.PHONY”特殊目标将“clean”目标声明为伪目标。避免当磁盘上存在一个名为“clean”文件时，目标“clean”所在规则的命令无法执行（具体原理见后续blog）。2.在命令行之前使用“-”，意思是忽略命令“rm”的执行错误。</p>
<p>&emsp;&emsp;因为目标“clean”没有出现在终极目标“sample”依赖关系中，所以我们执行make时，目标“clean”所在规则不会被处理。当需要执行此规则时，要在make的命令行选项中明确指定这个目标（执行“make clean”）。</p>
<p>&emsp;&emsp;以上就是关于Makefile的大致描述，关于Makefile的语法以及更加详尽的用法将在后续blog中进行描述。此blog目的仅仅是使读者对于Makefile有一个大致的印象，看完此内容并不足以使你成为一个Makefile高手，甚至不会是一个入门级选手。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GNU make工具的汇总（2）</title>
    <url>/2020/09/12/%E5%85%B3%E4%BA%8EGNU%20make%E5%B7%A5%E5%85%B7%E7%9A%84%E6%B1%87%E6%80%BB%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="Makefile总述"><a href="#Makefile总述" class="headerlink" title="Makefile总述"></a>Makefile总述</h1><h2 id="Makefile的内容"><a href="#Makefile的内容" class="headerlink" title="Makefile的内容"></a>Makefile的内容</h2><p>&emsp;&emsp;在一个完整的Makefile中，包含了5个东西：显式规则、隐式规则、变量定义、指示符和注释。</p>
<ul>
<li>显式规则：它描述了在何种情况下如何更新一个或者多个被称为目标的文件（Makefile的目标文件）。书写Makefile时，需要明确地给出目标文件、目标依赖文件列表以及更新目标文件所需要的命令。</li>
<li>隐式规则：它是make根据一类目标文件（典型的是根据文件名的后缀）而自动推导出来的规则。make根据目标文件名，自动产生目标的依赖文件并使用默认的命令来对目标进行更新。</li>
<li>变量定义：使用一个字符或一个字符串代表一段文本串，当定义了一个变量以后，Makefile后续在需要使用此文本串的地方，就会通过引用这个变量来实现对文本串的使用。</li>
<li>指示符：也就是命令</li>
<li>注释：Makefile中“#”字符后的内容被作为是注释内容（和shell脚本一样）处理。注释行的结尾如果存在反斜线（\），那么下一行也被作为注释行。</li>
</ul>
<h2 id="包含其它Makefile文件"><a href="#包含其它Makefile文件" class="headerlink" title="包含其它Makefile文件"></a>包含其它Makefile文件</h2><p>&emsp;&emsp;“include”指示符告诉make暂停读取当前的Makefile，而转去读取“include”指定的一个或多个文件，完成以后再继续当前的Makefile的读取。Makefile中指示符“include”书写在独立的一行，其形式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> FILENAMES...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;FILENAMES是shell所支持的文件名（可以使用通配符）。</p>
<p>&emsp;&emsp;指示符“include”和文件名之间、多个文件之间使用空格或者“TAB”键隔开。</p>
<p>&emsp;&emsp;如果指示符“include”指定的文件不是以斜线开始（绝对路径，如/usr/src/Makefile…），而且当前目录下也不存在此文件；make将根据文件名试图在以下几个目录查找：首先，查找使用命令行选项“-l”或者“–include-dir”指定的目录，如果找到指定的文件，则使用这个文件；否则继续依次搜索以下几个目录（如果存在）：“/usr/gun/include”、“/usr/local/include”和“/usr/include”。</p>
<p>&emsp;&emsp;当这些目录下都没有找到“include”指定的文件时，make将会提示一个包含文件未找到的警告提示，但是不会立即退出。而是继续处理Makefile后续内容。当完成读取整个Makefile后，make将试图使用规则来创建通过指示符“include”指定的但未找到的文件，当不能创建它时（没有创建这个文件的规则），make将提示致命错误并退出。</p>
<p>&emsp;&emsp;通常我们在Makefile中使用“-include”来代替“include”，来忽略由于包含文件不存在或者无法创建时的错误提示。</p>
<h2 id="变量MAKEFILES"><a href="#变量MAKEFILES" class="headerlink" title="变量MAKEFILES"></a>变量MAKEFILES</h2><p>&emsp;&emsp;如果在当前环境定义了一个“MAKEFILES”环境变量，make执行时首先将此变量的值作为需要读入的Makefile文件，多个文件之间使用空格隔开。类似使用指示符“include”包含其他Makefile文件一样，如果文件名非绝对路径而且当前目录也不存在此文件，make就会在一些默认的目录去寻找，它和“include”的区别：</p>
<ol>
<li>环境变量指定的makefile文件中的目标不会作为make执行的“终极目标”；而在make的工作目录下存在这样一个文件（“makefile”、“Makefile”等），那么make执行时的“终极目标”就是当前目录下这个文件中所定义的“终极目标”。</li>
<li>环境变量所定义的文件列表，在执行make时，如果不能找到其中一个文件。make不会提示错误，也不退出。也就是说环境变量“MAKEFILES”定义的包含文件是否存在不会导致make错误。</li>
<li>make在执行时，首先读取的是环境变量“MAKEFILES”所指定的文件列表，之后才是工作目录下的makefile文件，“include”指定的文件是在make发现此关键字时，暂停正在读取的文件而转去读取“include”所指定的文件。</li>
</ol>
<h2 id="变量MAKEFILE-LIST"><a href="#变量MAKEFILE-LIST" class="headerlink" title="变量MAKEFILE_LIST"></a>变量MAKEFILE_LIST</h2><p>&emsp;&emsp;make程序在读取多个makefile文件时，包括由环境变量“MAKEFILES”指定的、命令行指定的、当前工作目录下的默认的以及使用指示符“include”指定包含的，在对这些文件进行解析执行之前make读取的文件名将会被自动依次追加到变量“MAKEFILE_LIST”的定义域中。</p>
<h2 id="其他特殊变量"><a href="#其他特殊变量" class="headerlink" title="其他特殊变量"></a>其他特殊变量</h2><p>&emsp;&emsp;GNU make支持一个特殊的变量，此变量不能通过任何途径给它赋值。它被展开为一个特定的值。一个重要的特殊变量是“.VARIABLES”。它被展开以后是此引用点之前、makefile文件中所定义的所有全局变量列表。包括：空变量（未赋值的变量）和make的内嵌变量，但不包括目标指定的变量。</p>
<h2 id="makefile文件的重建"><a href="#makefile文件的重建" class="headerlink" title="makefile文件的重建"></a>makefile文件的重建</h2><p>&emsp;&emsp;Makefile可由其他文件生成，例如RCS或SCCS文件。如果makefile由其他文件重建，那么在make开始解析这个makefile时需要重新读取更新后的makefile，而不是之前的makefile。make的处理过程是这样的：</p>
<p>&emsp;&emsp;make在读取所有makefile文件后，首先将所读取的每个makefile作为一个目标，寻找更新它们的规则。如果存在一个更新某一个makefile文件的明确规则或者隐含规则，就去更新对应的makefile文件。完成对所有的makefile文件的更新之后，如果之前所读取任何一个makefile文件被更新，那么make就清除本次执行的状态重新读取一遍所有的makefile文件（此过程中，同样在读取完成以后也会去试图更新所有的已经读取的makefile文件，但是一般这些文件不会再次被重建，因为它们在时间戳上已经是最新的了）。读取完成以后再开始解析已经读取的makefile文件并开始执行必要的动作。</p>
<p>&emsp;&emsp;实际应用中，我们会明确给出makefile文件，而并不需要来由make自动重建它们。但是make在每一次执行时总会自动地试图重建那些已经存在的makefile文件，如果需要处于效率考虑，可以采用一些办法来避免make在执行过程中查找重建makefile的隐含规则。例如我们可以书写一个明确的规则，以makefile文件作为目标，规则的命令定义为空。</p>
<p>&emsp;&emsp;makefile规则中，如果使用一个没有依赖只有命令行的双冒号规则去更新一个文件，那么每次执行make时，此规则的目标文件将会被无条件更新（此规则定义的命令会被无条件执行）。如果这样一个规则的目标是makefile文件，那么执行make时，这个makefile文件就会被无条件更新，而使得make的执行陷入到一个死循环（此makefile文件被不断的更新、重新读取、更新再重新读取的过程）。为了防止这种情况的发生，make在遇到一个目标是makefile文件的双冒号规则时，将忽略这个规则的执行</p>
<h2 id="make如何解析makefile文件"><a href="#make如何解析makefile文件" class="headerlink" title="make如何解析makefile文件"></a>make如何解析makefile文件</h2><p>&emsp;&emsp;GNU make的执行过程分为两个阶段：</p>
<ol>
<li>第一阶段：读取所有的makefile文件（包括“MAKEFILES”变量指定的、指示符“include”指定的、以及命令行选项“-f（–file）”指定的makefile文件），内建所有的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。</li>
<li>第二阶段：根据第一阶段已经建立好的依赖关系结构链表决定哪些目标需要更新，并使用对应的规则来重建这些目标。</li>
</ol>
<h1 id="make的执行过程如下"><a href="#make的执行过程如下" class="headerlink" title="make的执行过程如下"></a>make的执行过程如下</h1><ol>
<li>依次读取变量“MAKEFILES”定义的makefile文件列表</li>
<li>读取工作目录下的makefile文件</li>
<li>依次读取工作目录makefile文件中使用指示符“include”包含的文件</li>
<li>查找重建所有已读取的makefile文件的规则（如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile，完成以后从第一步重新开始执行）</li>
<li>初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li>
<li>根据“终极目标”以及其他目标的依赖关系建立依赖关系链表</li>
<li>执行除“终极目标”以外其他目标的依赖关系建立依赖关系链表</li>
<li>执行“终极目标”所在的规则</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GNU make工具的汇总（3）</title>
    <url>/2020/09/14/%E5%85%B3%E4%BA%8EGNU%20make%E5%B7%A5%E5%85%B7%E7%9A%84%E6%B1%87%E6%80%BB%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<hr>
<h1 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h1><h2 id="规则语法"><a href="#规则语法" class="headerlink" title="规则语法"></a>规则语法</h2><p>&emsp;&emsp;通常规则的语法格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGETS: PREQUISITES</span></span><br><span class="line">    COMMAND</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGETS: PREQUISITES; COMMAND</span></span><br><span class="line">    COMMAND</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>书写规则时，需要注意以下几点：</p>
<ol>
<li><p>规则的命令部分有两种书写方式：a.命令可以和目标：依赖描述放在同一行。命令在依赖文件列表后并使用分号（；）和依赖文件列表分开。b.命令在目标：依赖描述的下一行。作为独立的命令行。</p>
<p>当作为独立的命令行时此行必须以“TAB”字符开始。在Makefile中，在第一个规则之后出现的所有以“TAB”字符开始的行都会被当作命令来处理。</p>
</li>
<li><p>Makefile中符号“$”有特殊的含义（表示变量或者函数的引用），在规则中需要用到符号“$”的地方，需要书写两个连续的（“$$”）。</p>
</li>
<li><p>前边已提到过，对于Makefile中一个较长的行，我们可以使用反斜线“\”将其书写到几个独立的行上。虽然make对Makefile文本行的最大长度是没有限制的，但还是建议这样做。</p>
</li>
</ol>
<p>规则的中心思想是：目标文件的内容是由依赖文件决定的，依赖文件的任何一处改动，将导致目前已经存在的目标文件的内容过期。规则的命令为重建目标提供了方法，这些命令运行在系统shell之上。</p>
<h2 id="依赖的类型"><a href="#依赖的类型" class="headerlink" title="依赖的类型"></a>依赖的类型</h2><p>&emsp;&emsp;有时候，需要定义一个这样的规则，在更新目标（目标文件已经存在）时只需要根据依赖文件中的部分来决定目标是否需要被重建，而不是在依赖文件里的任何一个被修改后都重建目标。为了实现这一目的，相应的就需要对规则的依赖就行分类，一类是在这些依赖文件被更新后，需要更新规则的目标；另一类是更新这些依赖后，可以不需要更新规则的目标。我们把第二类称为：“ordered-only”依赖。书写规则时，“ordered-only”依赖使用管道符号“|”开始，作为目标的一个依赖文件。规则依赖列表中管道符号“|”左边是常规依赖，管道右边的就是“ordered-only”依赖。这样的规则书写格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">TARGETS: NORMAL-PREREQUISITES | ORDER-ONLY-PREREQUISITES</span></span><br></pre></td></tr></table></figure>

<p>这样的规则中常规依赖文件可以是空；同样也可以对一个目标就行多次追加依赖。注意：规则依赖文件列表中如果一个文件同时出现在常规列表和“ordered-only”列表中，那么此文件被作为常规依赖处理（因为常规依赖所实现的动作是“ordered-only”依赖所实现的动作的一个超集）。</p>
<h2 id="通配符存在的缺陷"><a href="#通配符存在的缺陷" class="headerlink" title="通配符存在的缺陷"></a>通配符存在的缺陷</h2><p>&emsp;&emsp;在我们的Makefile中，期望能够根据所有的.o文件生成可执行文件“demo”：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objects = *.o</span><br><span class="line"></span><br><span class="line"><span class="section">demo: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o demo <span class="variable">$(CFLAGS)</span> <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>这里变量“objects”的值是一个字符串“*.o”。在重建“demo”的规则中对变量“objects”进行展开，目标“demo”的依赖就是“*.o”，即所有的.o文件列表。如果在工作目录下已经存在必需的.o文件，那么这些.o文件将成为目标的依赖文件，目标“demo”将根据规则重建。</p>
<p>&emsp;&emsp;但是如果将工作目录下的所有.o文件删除，重新执行make将会得到一个类似于“没有创建*.0文件的规则”的错误提示。这当然不是我们想要的结果。为了达到我们想要的结果，在对变量进行定义时需要使用一些高级的技巧，包括使用“wildcard”函数（定义为“objects =$(wildcard *.o)”）和字符串的置换。</p>
<h2 id="函数wildcard"><a href="#函数wildcard" class="headerlink" title="函数wildcard"></a>函数wildcard</h2><p>&emsp;&emsp;在规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用“wildcard”，它的用法是：$(wildcard PATTERN…)。在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。但如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。</p>
<p>&emsp;&emsp;一般来说，我们可以使用“$(wildcard *.c)”来获取工作目录下的所有的.c文件列表。复杂一些的用法，可以使用“$(patsubst %.c,%.o,$(wildcard *.c))”，首先使用“wildcard”函数获取工作目录下的.c文件列表；之后将列表中所有文件名的后缀.c替换为.o。这样我们就可以得到在当前目录下可生成的.o文件列表。因此在一个目录下可以使用如下内容的Makefile来将工作目录下的所有.c文件进行编译并最后连接成为一个可执行文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sample Makefile</span></span><br><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">    cc -o foo <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里使用了make的隐含规则来编译.c的源文件。</p>
<h2 id="Makefile伪命令"><a href="#Makefile伪命令" class="headerlink" title="Makefile伪命令"></a>Makefile伪命令</h2><p>&emsp;&emsp;伪目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令，有时也可以将一个伪目标称为一个标签。使用伪目标有两个原因：</p>
<ol>
<li>避免在我们的Makefile中定义的只执行命令的目标和工作目录下的实际文件名出线名字冲突。</li>
<li>提高执行make时的效率，特别是对一个大型的工程来说，编译的效率我们同时关心。</li>
</ol>
<p>以下就这两个问题我们进行分析讨论：</p>
<ol>
<li><p>如果我们需要编写这样的一个规则：规则所定义的命令不是去创建目标文件，而是通过make命令行指定它来执行一些特定的命令。像很常见的clean目标:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>

<p>规则中“rm”不是创建文件“clean”的命令，而是删除当前目录下的所有.o文件和temp文件。当工作目录下不存在“clean”这个文件时，我们输入“make clean”，“rm *.o temp”总会被执行，这是我们的初衷。</p>
<p>&emsp;&emsp;但是如果当前工作目录下存在文件“clean”，情况就不一样了，同样我们输入“make clean”，由于这个规则没有任何依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令，因此“rm”命令不会被执行。这并不是我们的初衷。为了解决这个问题，我们需要将目标“clean”声明为伪目标。如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br></pre></td></tr></table></figure>

<p>这样目标“clean”就被声明为一个伪目标，无论在当前目录下是否存在“clean”这个文件，我们输入“make clean”之后，“rm”命令都会被执行。而且，当一个目标被声明为伪目标后，make在执行此规则时不会去试图查找隐含规则来创建它。其完整格式如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o temp</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪目标的另一种使用场合是在make的并行和递归执行过程中。此情况下一般会存在一个变量，定义为所有需要make的子目录。对多个目录进行make对实现方式可以是：在一个规则的命令行中使用shell循环来完成。如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SUBDIR = one two three</span><br><span class="line"></span><br><span class="line"><span class="section">subdirs:</span></span><br><span class="line">    for dir in <span class="variable">$(SUBDIR)</span>; do\</span><br><span class="line">        <span class="variable">$(MAKE)</span> -C $$dir;\</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>但这种实现方法存在以下几个问题。1.当子目录执行make出现错误时，make不会退出。也就是说，在对某一个目录执行make失败后，会继续对其他的目录进行make。在最终执行失败的情况下，我们很难根据错误提示定位出具体是在哪个目录下执行make时发生错误。2.另一个问题就是使用这种shell的循环方式时，没有用到make对目录的并行处理功能，由于规则的命令是一条完整的shell命令，不能被并行处理。</p>
<p>有了为目标后，我们可以用它来克服上述2个问题：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SUBDIRS = one two three</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: subdirs $(SUBDIRS)</span></span><br><span class="line"><span class="section">subdirs: <span class="variable">$(SUBDIRS)</span></span></span><br><span class="line"><span class="variable">$(SUBDIRS)</span>:</span><br><span class="line">    <span class="variable">$(MAKE)</span> -C <span class="variable">$@</span></span><br><span class="line"><span class="section">one: two</span></span><br></pre></td></tr></table></figure>

<p>上述的实现中有一个没有命令行的规则“one: two”，此规则用来限制子目录的make顺序。</p>
<p>&emsp;&emsp;一般情况下，一个伪目标不作为另外一个目标的依赖。这是因为当一个目标文件的依赖包含伪目标时，每一次在执行这个规则时伪目标所定义的命令都会被执行。当一个伪目标没有作为任何目标的依赖时，我们只能通过make的命令行来指定它为make的终极目标，来执行它所在规则所定义的命令。例如“make clean”。</p>
<p>&emsp;&emsp;在Makefile中，一个伪目标可以有自己的依赖（可以是一个或者多个文件、一个或者多个伪目标）。在一个目录下如果需要创建多个可执行程序，我们可以将所有程序的重建规则在一个Makefile中描述。因为Makefile中第一个目标是“终极目标”，约定的做法是使用一个“all”的伪目标来作为终极目标，它的依赖文件就是那些需要创建的程序，以下就是一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all: one two three</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"></span><br><span class="line"><span class="section">one: one.o func.o</span></span><br><span class="line">    cc -o one one.o func.o</span><br><span class="line"><span class="section">two: two.o func.o</span></span><br><span class="line">    cc -o two two.o func.o</span><br><span class="line"><span class="section">three: three.o func.o</span></span><br><span class="line">    cc -o three three.o func.o</span><br></pre></td></tr></table></figure>

<p>执行make时，目标“all”被作为终极目标。为了完成对它的更新，make会创建或者重建目标“all”的所有依赖文件。当需要单独更新某一个程序时，我们可以通过make的命令行选项来目前指定需要重建的程序（例如：“make one”）。</p>
<p>&emsp;&emsp;当一个伪目标作为另一个伪目标的依赖时，make将其作为另外一个伪目标的子例程来处理（就跟C语言中的函数调用一样）。下面就是这个做法的例子：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class="line"><span class="section">cleanall: cleanobj cleandiff</span></span><br><span class="line">    rm program</span><br><span class="line"><span class="section">cleanobj:</span></span><br><span class="line">    rm *.o</span><br><span class="line"><span class="section">cleandiff:</span></span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure>

<p>我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。</p>
<p>&emsp;&emsp;说明：</p>
<p>&emsp;&emsp;通常在清除文件的伪目标所定义的命令中“rm”使用选项“-f（–force）”来防止在缺少删除文件时出错并退出。也可以在“rm”之前加上“-”来防止“rm”错误退出，使用这个方法时make会提示错误信息但不会退出。为了不看到这些讨厌的信息，需要使用上述第一种方式。</p>
<p>&emsp;&emsp;另外make存在一个内嵌的隐含变量“RM”。它被定义为：“RM=rm -f”。因此在书写“clean”规则的命令时可以使用变量“$(RM)”来替代“rm”。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>关于pragma那些事</title>
    <url>/2020/11/12/%E5%85%B3%E4%BA%8Epragma%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<hr>
<h1 id="关于gragma那些事"><a href="#关于gragma那些事" class="headerlink" title="关于gragma那些事"></a>关于gragma那些事</h1><p>&emsp;&emsp;gragma的作用是设定编译器的状态或者指示编译器完成一些特定的动作。编译指令是机器或操作系统专有的，且对每个编译器都是不同的。</p>
<h2 id="warning-pragma"><a href="#warning-pragma" class="headerlink" title="warning pragma"></a>warning pragma</h2><p>&emsp;&emsp;可以对编译器发出的警告信息进行选择性修改。</p>
<p>&emsp;&emsp;其语法：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(警告指示符：警告号列表[; 警告指示符：警告号列表...])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push[,n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;警告指示符（warning-specifier）：</p>
<table>
<thead>
<tr>
<th>Warning-specifier</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>1,2,3,4</td>
<td>给予特定警告一个警告级别，也可以开启一个指定的默认被关闭的警告。</td>
</tr>
<tr>
<td>default</td>
<td>重置一个警告行为恢复到其默认的状态</td>
</tr>
<tr>
<td>disable</td>
<td>不报告特定的警告信息</td>
</tr>
<tr>
<td>error</td>
<td>将特定警告信息作为错误报告</td>
</tr>
<tr>
<td>once</td>
<td>只显示出一次特定的警告信息</td>
</tr>
<tr>
<td>suppress</td>
<td>将当前状态的编译指示推入栈，禁止下一行的特定警告，并且推出警告栈，使得当前状态的编译指示被重置。</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;以下代码展示了一个警告指示符可以包含多个警告号，并且多个警告指示符可以被定义在同一个编译指令中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(diable : 4057 34; once : 4385; <span class="meta-keyword">error</span> : 164)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个指令与下列代码是完全一样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Disable warning messages 4507 and 4034.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4057 34)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Issue warning C4385 only once.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(once : 4385)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Report warning C4164 as an error.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(<span class="meta-keyword">error</span> : 164)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编译器会在任何在0到999之间的警告号上添加4000。</p>
<p>&emsp;&emsp;对于那些在4700到4999之间的警告号（与代码生成有关），当编译器遇到函数定义时警告的状态将会对剩下的函数生效。在函数中使用warning pragma来更改比4699大大的警告号的状态只会在函数末尾起作用。以下实例展示了用以禁用代码生成警告信息的warning pragma的正确位置，并且在之后复原被禁用的警告的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pragma_warning.cpp</span></span><br><span class="line"><span class="comment">//compile with: /W1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4700)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y = x;  <span class="comment">//no C4700 here</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(default : 4700)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y = x;  <span class="comment">//C4700</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;warninig pragma也支持以下句法，n表示警告级别（1到4）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push[, n])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;pragma warning(push)为每一个警告存储当前的警告状态。pragma warning(push, n)为每个警告存储当前的警告状态，并且将全局警告级别设置为n。</p>
<p>&emsp;&emsp;pragma warning(pop)弹出最后一个被推入栈的警告状态。你在push和pop之间对警告状态做出的任何更改都会被取消，考虑下例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4705)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4706)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4707)</span></span><br><span class="line"><span class="comment">//Some code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这段代码的最后，pop复原每个警告（包括4705，4706和4707）到它们在此代码段之前的状态。</p>
<p>&emsp;&emsp;当你写头文件时，你可以使用push和pop来保证当警告状态被用户更改时不会阻止头文件正确地编译。在开头使用push并且在末尾使用pop。比如，假设你有一个头文件在第4级别警告不会被编译完全，那么可以在接下来的代码中将其警告级别改为3级别，然后在其末尾复原其至原始级别。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(push, 3)</span></span><br><span class="line"><span class="comment">//Declarations/definitions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(pop)</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>关于替换new和delete的技术</title>
    <url>/2020/11/27/%E5%85%B3%E4%BA%8E%E6%9B%BF%E6%8D%A2new%E5%92%8Cdelete%E7%9A%84%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<hr>
<h1 id="想要替换operator-new或operator-delete的原因"><a href="#想要替换operator-new或operator-delete的原因" class="headerlink" title="想要替换operator new或operator delete的原因"></a>想要替换operator new或operator delete的原因</h1><p>&emsp;&emsp;为什么会有人想要替换编译器提供的operator new或operator delete呢？下面是三个最常见的理由：</p>
<a id="more"></a>

<ul>
<li><p><strong>用来检测运用上的错误</strong>。如果将“new所得内存”delete掉却不幸失败，这就会导致内存泄漏。如果在“new所得内存”身上多次delete则会导致不确定行为。如果operator new持有一串动态分配所得地址，而operator delete将地址从中移走，倒是很容易检测出上述错误用法。此外各式各样的编程错误可能导致数据“overrun”（写入点在分配区块尾端之后）或“underruns”（写入点在分配区块起点之前）。如果我们自定定义一个operator new，使得可以超额分配内存，以额外空间（位于客户所得区块之前或之后）放置特定的byte patterns（即签名，signatures）。operator delete便得以检查上述签名是否原封不动，若否就表示在分配区的某个生命时间点发生了overrun或underrun，这时候operator delete可以志记（log）所发生的事情以及那个罪魁祸首的指针。</p>
</li>
<li><p><strong>为了强化效能</strong>。编译器所带的operator new和operator delete主要用于一般目的，它们不但可被长时间执行的程序（例如网页服务器，web serves）接受，也可被执行时间少于一秒的程序接受。它们必须处理一系列需求，包括大块内存、小块内存、大小混合型内存。它们必须接纳各种分配形态，范围从程序存活期间的少量区块动态分配，到大数量短命对象的持续分配和归还。此外还有一个问题也是它们需要考虑的——内存碎片：即使有时候内存空间总量足够但由于它们分散为许多小区块的自由内存，这也就导致了程序无法满足大区块内存的要求。</p>
<p>&emsp;&emsp;通常我们可以发现，定制版的operator new和operator delete性能胜过缺省版本。也就是说它们更快，有时候甚至会快很多，而且它们需要的内存比较少，最高可省50%。对某些应用程序而言，将旧有的（编译器自带的）new和delete替换为定制版本，是获得重大效能提升的办法之一。</p>
</li>
<li><p><strong>为了收集使用上的统计数据</strong>。在你开始定制new和delete之前，应该先弄清楚你的软件如何使用其动态内存。分配区块的大小分布如何？寿命分布如何？它们倾向于以FIFO（先进先出）次序或LIFO（后进先出）次序或随机次序来分配和归还？它们的运用形态是否随时间改变，也就是说你的软件在不同的执行阶段有不同的分配／归还形态吗？任何时刻所使用的最大动态分配量（高水位）是多少？自行定义operator new和operator delete使我们得以轻松收集到这些信息。</p>
</li>
</ul>
<h1 id="定制我们自己的operator-new所需要注意的问题"><a href="#定制我们自己的operator-new所需要注意的问题" class="headerlink" title="定制我们自己的operator new所需要注意的问题"></a>定制我们自己的operator new所需要注意的问题</h1><p>&emsp;&emsp;理论上，写一个定制型operator new十分简单。举个例子，下面是一个global operator new，可以帮助检测“overrun”或“underrun”。其中还有不少小错误，稍后我们会完善它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> signature = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> Byte;</span><br><span class="line"><span class="comment">//这段代码还有若干小错误，详下。</span></span><br><span class="line"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>（<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>) <span class="keyword">throw</span>(<span class="built_in">std</span>::bad_alloc) &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">size_t</span> realSize = <span class="built_in">size</span> + <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);  <span class="comment">//增加大小，使能够塞入两个signatures。</span></span><br><span class="line">    <span class="keyword">void</span>* pMem = <span class="built_in">malloc</span>(realSize);  <span class="comment">//调用malloc取得内存。</span></span><br><span class="line">    <span class="keyword">if</span>(!pMem) <span class="keyword">throw</span> bad_alloc();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//将signature写入内存的最前端和最后端。</span></span><br><span class="line">    *(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(pMem)) = signature;</span><br><span class="line">    *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(<span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem)</span><br><span class="line">        + realSize - <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) = signature;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//返回指针，指向位于第一个signature之后的内存位置。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Byte*&gt;(pMem) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述operator new的缺点主要在于它没有履行身为这个特殊函数所应该“坚持C++规矩”的职责。举个例子operator new都应该内含一个循环，反复调用某个new-handler函数，这里却没有。另外还有一个比较微妙的主题：齐位（alignment）。</p>
<p>&emsp;&emsp;许多计算机体系结构要求特定的类型必须放在特定的内存地址上。例如它可能会要求指针的地址必须是4倍数或double的地址必须是8倍数。如果没有遵循这个约束条件，可能导致运行期硬件异常。有些体系结构比较慈悲，不需要我们严格遵守上述规则，当然，如果满足齐位条件，程序便可以获得更佳的效率。例如Intel x86体系结构上的double可被对齐于任何byte边界，但如果它是8-byte齐位，其访问速度会快许多。</p>
<p>&emsp;&emsp;C++要求所有operator new返回的指针都有适当的对齐（取决于数据类型）。malloc就是在这样的要求下工作，所以令operator new返回一个取得自malloc的指针是安全的。然而上述operator new中我并未返回一个取得自malloc的指针，而是返回一个得自malloc且偏移一个int大小的指针。没人能够保证它的安全！如果客户端调用operator new希望获取一个double所需的内存，而我们在一部“int为4byte且double必须为8byte齐位”的机器上跑，我们可能会获得一个没有适当齐位的指针。这可能会造成程序崩溃或执行速度变慢。不论哪种情况都不是我们所愿意见到的。</p>
<p>&emsp;&emsp;其实很多时候定制我们需要的高效的new和delete并非是必要的。许多平台上面已有商业产品可以替代编译器子自带的内存管理器。如果需要它们来为你的程序提高技能和改善效能，你唯一需要做的就是重新连接（relink）。当然啦，首先你得花点钱买下它们。</p>
<p>&emsp;&emsp;另一个选择是open source社区里面的内存管理器。它们在许多平台上面都可以用，你可以下载并试试。很多时候我们编写的内存管理器可能会遗漏可移植性和齐位考虑、线程安全性等等令人厌恶的麻烦细节。真正配得上程序库这个称号的“程序库”，必然十分的健全。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><blockquote>
<ul>
<li>有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>别让异常逃离析构函数</title>
    <url>/2020/07/23/%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="别让异常逃离析构函数"><a href="#别让异常逃离析构函数" class="headerlink" title="别让异常逃离析构函数"></a>别让异常逃离析构函数</h1><p>&emsp;&emsp;C++并不禁止析构函数吐出异常，但它不鼓励我们这样做。这是有理由的。考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~Widget() &#123; ... &#125;  <span class="comment">//假设这个可能吐出一个异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; v;</span><br><span class="line">    ...</span><br><span class="line">&#125;                      <span class="comment">//v在这里被自动销毁</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;当vector v被销毁，它有责任销毁其内含的所有Widgets。假设v内含十个Widgets，而在析构第一个元素期间，有个异常被抛出。其他九个Widgets还是应该被销毁（否则它们保存的任何资源都会发生泄漏），因此v应该调用它们各个析构函数。但假设在那些调用期间，第二个Widget析构函数又抛出异常。现在有两个同时作用的异常，这对C++而言太多了。在两个异常同时存在的情况下，程序若不是结束执行就是导致不明确的行为。本例中它会导致不明确的行为。使用标准程序库的任何其他容器或TR1的任何容器或甚至array，也会出现相同情况。只要析构函数吐出异常，即使并非使用容器或array，程序也可能过早结束或出现不明确行为。没错，C++不喜欢析构函数吐出异常！</p>
<p>&emsp;&emsp;这很容易理解，但如果我们的析构函数必须执行一个动作，而该动作可能会在失败时抛出异常，该怎么办？举个例子，假设我们使用一个class负责数据库连接：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConnection</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> DBConnection <span class="title">create</span><span class="params">()</span></span>;  <span class="comment">//这个函数返回DBConnection对象；</span></span><br><span class="line">                                   <span class="comment">//为求简化暂略参数。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;                  <span class="comment">//关闭联机；失败则抛出异常。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为确保客户不忘记在DBConnection对象身上调用close()，一个合理的想法是创建一个用来管理DBConnection资源的class，并在其析构函数中调用close：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span>    <span class="comment">//这个class用来管理DBConnection对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    ~DBConn() &#123;   <span class="comment">//确保数据库连接总是会被关闭</span></span><br><span class="line">      db.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnetion db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这便允许客户写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;                                    <span class="comment">//开启一个区块</span></span><br><span class="line"><span class="function">DBConn <span class="title">dbc</span><span class="params">(DBConnection::create())</span></span>;  <span class="comment">//建立DBConnection对象</span></span><br><span class="line">                                     <span class="comment">//  并交给DBConn对象以便管理。</span></span><br><span class="line">...                                  <span class="comment">//通过DBConn的接口</span></span><br><span class="line">                                     <span class="comment">//  使用DBConnection对象。</span></span><br><span class="line">&#125;                                    <span class="comment">//在区块结束点，DBConn对象被销毁，</span></span><br><span class="line">                                     <span class="comment">//因而自动为DBConnection对象调用close。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只要调用close成功，一切都美好。但是如果该调用导致异常，DBConn析构函数会传播该异常，也就是允许它离开这个析构函数。这会造成问题，因为这就是抛出了难以驾驭的麻烦。</p>
<p>&emsp;&emsp;两个办法可以避免这一问题。DBConn的析构函数可以：</p>
<ul>
<li>如果close抛出异常就结束程序。通常通过调用abort完成：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败；</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果程序遭遇一个“于析构期间发生的错误”后无法继续执行，“强迫结束程序”是个合理选项。毕竟它可以阻止异常从析构函数传播出去。也就是说调用abort可以抢先置“不明确行为”于死地。</p>
<ul>
<li>吞下因调用close而发生的异常：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DBConn::~DBConn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; db.<span class="built_in">close</span>(); &#125; </span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">//制作运转记录，记下对close的调用失败；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般而言，将异常吞掉是个坏主意，因为它压制了“某些动作失败”的重要信息！然而有时候吞下异常也比负担“草率结束程序”或“不明确行为带来的风险”好。为了让这成为一个可行方案，程序必须能够继续可靠地执行，即使在遭遇并忽略一个错误之后。</p>
<p>&emsp;&emsp;这些办法都没什么吸引力。问题在于两者都无法对“导致close抛出异常”的情况做出反应。</p>
<p>&emsp;&emsp;一个较佳策略是重新设计DBConn接口，使其客户有机会对可能出现的问题做出反应。例如DBConn自己可以提供一个close函数，因而赋予客户一个机会得以处理“因该操作而发生的异常”。DBConn也可以追踪其所管理的DBConnection是否已被关闭，并在答案为否的情况下由其析构函数关闭之。这可防止遗失数据库连接。然而如果DBConnection析构函数调用close失败，我们将又退回“强迫结束程序”或“吞下异常”的老路：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;  <span class="comment">//供客户使用的新函数</span></span><br><span class="line">       db.<span class="built_in">close</span>();</span><br><span class="line">       closed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~DBConn() &#123;</span><br><span class="line">        <span class="keyword">if</span>(!closed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  <span class="comment">//关闭连接（如果客户不那么做的话）</span></span><br><span class="line">                db.<span class="built_in">close</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">                <span class="comment">//制作运转记录，记下对close的调用失败；</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    <span class="keyword">bool</span> closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;把调用close的责任从DBConn析构函数手上移到DBConn客户手上（但DBConn析构函数内仍内含一个“双保险”调用）可能会给我们“肆无忌惮转移负担”的印象。实际上在这里并无大碍。如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。本例要说的是，由客户自己调用close并不会对他们带来负担，而是给他们一个处理错误的机会，否则他们没机会响应。如果他们不认为这个机会有用（或许他们坚信不会有错误发生），可以忽略它，依赖DBConn析构函数去调用close。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li><p>析构函数绝对不要抛出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</p>
</li>
<li><p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>务必重视vector容器中元素的删除操作</title>
    <url>/2021/04/09/%E5%8A%A1%E5%BF%85%E9%87%8D%E8%A7%86vector%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h1 id="vector的小“删除”，大“智慧”"><a href="#vector的小“删除”，大“智慧”" class="headerlink" title="vector的小“删除”，大“智慧”"></a>vector的小“删除”，大“智慧”</h1><p>&emsp;&emsp;在STL中，某些算法（移除型算法），它们本质上只是进行逻辑性的思考。这些算法并不会改变元素的数量，反而是将原本置于后面的“不移除元素”向前移动，以此来覆盖那些应被移除的元素而已。它们都返回新区间的逻辑终点（也就是最后一个“不移除元素”的下一个位置。</p>
<p>&emsp;&emsp;那么如果要真正地删除我们不需要的元素，到底要如何处理呢？一般的手段虽然会简单粗暴，但正是这些粗暴的手法会将我们的程序带到崩溃的边缘。考虑以下代码：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">... </span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; str = &#123; <span class="string">"Chuck Berry"</span>, <span class="string">"Little Richard"</span>, <span class="string">"Alice"</span>, <span class="string">"Bob"</span>, <span class="string">"Jerry Lee Lewis"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除str中不是摇滚歌手的人</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span>(FIND_IF_NOT_ROCKSTAR(*it));</span><br><span class="line">        str.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出结果</span></span><br><span class="line">PRINT_ELEMENTS(str, <span class="string">"ALL of these are rockstar: "</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后打印出来的结果可能不会合乎你的预期——打印出除了Alice与Bob以外的所有人，结果而是把Bob也一同打印出来了，Alice被正确的剔除了。</p>
<h1 id="erase所执行的操作"><a href="#erase所执行的操作" class="headerlink" title="erase所执行的操作"></a>erase所执行的操作</h1><p>&emsp;&emsp;关于vector的erase在STL中的语义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator <span class="built_in">position</span>)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span></span><br></pre></td></tr></table></figure>

<p>第一个将删除position所指位置的元素，并返回所删除元素的下一个位置；第二个将删除[first,last)区间的元素，并返回所删除元素的下一个位置，也就是last。</p>
<p>&emsp;&emsp;此外，值得一提的是，关于string的erase在STL中的语义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string::clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>两个函数都会删除string内等所有字符，因此调用后string为空。</li>
<li><code>erase()</code>返回<code>*this</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(size_type idx)</span></span></span><br><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">erase</span><span class="params">(size_type idx, size_type len)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>两种形式都删除<code>*this</code>之内从索引idx开始的最多len个字符。</li>
<li>都返回<code>*this</code>。</li>
<li>如果未指定<em>len</em>，则删除idx之后的所有字符。</li>
<li>如果<code>idx &gt; size()</code>，两种形式都抛出out_if_range异常。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator pos)</span></span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator beg, const_iterator <span class="built_in">end</span>)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>分别删除pos所指的单一字符或[beg,end)区间内的所有字符。</li>
<li>都返回最后一个被删除字符的下一字符（因此第二形式返回的是end）。</li>
<li>在C++11之前，pos、beg和end的类型都是iterator。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除最末字符。</li>
<li>对空string调用此函数，会导致不明确行为。</li>
<li>始自C++11。</li>
</ul>
<p>&emsp;&emsp;现在让我们来看看erase到底瞒着我们干了些什么？erase用于从一个集合中删除一个元素，但是对于基于数组的容器，例如这里的vector（溯源到它的本家c数组），存储在删除元素后的所有元素都需要向前也就是往它们前一个元素的位置移动一位，以避免集合中留下“空位”，最后再将集合的容量缩减一个sizeof（type）并delete多余分配的空间。但这也导致了大量的开销，当然本篇blog不对此进行讨论。然而指向被删除元素的迭代器却不会那么聪明地也向前移动，它依然指向被删除元素的位置，也就是指向了被删除元素后的元素。</p>
<p>&emsp;&emsp;让我们看下erase操作后，str中的情况：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">"Chuck Berry"</span>, <span class="string">"Little Richard"</span>, <span class="string">"Bob"</span>, <span class="string">"Jerry Lee Lewis"</span></span><br></pre></td></tr></table></figure>

<h1 id="如何正确的删除vector中的元素"><a href="#如何正确的删除vector中的元素" class="headerlink" title="如何正确的删除vector中的元素"></a>如何正确的删除vector中的元素</h1><p>&emsp;&emsp;既然，循规蹈矩的手段不行，那么在遇到这样的问题时，我们需要停下来，好好想想，考虑如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = str.<span class="built_in">begin</span>(); it != str.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(FIND_IF_NOT_ROCKSTAR(*it)) &#123;</span><br><span class="line">        str.erase(it);</span><br><span class="line">        --it;</span><br><span class="line">    &#125;</span><br><span class="line">    ++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结果很好，得到了我们想要的。但是这样的代码始终看起来不那么好看，对于代码洁癖的某些人可能会十分的不适。另一种方法可能会满足你的口味：remove。</p>
<h1 id="将remove与erase组合起来"><a href="#将remove与erase组合起来" class="headerlink" title="将remove与erase组合起来"></a>将remove与erase组合起来</h1><p>&emsp;&emsp;关于remove以及remove_if的语义在STL中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ForwardIterator</span><br><span class="line"><span class="built_in">remove</span>(ForwardIterator beg, ForwardIterator <span class="built_in">end</span>,</span><br><span class="line">       <span class="keyword">const</span> T&amp; value)</span><br><span class="line">  </span><br><span class="line">ForwardIterator</span><br><span class="line">remove_if(ForwardIterator beg, ForwardIterator <span class="built_in">end</span>,</span><br><span class="line">          UnaryPredicate op)</span><br></pre></td></tr></table></figure>

<h2 id="remove与remove-if的规则与原理"><a href="#remove与remove-if的规则与原理" class="headerlink" title="remove与remove_if的规则与原理"></a>remove与remove_if的规则与原理</h2><ul>
<li>remove会移除[beg,end)区间中每一个“与value相等”的元素。</li>
<li>remove_if会移除[beg,end)区间中每一个“令unary predicate op(elem)结果为true”的元素。</li>
<li>两个算法都返回被改动的序列的新逻辑终点（也就是最后一个未被移除元素的下一位置）。</li>
<li>这些算法会把原本置于后面的未移除元素向前移动，覆盖被移除元素。</li>
<li>未被移除的元素在相对次序上保持不变。</li>
<li>注意，remove_if通常会在内部复制它所获得的那个unary predicate，然后两次运用它。如果该unary predicate在函数调用过程中改改变状态，就可能导致问题。</li>
<li>由于元素会被改动，所以这些算法不可用于associative或unorderd容器。然而这些容器提供了功能类似的成员函数erase。</li>
<li>List提供了一个效果相同的成员函数remove，效能较高，原因是它不重新赋值，而是重新链接pointer。</li>
<li>复杂度：线性。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_int = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印remove操作之前的vector元素</span></span><br><span class="line">    PRINT_ELEMTNS(vec_int, <span class="string">"vec_int: "</span>);</span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">remove</span>(vec_int.<span class="built_in">begin</span>(), vec_int.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 打印remove操作之后的vector元素</span></span><br><span class="line">    PRINT_ELEMENTS(vec_int, <span class="string">"size is not changed: "</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将remove操作后残存的“影子”移除掉</span></span><br><span class="line">    vec_int.erase(it, vec_int.<span class="built_in">end</span>());</span><br><span class="line">    PRINT_ELEMENTS(vec_int, <span class="string">"size is changed: "</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 移除所有小于4的元素</span></span><br><span class="line">    vec_int.erase(remove_if(vec_int.<span class="built_in">begin</span>(), vec_int.<span class="built_in">end</span>(),</span><br><span class="line">                  [](<span class="keyword">int</span> elem)&#123;</span><br><span class="line">                      <span class="keyword">return</span> elem &lt; <span class="number">4</span>;</span><br><span class="line">                  &#125;),</span><br><span class="line">                  vec_int.<span class="built_in">end</span>());</span><br><span class="line">  </span><br><span class="line">    PRINT_ELEMENTS(vec_int, <span class="string">" &lt; 4 remove: "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;很好，这样一来我们的代码就十分契合STL的范式了。需要记住的是，我们不必担心这里的效率问题，对于for_each，for auto以及传统的for循环，它们都已经经由编译器的优化呈现给你了，它们的效率并无太大的差别。可以根据个人的习惯来决定到底是使用哪个。</p>
<h1 id="clear所执行的动作"><a href="#clear所执行的动作" class="headerlink" title="clear所执行的动作"></a>clear所执行的动作</h1><p>&emsp;&emsp;clear将vector容器中的所有元素抹除，并且将vector的容器容量变为0。但是reallocation动作并不会一定保证发生，同样的容器的容量也不会保证一定被更改。一个典型的替代方法是使用swap来强制reallocation动作发生：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;T&gt;().swap(x);  <span class="comment">// clear x reallocating</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>创建进程的fork函数</title>
    <url>/2021/05/03/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84fork%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h1><p>&emsp;&emsp;每个进程都有一个非负整数表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。例如，应用程序有时就把进程ID作为名字的一部分来创建一个唯一的文件名。</p>
<p>&emsp;&emsp;虽然是唯一的，但是进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数UNIX系统实现延迟复用算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<a id="more"></a>

<p>&emsp;&emsp;系统中有一些专用进程，但是具体细节随实现而不同。ID为0的进程通常是调度进程，常常被称为交换进程。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。进程ID1通常是init进程，在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是/etc/init，在较新版本中是/sbin/init。此进程负责在自举内核后启动一个UNIX系统。init通常读取与系统有关的初始化文件（/etc/rc*文件或/etc/inittab文件，以及在/etc/init.d中的文件），并将系统引导到一个状态（如多用户）。init进程绝不会终止。它是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。</p>
<blockquote>
<p>在Mac OS X 10.4中，init进程被launched进程替代，执行的任务集与init相同，但扩展了功能。</p>
</blockquote>
<p>&emsp;&emsp;每个UNIX系统实现都有它自己的一套提供操作系统服务的内核进程，例如，在某些UNIX的虚拟存储器实现中，进程ID2是守护页进程（page daemon），此进程负责支持虚拟存储器系统的分页操作。</p>
<p>&emsp;&emsp;除了进程ID，每个进程还有一些其他标识符。下列函数返回这些标识符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回调用进程的进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回调用进程的父进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回调用进程的实际用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回调用进程的有效用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回调用进程的实际组ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回调用进程的有效组ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意，这些函数都没有出错返回。</p>
<h1 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h1><p>&emsp;&emsp;一个现有的进程可以调用fork函数创建一个新进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由fork创建的新进程被称为子进程（child process）。fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。将子进程ID返回给父进程的理由是：因为一个进程的子进程可以有多个，并且没有一个函数使一个进程可以获得其所有子进程的进程ID。fork使子进程得到返回值0的理由是：一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得父进程的进程ID（进程ID0总是由内核交换进程使用，所以一个子进程的进程ID不可能为0）。</p>
<p>&emsp;&emsp;子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。</p>
<p>&emsp;&emsp;由于在fork之后经常跟随着exec，所以现在的很多实现并不执行一个父进程数据段、堆和栈的完全副本。作为替代，使用了写时复制（Copy-On-Write，COW）技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任何一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的“一页”。</p>
<p>&emsp;&emsp;使fork失败的两个主要原因是：</p>
<ol>
<li>系统中已经有太多的进程（通常意味着某个方面出了问题）。</li>
<li>该实际用户ID的进程总数超过了系统限制。其中CHILD_MAX规定了每个实际用户ID在任一时刻可拥有的最大进程数。</li>
</ol>
<p>&emsp;&emsp;fork有以下两种用法：</p>
<ol>
<li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的——父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求。</li>
<li>一个进程要执行一个不同的程序。这对shell是常见的情况。在这种情况下，子进程从fork返回后立即调用exec。</li>
</ol>
<p>&emsp;&emsp;某些操作系统将第2种用法中的两个操作（fork之后执行exec）组合成一个操作，称为spawn。UNIX系统将这两个操作分开，因为在很多场合需要单独使用fork，其后并不跟随exec。另外，将这两个操作分开，使得子进程在fork和exec之间可以更改自己的属性，如I/O重定向、用户ID、信号安排等。</p>
<blockquote>
<p>Single UNIX Specification在高级实时选项组中确实包括了spawn接口。但是该接口并不想替换fork和exec。它们的目的是支持难于有效实现fork的系统，特别是对存储管理缺少硬件支持的系统。</p>
</blockquote>
<h1 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h1><p>&emsp;&emsp;vfork函数的调用序列和返回值与fork相同，但两者的语义不同。</p>
<blockquote>
<p>vfork起源于较早的2.9BSD。有些人认为，该函数是有瑕疵的。但是以下4种UNIX系统：FreeBSD8.0、Linux3.2.0、Mac OS X 10.6.8和Solaris 10实际上都支持它。事实上，BSD的开发者在4.4BSD中删除了该函数，但4.4BSD派生的所有开放源码BSD版本又将其回收。SUSv3中，vfork被标记为弃用的接口，在SUSv4中被完全删除。只是由于历史的原因还是把它包含进来。可移植的应用程序不应该使用这个函数。</p>
</blockquote>
<p>&emsp;&emsp;vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec（或exit），于是也就不会引用该地址空间。不过在子进程调用exec或exit之前，它在父进程的空间中运行。这种优化工作方式在某些UNIX系统的实现中提高了效率，但如果子进程修改数据（除了用于存放vfork返回值的结果）、进行函数调用、或者没有调用exec或exit就返回都可能会带来未知的结果。</p>
<p>&emsp;&emsp;vfork和fork之间的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数中的任意一个时，父进程会恢复运行。（如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。）</p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>线程进程</tag>
      </tags>
  </entry>
  <entry>
    <title>剔除template内与参数无关的代码</title>
    <url>/2020/11/16/%E5%89%94%E9%99%A4template%E5%86%85%E4%B8%8E%E5%8F%82%E6%95%B0%E6%97%A0%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<hr>
<h1 id="剔除template内与参数无关的代码"><a href="#剔除template内与参数无关的代码" class="headerlink" title="剔除template内与参数无关的代码"></a>剔除template内与参数无关的代码</h1><p>&emsp;&emsp;使用template可以有效地避免代码重复。有时候你会需求10个类，每一个都含有100个成员函数（当然啦，这里稍微有点夸张）。那么在此情况下，你只需要编写一个class template，然后剩下的事情就交给编译器去吧，由编译器来具现化这10个类跟1000个成员函数。由于class template的成员函数只有在被使用时才会被具现化，因此只有当某些函数被真正使用时，你才会获得这些函数。同样的，function template也有此类功能。为了避免写出大量重复函数代码，你只需要写一个function template，然后让编译器去完成剩下的事情就够了。看来“懒惰”才是推进人类技术进步的关键。</p>
<a id="more"></a>

<p>&emsp;&emsp;但是，如果你的经验不够老道，使用template也可能会导致代码膨胀：其二进制码会带着重复的代码、数据，或两者都有。其结果就是：有可能看起来源码倒是挺干净整齐的，但目标码却不是这样的。所以你需要知道如何避免这样的二进制码臃肿。</p>
<p>&emsp;&emsp;这里要提到一个名称：commonality and variability analysis。翻译过来就是共性与变性分析，即使你从来没有写过template，你也应该熟悉这个分析方式。</p>
<p>&emsp;&emsp;比如，当你编写某个函数时，你会发现其中一个函数的某些实现码与另一个函数的实现码实质上是一样的。当然，一般来说我们不会去单纯地去重复这些代码，除非你是一个懒惰且不求甚解的程序员。为了避免这种情况，你一般会抽出这两个函数共同的部分，把它们放到第三个函数中，然后令原先两个函数调用这个函数。所谓“共性与变性分析”也就是：你分析这两个函数，找出它们共同的部分和变化的部分，把共同的部分搬到一个新函数去，保留变化的部分在原函数中不动。同样的道理，对于class来说，假设你正在编写2个class，而你需要将其中一个class与另外一个class共同的部分搬到一个新的class去，然后使用继承或复合，令原先的class取得这个共同特性。而原class的互异部分依然保留在原来的位置。</p>
<p>&emsp;&emsp;编写template时，也是要做上述类似的分析，以相同的方式来避免重复，但这里有一个关键点。在non-template中，重复的源码十分清楚明了：你可以“看到”两个函数或两个class之间确实有所“重复”。然而在template代码中，重复却是隐晦的：毕竟只存在一份template源码，所以你必须要能够感受到当template被具现化多次时可能发生的重复，这种感知需要长期的训练。</p>
<p>&emsp;&emsp;举个例子，假设你要为一个固定尺寸的正方形矩阵编写一个template。该矩阵的性质之一是支持逆矩阵运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typeame T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span></span>;  <span class="comment">//求逆矩阵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个template接受一个类型参数T，还有一个类型为size_t的参数（这是一个非类型参数）。这种非类型参数比起类型参数并不是那么常见，但是它们是合法的.</p>
<p>&emsp;&emsp;现在，考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">5</span>&gt; sm1;</span><br><span class="line">...</span><br><span class="line">sm1.invert();  <span class="comment">//调用SquareMatrix&lt;double, 5&gt;::invert</span></span><br><span class="line"></span><br><span class="line">SquareMatrix&lt;<span class="keyword">double</span>, <span class="number">10</span>&gt; sm2;</span><br><span class="line">...</span><br><span class="line">sm2.invert();  <span class="comment">//调用SquareMatrix&lt;double, 10&gt;::invert</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码会具现出两份invert。这些函数并非完全相同，因为其中一个操作的是5*5矩阵而另一个操作的是10*10矩阵，但除了这两个常量5跟10，两个函数的其他部分完全相同。这是template造成代码膨胀的一个典型例子。</p>
<p>&emsp;&emsp;如果你看到两个函数完全相同，除了一个使用5而另一个使用10，这种情况下，你会怎么做？你的本能可能会为它们创建一个带数值参数的函数，然后以5和10来调用这个带参数的函数，而不重复代码。下面是对SquareMatrix的第一次修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span> &#123;</span>                      <span class="comment">//与尺寸无关的base class用于正方矩阵</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> matrixSize)</span></span>;  <span class="comment">//以给定尺寸求逆矩阵</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;  <span class="comment">//避免遮掩base版的invert</span></span><br><span class="line">                                            <span class="comment">//避免编译器不进入到base class作用域内查找invert</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invert</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;invert(n); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;base class SquareMatrixBase内有带参数的invert。也就是说，其只对“矩阵对象的类型”参数化，不对矩阵的尺寸参数化。因此对于某给定的对象类型，所有该类型的矩阵共享同一个SquareMatrixBase class，当然其中的带参数的invert也是共享的。</p>
<p>&emsp;&emsp;SquareMatrixBase::invert本意是为了“避免derived class代码重复”，并没有打算提供给用户这个机能，因此它以protected替换public。并且调用它的额外成本应该为0，因为derived class的invert调用base class版本时用的是inline调用。这里的函数应该使用“this-&gt;”，正如“<a href="/2020/11/15/%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E7%89%88%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/" title="学习处理模版化基类内的名称">学习处理模版化基类内的名称</a>”所说，若不这样做，编译器便不会进入到base class作用域内查找SquareMatrixBase的invert。最后，要注意的是上述代码的继承关系为private。也就是说这里的base class只是为了帮助derived class实现，而不是为了表现SquareMatrix和SquareMatrixBase之间的is-a关系。</p>
<p>&emsp;&emsp;接下来棘手的问题来了，SquareMatrixBase::invert如何知道该操作什么数据？虽然它从参数中知道了矩阵的尺寸，但它又如何知道哪个特定矩阵的数据在哪儿？想必只有derived class才知道吧。那么问题又来了，derived class该如何联络base class做逆矩阵运算呢？</p>
<p>&emsp;&emsp;其中一个办法是令SquareMatrixBase存储一个指针，指向矩阵数值所在的内存。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrixBase</span> &#123;</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        SquareMatrixBase(<span class="built_in">std</span>::<span class="keyword">size_t</span> n, T* pMem)  <span class="comment">//存储矩阵大小和一个指针</span></span><br><span class="line">            : <span class="built_in">size</span>(n), pData(pMem) &#123;&#125;             <span class="comment">//指针指向矩阵数值</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setDataPtr</span><span class="params">(T* ptr)</span> </span>&#123; pData = ptr; &#125;  <span class="comment">//重新赋值给pData</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>;  <span class="comment">//矩阵的大小</span></span><br><span class="line">        T* pData;          <span class="comment">//指针，指向矩阵内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这允许derived class决定内存分配方式。某些实现版本也许会将矩阵数据存储在SquareMatrix对象内部：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SquareMatrix()                         <span class="comment">//将矩阵大小</span></span><br><span class="line">            : SquareMatrixBase&lt;T&gt;(n, data) &#123;&#125;  <span class="comment">//和数据指针送给base class</span></span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T data[n*n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种类型的对象不需要动态分配内存，但对象自身可能非常大。另一种做法是把每一个矩阵的数据放进heap（也就是通过new来分配内存）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="built_in">std</span>::<span class="keyword">size_t</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SquareMatrix</span> :</span> <span class="keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        SquareMatrix()                          <span class="comment">//将base class的数据指针设为null，</span></span><br><span class="line">            : SquareMatrixBase&lt;T&gt;(n, <span class="number">0</span>),        <span class="comment">//为矩阵内容分配内存，</span></span><br><span class="line">            pData(<span class="keyword">new</span> T[n*n])                   <span class="comment">//将指向该内存的指针存储起来，</span></span><br><span class="line">            &#123; <span class="keyword">this</span>-&gt;setDataPtr(pData.<span class="built_in">get</span>()); &#125;  <span class="comment">//然后将它的一个副本交给base class</span></span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        boost::scoped_array&lt;T&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码中SquareMatrix成员函数可以单纯地以inline方式调用base class版本，后者由“持有同类型元素（不论矩阵大小）之所有矩阵共享。更棒的是，不同大小的SquareMatrix对象现在有着不同的类型！即使（例如SquareMatrix&lt;double,5&gt;和SquareMatrix&lt;double,10&gt;）对象使用相同的SquareMatrixBase&lt;double&gt;成员函数，你也没法传递一个SquareMatrix&lt;double,5&gt;对象到一个期望获得SquareMatrix&lt;double,10&gt;的函数去。</p>
<p>&emsp;&emsp;这确实很棒，但是必须要付出一定的代价。绑着矩阵尺寸的那个invert版本，有可能生成比共享版本（其中尺寸是以函数参数传递或存储在对象内）更佳的代码。例如在尺寸专属版中，尺寸是个编译期常量，因此可以借助常量的“广泛传播性”达到最优化，包括把它们置于生成指令中成为直接操作数。这在“与尺寸无关”的版本中是无法办到的。</p>
<p>&emsp;&emsp;但是从另一个角度看，不同大小的同类型矩阵共享一个invert，可以减少执行文件的大小，也就因此降低了程序的working set（所谓working set是指对一个在“虚内存环境”下执行的进程而言，其所使用的那一组内存页）大小，并强化指令高速缓存区内的引用集中化。这些都可能令程序执行得更加快速，从而超越“尺寸专属版”invert的最优化效果。孰优孰劣就得看你的平台的行为以及实际代码中数据的表现了。</p>
<p>&emsp;&emsp;另一个效能评比的主题是对象大小。现在将前述“与矩阵大小无关的函数版本”搬到base class内，这会增加每个对象的大小。例如在上述代码中，每一个SquareMatrix对象都有一个指针（继承自base class）指向其内矩阵的数据。虽然每个derived class已有一种取得数据的办法，这会对每一个SquareMatrix对象增加至少一个指针那么大。当然你也可以修改这个设计，将这些指针拿掉，但是这依旧会留给你若干抉择问题。例如令base class存储一个protected指针指向矩阵数据，会导致其丧失封装性，也可能造成资源管理上的混乱和复杂。如果base class存储一个指针指向矩阵数据，那些数据空间也许是动态分配的，也许存储于derived class对象内，如何判断这个指针该不该删除呢？这个问题的答案留给你在以后的工作中慢慢思索，但是你越是尝试精密的做法，事情就会变得越发复杂。从这个角度来看，少许的代码重复倒是挺合情合理的。</p>
<p>&emsp;&emsp;综上讨论的都还仅限于非类型模版参数带来的膨胀，其实类型参数也会导致膨胀。例如在许多平台上int和long有相同的二进制表述，所以像vector&lt;int&gt;和vector&lt;long&gt;的成员函数有可能完全相同——也就是膨胀！某些连接器会合并完全相同的函数实现码，但有些不会，后者也就意味着某些template被具现化为int和long两个版本，并因此造成代码膨胀（在某些环境下）。同样，在大多数平台上，所有指针类型都有相同的二进制表述，因此凡是template持有指针者（例如list&lt;int<em>&gt;，list&lt;const int\</em>&gt;，list&lt;SquareMatrix&lt;long,3&gt;*&gt;等等）往往应该对每一个成员函数使用唯一一份底层实现。这意味，如果你实现某些成员函数而它们操作强指针类型（即T*），你应该令它们调用另一个操作无类型指针（即void*）的函数，由后者完成实际工作。某些C++标准程序库实现版本为vector，deque和list等template做了这件事。如果你在想着如何为你的template减少代码膨胀，可以参考前述的代码程序库。</p>
<blockquote>
<ul>
<li>template生成多个class和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相互依赖的关系。</li>
<li>因非类型模版参数而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。</li>
<li>因类型模版参数而造成的代码膨胀，往往可降低，做法是让带有完全二进制表述的具现类型共享实现码。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>区分接口继承和实现继承</title>
    <url>/2020/10/29/%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<hr>
<h1 id="区分接口继承和实现继承"><a href="#区分接口继承和实现继承" class="headerlink" title="区分接口继承和实现继承"></a>区分接口继承和实现继承</h1><p>&emsp;&emsp;表面上直截了当的public继承概念，经过更严密的检查之后，发现它由两部分组成：函数接口继承和函数实现继承。这两种继承的差异，很像函数声明与函数定义之间的差异。</p>
<p>&emsp;&emsp;身为class设计者，有时候我们会希望derived class只继承成员函数的接口（也就是声明）；有时候又会希望derived class同时继承函数的接口和实现，但又希望能够覆写它们所继承的实现；又有时候希望derived class同时继承函数的接口和实现，并且不允许覆写任何东西。</p>
<a id="more"></a>

<p>&emsp;&emsp;为了更好地感觉上述选择之间的差异，让我们考虑一个展现绘图程序中各种几何形状的class继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> vod <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ellipse</span> :</span> <span class="keyword">public</span> Shape &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Shape是个抽象class；它的pure virtual函数draw使他成为一个抽象class。所以客户不能够创建Shape class的实体，只能创建其derived class的实体。尽管如此，Shape还是强烈影响了所有以public形式继承它的derived class，因为：</p>
<ul>
<li>成员函数的接口总是会被继承，public继承意味着is-a，所以对base class为真的任何事情一定也对其derived class为真。因此，如果某个函数可施行于某class身上，一定也可施行于其derived class身上。</li>
</ul>
<p>&emsp;&emsp;Shape class声明了三个函数。第一个是draw，于某个隐喻的视屏中画出当前对象。第二个是error，准备让那些“需要报导某个错误”的成员函数调用。第三个是objectID，返回当前对象的一个独立无二的整数识别码。每个函数的声明方式都不相同：draw是个pure virtual函数；error是个简朴的（非纯）impure virtual函数；objectID是个non-virtual函数。这些不同的声明带来什么样的暗示呢？</p>
<p>&emsp;&emsp;首先考虑pure virtual函数draw：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;pure virtual函数有两个最突出的特性：它们必须被任何“继承了它们”的具象class重新声明，而且它们在抽象class中通常没有定义。把这两个性质摆在一起，你就会明白：</p>
<ul>
<li>声明一个pure virtual函数的目的是为了让derived class只继承函数接口。</li>
</ul>
<p>&emsp;&emsp;这对Shape::draw函数是再合理不过的事了，因为所有Shape对象都应该是可绘出的，这是合理的要求。但Shape class无法为此函数提供合理的缺省实现，毕竟椭圆形绘法迥异于矩形绘法。Shape::draw的声明式乃是对具象derived class设计者说，“你必须提供一个draw函数，但我不干涉你怎么实现它。”</p>
<p>&emsp;&emsp;令人意外的是，我们竟然可以为pure virtual函数提供定义。也就是说你可以为Shape::draw供应一份实现代码，C++并不会发出怨言，但调用它的唯一途径是“调用时明确指出其class名称”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shape* ps = <span class="keyword">new</span> Shape;       <span class="comment">//错误！Shape是抽象的</span></span><br><span class="line">Shape* ps1 = <span class="keyword">new</span> Rectangle;  <span class="comment">//没问题</span></span><br><span class="line">ps1-&gt;draw();                 <span class="comment">//调用Rectangle::draw</span></span><br><span class="line">Shape* ps2 = <span class="keyword">new</span> Ellipse;    <span class="comment">//没问题</span></span><br><span class="line">ps2-&gt;draw();                 <span class="comment">//调用Ellipse::draw</span></span><br><span class="line">ps1-&gt;Shape::draw();          <span class="comment">//调用Shape::draw</span></span><br><span class="line">ps2-&gt;Shape::draw();          <span class="comment">//调用Shape::draw</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;除了能够帮助你在高雅酒会上留给大师级程序员一个深刻的印象，一般而言这项性质用途有限。但是稍后你将看到，它可以实现一种机制，为简朴的（非纯）impure virtual函数提供更平常更安全的缺省实现。</p>
<p>&emsp;&emsp;简朴的impure virtual函数背后的故事和pure virtual函数有点不同。一如往常，derived class继承其函数接口，但impure virtual函数会提供一份实现代码，derived class可能覆写它。稍加思索，你就会明白：</p>
<ul>
<li>声明简朴的（非纯）impure virtual函数的目的，是让derived class继承该函数的接口和缺省实现。</li>
</ul>
<p>&emsp;&emsp;考虑Shape::error这个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其接口表示，每个class都必须支持一个“当遇上错误时可调用”的函数，但每个class都可自由处理错误。如果某个class不想针对错误做出任何特殊行为，它可以退回到Shape class提供的缺省错误处理行为。也就是说Shape::error的声明式告诉derived class的设计者，“你必须支持一个error函数，但如果你不想自己写一个，可以使用Shape class提供的缺省版本”。</p>
<p>&emsp;&emsp;但是，允许impure virtual函数同时指定函数声明和函数缺省行为，却有可能造成危险。欲探讨原因，让我们考虑XYZ航空公司设计的飞行继承体系。该公司只有A型和B型飞机，两者都以相同方式飞行。因此XYZ设计出这样的继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airport</span> &#123;</span> ... &#125;;  <span class="comment">//用以表现机场</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    缺省代码，将飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为了表示所有飞机都一定能飞，并阐明“不同型飞机原则上需要不同的fly实现”，Airplane::fly被声明为virtual。然而为了避免在ModelA和ModelB中撰写相同代码，缺省飞行行为由Airplane::fly提供，它同时被ModelA和ModelB继承。</p>
<p>&emsp;&emsp;这是个典型的面相对象设计。两个class共享一份相同性质（也就是它们实现fly的方式），所以共同性质被搬到base class中，然后被这两个class继承。这个设计突显出共同性质，避免代码重复，并提升未来的强化能力，减缓长期维护所需的成本。所有这些都是面相对象技术如此受到欢迎的原因。XYZ航空公司应该感到骄傲。</p>
<p>&emsp;&emsp;现在，假设XYZ盈余大增，决定购买一种新式C型飞机。C型和A型以及B型有某些不同。更明确地说，它的飞行方式不同。</p>
<p>&emsp;&emsp;XYZ公司的程序员正在继承体系中针对C型飞机添加了一个class，但由于他们急着让新飞机上线服务，竟忘了重新定义其fly函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    ...  <span class="comment">//未声明fly函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后代码中有一些诸如此类的动作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Airport <span class="title">MLP</span><span class="params">(...)</span></span>;  <span class="comment">//MLP是某个机场</span></span><br><span class="line">Airplane* pa = <span class="keyword">new</span> ModelC;</span><br><span class="line">...</span><br><span class="line">pa-&gt;fly(MLP);      <span class="comment">//调用Airplane::fly</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这将酿成大祸；这个程序试图以ModelA或ModelB的飞行方式来飞ModelC。</p>
<p>&emsp;&emsp;问题不在Airplane::fly有缺省行为，而在于ModelC在未明白说出“我要”的情况下就继承了该缺省行为。幸运的是我们可以轻易做到“提供缺省实现给derived class，但除非它们明白要求否则免谈”。此间伎俩在于切断“virtual函数接口”和其”缺省实现“之间的连接。下面是一种做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::defaultFly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    缺省行为，将飞行飞至指定目的地。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;请注意，Airplane::fly已被改为一个pure virtual函数，只提供飞行接口。其缺省行为也出现在Airplane class中，但此次系以独立函数defaultFly的姿态出现。若想使用缺省实现（例如ModelA和ModelB），可以在其fly函数中对defaultFly做一个inline调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            defaultFly(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            defaultFly(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在ModelC class不可能意外继承不正确的fly实现代码了，因为Airplane中的pure virtual函数迫使ModelC必须提供自己的fly版本：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span> </span>&#123;</span><br><span class="line">    将C型飞机飞至指定目的地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个方案并非安全无虞，程序员还是可能因为剪贴代码而招来麻烦，但它的确比原先的设计值得依赖。至于Airplane::defaultFly，请注意它现在成了protected，因为它是Airplane及其derived class的实现细目。乘客应该只在意飞机能不能飞，不在意它们怎么飞。</p>
<p>&emsp;&emsp;Airplane::defaultFly是个non-virtual函数，这一点也很重要。因为没有任何一个derived class应该重新定义此函数。如果defaultFly是virtual函数，就会出现一个循环问题：万一某些derived class忘记重新定义defaultFly，会怎样？</p>
<p>&emsp;&emsp;有些人反对以不同的函数分别提供接口和缺省实现，像上述的fly和defaultFly那样。他们关心因过度雷同的函数名称而引起的class命名空间污染问题。但是他们也同意，接口和缺省实现应该分开。这个表面上看起来的矛盾该如何解决？唔，我们可以利用“pure virtual函数必须在derived class中重新声明，但它们也可以拥有自己的实现”这一事实。下面便是Airplane继承体系如何给pure virtual函数一份定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Airplane::fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123; <span class="comment">//pure virtual函数实现</span></span><br><span class="line">    缺省行为，将飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            Airplane::fly(destination);</span><br><span class="line">        &#125; </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelB</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">            Airplane::fly(destination);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelC</span> :</span> <span class="keyword">public</span> Airplane &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModelC::fly</span><span class="params">(<span class="keyword">const</span> Airplane&amp; destination)</span> </span>&#123;</span><br><span class="line">    将C型飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这几乎和前一个设计一摸一样，只不过pure virtual函数Airplane:fly替换了独立函数Airplane::defaultFly。本质上，现在的fly被分割为两个基本要素：其声明部分表现的是接口（那是derived class必须使用的），其定义部分则表现出缺省行为（那是derived class可能使用的，但只有在它们明确提出申请时才是）。如果合并fly和defaultFly，就丧失了“让两个函数享有不同保护级别”的机会：习惯上被设为protected的函数（defaultFly）如今成了public（因为它在fly之中）。</p>
<p>&emsp;&emsp;最后，让我们看看Shape的non-virtual函数objectID：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">objectID</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果成员函数是个non-virtual函数，意味着它并不打算在derived class中有不同的行为。实际上一个non-virtual成员函数所表现的不变性凌驾其特异性，因为它表示不论derived class变得多么特异化，它的行为都不可以改变。就其自身而言：</p>
<ul>
<li>声明non-virtual函数的目的是为了令derived class继承函数的接口及一份强制性实现。</li>
</ul>
<p>&emsp;&emsp;你可以把Shape::objectID的声明想做是：“每个Shape对象都有一个用来产生对象识别码的函数；此识别码总是采用相同计算方法，该方法由Shape::objectID的定义式决定，任何derived class都不应该尝试改变其行为”。由于non-virtual函数代表的意义是不变性凌驾特异性，所以它绝不该在derived class中被重新定义。</p>
<p>&emsp;&emsp;pure virtual函数、simple（impure）virtual函数、non-virtual函数之间的差异，使你得以精确指定你想要derived class继承的东西：只继承接口，或是继承接口和一份缺省实现，或是继承接口和一份强制实现。由于这些不同类型的声明意味着根本意义并不相同的事情，当你声明你的成员函数时，必须谨慎选择。如果你确实履行，应该能够避免经验不足的class设计者最常犯的两个错误。</p>
<p>&emsp;&emsp;第一个错误是将所有函数声明为non-virtual。这使得derived class没有余裕空间进行特化工作。non-virtual析构函数尤其会带来问题（见“<a href="/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" title="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</a>”）。当然啦，设计一个并不想成为base class的class是绝对合理的，既然这样，将其所有成员函数都声明为non-virtual也很适当。但这种声明如果不是忽略了virtual和non-virtual函数之间的差异，就是过度担心virtual函数的效率成本。实际上任何class如果打算被用来当做一个base class，都会拥有若干virtual函数。</p>
<p>&emsp;&emsp;如果你关心virtual函数的成本，请容许我介绍所谓的80-20法则（也可见“<a href="/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/" title="透彻了解inlining的里里外外">透彻了解inlining的里里外外</a>。这个法则说，一个典型的程序有80%的执行时间花费在20%的代码身上。此一法则十分重要，因为它意味，平均而言你的函数调用中可以有80%是virtual而不冲击程序的大体效率。所以当你担心是否有能力负担virtual函数的成本之前，请先将心力放在那举足轻重的20%代码上头，它才是关键。</p>
<p>&emsp;&emsp;另一个常见错误是将所有成员函数声明为virtual。有时候这样做是正确的，例如“<a href="/2020/08/13/%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E/" title="将文件间的编译依存关系降至最低">将文件间的编译依存关系降至最低</a>”的interface class。然而这也可能是class设计者缺乏坚定立场的前兆。某些函数就是不该在derived class中被重新定义，果真如此你应该将那些函数声明为non-virtual。没有人有权利妄称你的class适用于任何人任何事物而他们只需花点时间重新定义你的函数就可以享受一切。如果你的不变性凌驾特异性，别害怕说出来。</p>
<blockquote>
<ul>
<li>接口继承和实现继承不同。在public继承之下，derived class总是继承base class的接口。</li>
<li>pure virtual函数只具体指定接口继承。</li>
<li>简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承。</li>
<li>non-virtual函数具体指定接口以及强制性实现继承。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>单一继承中的数据成员的布局</title>
    <url>/2021/11/01/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<hr>
<h1 id="单一继承中的数据成员的布局"><a href="#单一继承中的数据成员的布局" class="headerlink" title="单一继承中的数据成员的布局"></a>单一继承中的数据成员的布局</h1><p>&emsp;&emsp;在C++中，类成员在内存中的布局会随着编译器和机器的不同而有所差别，有的相差甚大，错综复杂。本系列blog将以两种情况进行讨论：<strong>单继承中的数据成员的布局</strong>和<strong>多重继承中的数据成员的布局</strong>。其中后者十分的复杂，见“<a href="/2021/10/25/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/" title="多重继承中数据成员的布局">多重继承中数据成员的布局</a>”。以下讨论均位于64位机器以及gcc编译器上进行，因此结果可能与读者所进行的测试有所出入，但是分析方式大体一致。</p>
<a id="more"></a>

<h2 id="基类无虚函数，子类亦无虚函数"><a href="#基类无虚函数，子类亦无虚函数" class="headerlink" title="基类无虚函数，子类亦无虚函数"></a>基类无虚函数，子类亦无虚函数</h2><h3 id="无virtual继承"><a href="#无virtual继承" class="headerlink" title="无virtual继承"></a>无virtual继承</h3><p>&emsp;&emsp;此类情况最为简单，考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> x; </span><br><span class="line">    <span class="keyword">int</span> y; </span><br><span class="line">  </span><br><span class="line">    Point2D() &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point2D's             address: %p\n"</span>, <span class="keyword">this</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point2D::x's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;x)); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point2D::y's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;y)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> :</span> <span class="keyword">public</span> Point2D &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> z; </span><br><span class="line"> </span><br><span class="line">    Point3D() &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D's             address: %p\n"</span>, <span class="keyword">this</span>); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D::x's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;x)); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D::y's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;y)); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D::z's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;z)); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>Point2D的内存布局如下：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-01%20%E4%B8%8B%E5%8D%881.01.16%281%29.png" alt="1"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Point2D），Point2D::x</td>
<td>0</td>
</tr>
<tr>
<td>Point2D::y</td>
<td>4</td>
</tr>
</tbody></table>
<ul>
<li>Point3D的内存布局如下：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-01%20%E4%B8%8B%E5%8D%881.04.50%282%29.png" alt="2"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Point3D，Point3D::Point2D），Point3D::Point2D::x</td>
<td>0</td>
</tr>
<tr>
<td>Point3D::Point2D::y</td>
<td>4</td>
</tr>
<tr>
<td>Point3D::z</td>
<td>8</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;Point3D继承了Point2D的x，y，并且存放在Point2D subobject中。那么如果，Point3D也有一个x，它覆盖了Point2D的x，那么，它的内存布局又是如何？假设其x定义于z之后（数据成员按照其声明顺序依次摆放）：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Point3D，Point3D::Point2D），Point3D::Point2D::x</td>
<td>0</td>
</tr>
<tr>
<td>Point3D::Point2D::y</td>
<td>4</td>
</tr>
<tr>
<td>Point3D::z</td>
<td>8</td>
</tr>
<tr>
<td>Point3D::x</td>
<td>12</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;可以看到Point3D中的x并不会完全覆盖掉Point2D中的x，我们依然可以通过Point2D::x来显式调用。</p>
<blockquote>
<p><strong>注意</strong>，一般来说<code>&amp;Point2D::x</code>会返回x在其所属类中的偏移量（offset），例如y在Point3D中的偏移量不是相对于Point3D的而是相对于其Point2D subobject的。z的偏移量则是相对于Point3D的。</p>
<p>为了区分“没有指向任何data member”的指针，和一个指向“第一个data member”的指针，每一个真正的member offset值都被加上1。因此要取得一个data member的真正的偏移量，需要将<code>&amp;Class::data_member</code>减掉1。然而现在很多编译器都会进行优化，有些编译器的<code>&amp;Class::data_member</code>的值就是其真正的偏移量。例如gcc编译器。</p>
</blockquote>
<h3 id="virtual继承"><a href="#virtual继承" class="headerlink" title="virtual继承"></a>virtual继承</h3><p>&emsp;&emsp;当继承为virtual时，Point2D布局不变。</p>
<ul>
<li>Point3D的内存布局如下：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-01%20%E4%B8%8B%E5%8D%8810.13.23%286%29.png" alt="6"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Point3D），vptr_Point3D</td>
<td>0</td>
</tr>
<tr>
<td>Point3D::z</td>
<td>8</td>
</tr>
<tr>
<td>（Point2D），Point2D::x</td>
<td>12</td>
</tr>
<tr>
<td>Point2D::y</td>
<td>16</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;读者可能会疑惑，这里并没有出现虚函数，但是为什么会有一个虚函数表指针呢？<code>vptr_Point3D</code>涉及到几个问题，有的编译器会使用该方法来解决虚拟继承中共享virtual base class subobject的问题。具体讨论见“<a href="/2021/10/25/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/" title="多重继承中数据成员的布局">多重继承中数据成员的布局</a>”。简单来说，就是在virtual function table中放置virtual base class的offset（而不是地址）。该offset值由<code>vptr_Point3D[-1]</code>指出。</p>
<p>&emsp;&emsp;此外，可以看到virtual base class Point2D subobject并没有像前述情况一样置于Point3D的首位，而是置于尾部。</p>
<h2 id="基类无虚函数，子类有虚函数"><a href="#基类无虚函数，子类有虚函数" class="headerlink" title="基类无虚函数，子类有虚函数"></a>基类无虚函数，子类有虚函数</h2><h3 id="无virtual继承-1"><a href="#无virtual继承-1" class="headerlink" title="无virtual继承"></a>无virtual继承</h3><p>&emsp;&emsp;将情况1的子类的<code>draw</code>函数改写为virtual，其他不变。基类的布局与情况1一样。</p>
<ul>
<li>Point3D的内存布局如下：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-01%20%E4%B8%8B%E5%8D%884.08.40%283%29.png" alt="3"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>(Point3D)，vptr_Point3D</td>
<td>0</td>
</tr>
<tr>
<td>(Point2D)，Point3D::Point2D::x</td>
<td>8</td>
</tr>
<tr>
<td>Point3D::Point2D::y</td>
<td>12</td>
</tr>
<tr>
<td>Point3D::z</td>
<td>16</td>
</tr>
</tbody></table>
<p>可见，虚函数表指针是放置在class object的第一位的，其次才是继承而来的基类。</p>
<h3 id="virtual继承-1"><a href="#virtual继承-1" class="headerlink" title="virtual继承"></a>virtual继承</h3><p>&emsp;&emsp;情况与情况1的virtual继承类似。</p>
<h2 id="基类有虚函数，子类也有虚函数（不可能没有）"><a href="#基类有虚函数，子类也有虚函数（不可能没有）" class="headerlink" title="基类有虚函数，子类也有虚函数（不可能没有）"></a>基类有虚函数，子类也有虚函数（不可能没有）</h2><h3 id="无virtual继承-2"><a href="#无virtual继承-2" class="headerlink" title="无virtual继承"></a>无virtual继承</h3><p>&emsp;&emsp;将情况2的基类的<code>draw</code>函数也改写为virtual，其他不变。如果要实现多态，那么基类就需要额外声明一个virtual虚构函数。</p>
<ul>
<li>Point2D的内存布局如下：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-01%20%E4%B8%8B%E5%8D%884.22.46%284%29.png" alt="4"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>(Point2D)，vptr_Point2D</td>
<td>0</td>
</tr>
<tr>
<td>Point2D::x</td>
<td>8</td>
</tr>
<tr>
<td>Point2D::y</td>
<td>12</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;虚函数表指针依然是放置在第一位的。</p>
<ul>
<li>Point3D的内存布局如下：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-01%20%E4%B8%8B%E5%8D%884.33.37%285%29.png" alt="5"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>(Point2D，Point3D)，vptr_Point3D</td>
<td>0</td>
</tr>
<tr>
<td>Point3D::Point2D::x</td>
<td>8</td>
</tr>
<tr>
<td>Point3D::Point2D::y</td>
<td>12</td>
</tr>
<tr>
<td>Point3D::z</td>
<td>16</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;Point3D继承了Point2D的虚函数表，并且覆写了<code>virtual draw</code>函数的地址（将<code>Point2D::draw</code>覆写为<code>Point3D::draw</code>）。</p>
<h3 id="virtual继承-2"><a href="#virtual继承-2" class="headerlink" title="virtual继承"></a>virtual继承</h3><p>&emsp;&emsp;Point2D布局不变。</p>
<ul>
<li>Point3D的内存布局如下：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-01%20%E4%B8%8B%E5%8D%8811.29.08%287%29.png" alt="7"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Point3D），vptr_Point3D</td>
<td>0</td>
</tr>
<tr>
<td>Point3D::z</td>
<td>8</td>
</tr>
<tr>
<td>Padding（字节补齐）</td>
<td>12</td>
</tr>
<tr>
<td>（Point2D），vptr_Point2D</td>
<td>16</td>
</tr>
<tr>
<td>Point2D::x</td>
<td>24</td>
</tr>
<tr>
<td>Point2D::y</td>
<td>28</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;可以看到在virtual继承下，子类拥有其本身以及基类的虚函数表指针，一共2个。此外，virtual base class Point2D subobject是置于尾部的，Point3D部分也是需要进行字节对齐的，填补的空间并不会用来留给virtual base class Point2D subobject。</p>
<h2 id="基类与子类都为空"><a href="#基类与子类都为空" class="headerlink" title="基类与子类都为空"></a>基类与子类都为空</h2><h3 id="无virtual继承-3"><a href="#无virtual继承-3" class="headerlink" title="无virtual继承"></a>无virtual继承</h3><p>&emsp;&emsp;考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;; <span class="comment">// size: 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;&#125;; <span class="comment">// size: 1</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编译后，Base与Derived的class object大小均为1。具体原因见“<a href="/2021/10/25/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/" title="多重继承中数据成员的布局">多重继承中数据成员的布局</a>”。</p>
<h3 id="virtual继承-3"><a href="#virtual继承-3" class="headerlink" title="virtual继承"></a>virtual继承</h3><p>&emsp;&emsp;考虑如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span>&#125;; <span class="comment">// size: 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;&#125;; <span class="comment">// size: 8</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Base class object大小依然为1，但是Derived class object大小却变为了8，其内部有一个vptr指向虚函数表，64位机器下的大小正好为8bytes。那么这里virtual base class Base subobject的1byte去哪里了呢？要视编译器的行为而定了，有的编译器也会将virtual base class Base subobject的1byte大小反映在Derived class object身上，因此Derived object大小就不是8bytes而是16bytes了，而有的编译器会对这种情况进行特殊处理，它会将virtual base class置于Derived class object的开头处，那么Derived class object也就不需要额外承担这一个字节的空间了，最后的结果就是8bytes。</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>原码、补码、反码详解</title>
    <url>/2021/03/12/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<h1 id="生活中存在的数学原理"><a href="#生活中存在的数学原理" class="headerlink" title="生活中存在的数学原理"></a>生活中存在的数学原理</h1><p>&emsp;&emsp;如果只给你一个计算机，但只能运算加法，而不能运算减法，那你该咋办？</p>
<p>&emsp;&emsp;其实原理很简单，日常生活中我们其实一直都有用到，这就是时钟。</p>
<p>&emsp;&emsp;假设现在是上午7点，那么6小时前是多少呢？没错！我们理所当然的认为是1点。那么6小时又是多少呢？7 + 6 - 12，还是1点！你坚定的说，没错！</p>
<p>&emsp;&emsp;那么，为什么第二次你减去了12呢？</p>
<p>&emsp;&emsp;因为时钟总共也就只有12个数啊，那这就是数学中的取模运算了！</p>
<a id="more"></a>

<h1 id="由浅入深"><a href="#由浅入深" class="headerlink" title="由浅入深"></a>由浅入深</h1><p>&emsp;&emsp;回到上述问题，现在是上午7点，那么5小时后呢？12点吗？为了统一操作，这里我们将所有的操作都取模，那么7 + 5 - 12 = 0。这样我们的数的范围是0到11了！</p>
<p>&emsp;&emsp;假如以7点为起点，5小时前与多少小时后是一样的呢？（7 - 5）mode12 = 2，（7 + ？）mode12 = 2，可以算出是7。也就是说无论是-5还是+7结果都是一样的，那么可以说-5与7在这种情景下是等价的。下面来做一个表格：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>-1</th>
<th>-2</th>
<th>-3</th>
<th>-4</th>
<th>-5</th>
<th>-6</th>
<th>-7</th>
<th>-8</th>
<th>-9</th>
<th>-10</th>
<th>-11</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>11</td>
<td>10</td>
<td>9</td>
<td>8</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这样我们就把它们的对应关系给列出来了，负数全部可以用正数来等价表示。比如-1可以用11来表示，-11可以用1来表示。</p>
<p>&emsp;&emsp;很好，但是现在我们会有一个问题。根据上述表格的规律，7 - 5 = 7 + 7 = 14 mod 12 = 2，没错，结果等于2。再来看7 - 9 = 7 + 3 = 10，这里我们潜意识会将其等价转换为-2，结果就是-2了。但是为什么上一个例子的结果2却没有进行转换呢，这是因为我们知道最后的结果是正数还是负数。这就是问题所在了，计算机在计算时可不会知道它是正数还是负数，所以这样肯定不行，那么到底该如何处理呢？</p>
<p>&emsp;&emsp;其实很简单，只要给定我们某个标记，我们就可以立刻知道它是正数还是负数。由于计算机的数字由二进制来表示，因此只要令其某一部分数字来表示负数就行了，这就是我们所说的“标记”。假如给定4位数字二进制（最多存储16个数字）表示，看下表：</p>
<table>
<thead>
<tr>
<th>00 00</th>
<th>00 01</th>
<th>00 10</th>
<th>00 11</th>
<th>01 00</th>
<th>01 01</th>
<th>01 10</th>
<th>01 11</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;那么该如何表示出它们的负数形式呢，答案就是将它们的最高位置于1，也就是说，把最高位为1的数表示为负数，最高位为0的数来表示正数。</p>
<table>
<thead>
<tr>
<th>10 00</th>
<th>10 01</th>
<th>10 10</th>
<th>10 11</th>
<th>11 00</th>
<th>11 01</th>
<th>11 10</th>
<th>11 11</th>
</tr>
</thead>
<tbody><tr>
<td>-8</td>
<td>-7</td>
<td>-6</td>
<td>-5</td>
<td>-4</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;这样一来，给我一个数，我就可以知道它是正数还是负数了，比如10，二进制是1010，开头是1，那它一定代表的是一个负数。但是它是负多少呢？因为现在是模16（4位），所以结果就是16 - 10 = 6，也就是-6了。</p>
<p>&emsp;&emsp;现在让我们以二进制的方式来看下，16 - 10 = 1 00 00 - 10 10 = （ 1 + 1111） - 1010 = （1111 - 1010） + 1 = 0101 + 1 = 0110 = 6，你可能要说这里出现了减法！！！不不不，这一步不是减法，而是进行的按位取反操作。</p>
<blockquote>
<p>总结：给定一个二进制数（前提是该数据类型为signed），如果二进制最高位是0，那么这个数就是正数；相反，如果二进制最高位是1，则该数代表负数，其绝对值可以由该二进制数按位取反再加一得来。并且如果给定的数是一个负数时，亦可以用按位取反再加一来对其绝对值进行运算来得到它的二进制数。</p>
</blockquote>
<p>&emsp;&emsp;这样，我们就把加减法完美的统一起来了。没错，这其实就是所谓的补码，计算机中所有的整数都是用补码存储的，这样计算机就只需要进行加法运算就足够。举个例子，1的补码是1不变，也就是0001；-1的补码，将1的二进制按位取反再加1，也就是0001按位取反变为1110，再加上1，最后就变为1111，1111代表多少呢？首先肯定代表负数，然后将其按位取反再加1，就是0001，所以结果就是-1了。</p>
<p>&emsp;&emsp;这样我们就明白了，只要学会将一个数转换为补码进行运算，然后补码再还原就够了，而且更棒的是，两个转换的方式还是一样的！按位取反，再加1，十分的清晰明了。</p>
<h1 id="计算机中的正负数？"><a href="#计算机中的正负数？" class="headerlink" title="计算机中的正负数？"></a>计算机中的正负数？</h1><p>&emsp;&emsp;现在让我们回归到计算机里，我们知道一般情况下int是4字节，也就是32位。一样的道理，对于signed int，我们将最高位为0的数表示为正数，最高位为1的数表示为负数。所以最大的正数是0111 1111 … 1111 1111，这个数代表多少呢？为了方便计算，先将其加1，变为1000 0000 … 0000 0000，也就是$2^{31}$，然后再减去1就行了。</p>
<p>&emsp;&emsp;那么绝对值最大的负数呢？因为1开头代表的是负数，其它部分当然是越小越好，所以就是1000 0000 … 0000 0000，直接套用公式，按位取反，再加1，结果就是1000 0000 … 0000 0000，咦？怎么又变回来了？之前算出来的最大正数是$2^{31}$ - 1，怎么负数比正数还多一个，不应该是对称的吗？</p>
<p>&emsp;&emsp;请仔细再想想，0开头的数和1开头的数，个数是不是一样的，但是0开头的数包括了0，所以正数就少了一个呀。顺便请再想想，最小的负数是$-2147483648$（$-2^{31}$），那$-2147483648 - 1$是多少呢？</p>
<p>&emsp;&emsp;如果你的答案是$-2147483649$，在上述情景下，显然，你不适合从事程序员这个职业。现在让我们来算一遍，$-2147483648$的补码是1000 0000 … 0000 0000，-1的补码是1按位取反再加1，就是1111 1111 … 1111 1111，然后把这两个数加起来就是0111 1111 … 1111 1111，这不正是那个最大的正数吗！！所以$-2147483648 - 1$的结果就是$2147483647$。</p>
<p>&emsp;&emsp;下面的表格也许会对你有所帮助：</p>
<table>
<thead>
<tr>
<th>00 00</th>
<th>00 01</th>
<th>00 10</th>
<th>00 11</th>
<th>01 00</th>
<th>01 01</th>
<th>01 10</th>
<th>01 11</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>10 00</td>
<td>10 01</td>
<td>10 10</td>
<td>10 11</td>
<td>11 00</td>
<td>11 01</td>
<td>11 10</td>
<td>11 11</td>
</tr>
<tr>
<td>-8</td>
<td>-7</td>
<td>-6</td>
<td>-5</td>
<td>-4</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;看上述表格，只有4位，所以最大的数是7，最小的数是-8。表格中7之后的数是-8，所以当-8减1，也就是-8前面的那个数，7。其实这个表格很好理解，将其转化为圆盘，就像时钟一样。</p>
<blockquote>
<p>总结：其实我们利用了寄存器的位数是有限制的特性——它到达最大的数以后会自动置零，相当于完成了取模操作，就像时钟一样，到了11点，之后就又会从零开始。然后我们再定义用哪些数代表正数，哪些数代表负数，从而完成了加减法的统一。并且给定一个数如果知道它的补码表示，也可以知道它代表几。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>在operator=中处理“自我赋值”</title>
    <url>/2020/07/25/%E5%9C%A8operator=%E4%B8%AD%E5%A4%84%E7%90%86%E2%80%9C%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC%E2%80%9D/</url>
    <content><![CDATA[<hr>
<h1 id="在operator-中处理“自我赋值”"><a href="#在operator-中处理“自我赋值”" class="headerlink" title="在operator=中处理“自我赋值”"></a>在operator=中处理“自我赋值”</h1><p>&emsp;&emsp;“自我赋值”发生在对象被赋值给自己时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;  <span class="comment">//赋值给自己</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这看起来有点愚蠢，但它合法，所以不要认定客户绝不会那么做。此外赋值动作并不总是那么可被一眼识别出来，例如：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a[i] = a[j];  <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果i和j有相同的值，这便是个自我赋值。再看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*px = *py;  <span class="comment">//潜在的自我赋值</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果px和py恰巧指向同一个东西，这也是自我赋值。这些并不明显的自我赋值，是“别名”带来的结果：所谓“别名”就是“有一个以上的方法指涉某对象”。一般而言如果某段代码操作pointer或reference而它们被用来“指向多个相同类型的对象”，就需要考虑这些对象是否为同一个。实际上两个对象只要来自同一个继承体系，它们甚至不需声明为相同类型就可能造成“别名”，因为一个base class的reference或pointer可以指向一个derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">const</span> Base&amp; rb, Derived* pd)</span></span>;  <span class="comment">//rb和*pd有可能其实是同一对象</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果我们尝试自行管理资源（如果我们打算写一个用于资源管理的class就得这样做），可能会在停止使用资源之前就意外释放了它。假设我们建立一个class用来保存一个指针指向动态分配的位图（bitmap）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;  <span class="comment">//指针，指向一个从heap分配而得的对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面是operator=实现代码，表面上看起来合理，但自我赋值出现时并不安全（它也不具备异常安全性）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp;</span><br><span class="line">Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//一份不安全的operator=实现版本</span></span><br><span class="line">    <span class="keyword">delete</span> pb;                          <span class="comment">//停止使用当前的Bitmap</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);           <span class="comment">//使用rhs的bitmap的副本</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的自我赋值问题是，operator=函数内的*this（赋值的目的端）和rhs有可能是同一个对象。果真如此delete就不只是销毁当前对象的bitmap，它也销毁rhs的bitmap。在函数末尾，Widget——它原本不该被自我赋值动作改变的——发现自己持有一个指针指向一个已被删除的对象！</p>
<p>&emsp;&emsp;欲阻止这种错误，传统做法是藉由operator=最前面的一个“证同测试”达到“自我赋值”的检测目的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//证同测试：如果是自我赋值，就不做任何事</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样做行得通。前一版本的operator=不仅不具备“自我赋值安全性”，也不具备“异常安全性”，这个新版本仍然存在异常方面的麻烦。更明确地说，如果“new Bitmap”导致异常，Widget最终会持有一个指针指向一块被删除的Bitmap。这样的指针有害。我们无法安全地删除它们，甚至无法安全地读取它们。</p>
<p>&emsp;&emsp;令人高兴的是，让operator=具备“异常安全性”往往自动获得“自我赋值安全”的回报。因此越来越多的人对“自我赋值”的处理态度是倾向于不去管它，把焦点放在实现“异常安全性”上。例如以下代码，我们只需注意在复制pb所指东西之前别删除pb：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Bitmap* pOrig = pb;        <span class="comment">//记住原先的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);  <span class="comment">//令pb指向*pb的一个副本</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;              <span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，如果“new Bitmap”抛出异常，pb（及其栖身的那个Widget）保持原状。即使没有证同测试，这段代码还是能够处理自我赋值，因为我们对原bitmap做了一份复件、删除原bitmap、然后指向新制造的那个复件。它或许不是处理“自我赋值”的最高效办法，但它行得通。</p>
<p>&emsp;&emsp;如果你很关心效率，可以把“证同测试”再次放回函数起始处。然而这样做，我们得先问问自己，“自我赋值”的发生概率有多高？因为这项测试也需要成本。它会使代码变大一些并导入一个新的控制流分支，而两者都会降低执行速度。Prefetching、caching和pipelining等指令的效率都会因此降低。</p>
<p>&emsp;&emsp;在operator=函数内手工排列语句（确保代码不但“异常安全”而且“自我赋值安全“）的一个替代方案是，使用所谓的copy and swap技术。这个技术和“异常安全性”有密切关系。然而由于它是一个常见而够好的operator=撰写办法，所以值得看看其实现手法像什么样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; rhs)</span></span>;  <span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;</span><br><span class="line">    Widget temp(rhs);        <span class="comment">//为rhs数据制作一份复件</span></span><br><span class="line">    swap(temp);              <span class="comment">//将*this数据和上述复件的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以下代码是上述代码的变奏曲：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs) &#123;  <span class="comment">//rhs是被传对象的一份复件</span></span><br><span class="line">    swap(rhs);                           <span class="comment">//将*this的数据和复件的数据互换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我个人比较担忧这个做法，它为了“巧妙性”而牺牲了“清晰性”。然而将“copying动作”从函数本体内移至“函数参数构造阶段”却可令编译器有时生成更高效的代码。</p>
<blockquote>
<p>确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</p>
<p>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>在资源管理类中小心copying行为</title>
    <url>/2020/07/28/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83copying%E8%A1%8C%E4%B8%BA/</url>
    <content><![CDATA[<hr>
<h1 id="在资源管理类中小心copying行为"><a href="#在资源管理类中小心copying行为" class="headerlink" title="在资源管理类中小心copying行为"></a>在资源管理类中小心copying行为</h1><p>&emsp;&emsp;并非所有资源都是heap-based，对这种资源而言，像shared_ptr这样的智能指针往往不适合作为资源管理者。既然如此，有可能偶尔我们会发现，我们需要建立自己的资源管理类。</p>
<p>&emsp;&emsp;例如，假设我们使用C API函数处理类型为Mutex的互斥器对象，共有lock和unlock两函数可用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span></span>;  <span class="comment">//锁定pm所指的互斥器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex* pm)</span></span>;  <span class="comment">//将互斥器解除锁定</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为确保绝不会忘记将一个被锁住的Mutex解锁，我们可能会希望建立一个class用来管理机锁。这样的class的基本结构由RAII（Resource Acquisition Is Initialization）“资源取得时机便是初始化时机”守则支配，也就是“资源在构造期间获得，在析构期间释放”：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex* pm)</span>: <span class="title">mutexPtr</span><span class="params">(pm)</span> </span>&#123;  <span class="comment">//获得资源</span></span><br><span class="line">       lock(mutexPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Lock() &#123; unlock(mutexPtr); &#125;  <span class="comment">//释放资源</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex* mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;客户对Lock的用法符合RAII方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mutex m;      <span class="comment">//定义我们需要的互斥器</span></span><br><span class="line">...</span><br><span class="line">&#123;             <span class="comment">//建立一个区块用来定义critiacl section</span></span><br><span class="line"><span class="function">Lock <span class="title">m1</span><span class="params">(&amp;m)</span></span>;  <span class="comment">//锁定互斥器</span></span><br><span class="line">...           <span class="comment">//执行critical section内的操作</span></span><br><span class="line">&#125;             <span class="comment">//在区块最末尾，自动解除互斥器锁定</span></span><br></pre></td></tr></table></figure>

<p>&emsp;这很好，但如果Lock对象被复制，会发生什么事？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;   <span class="comment">//锁定m</span></span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>;  <span class="comment">//将ml1复制到ml2身上，这会发生什么事？</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是某个一般化问题的特定例子。那个一般化问题是每一个RAII class作者一定需要面对的：“当一个RAII对象被复制，会发生什么事？”大多数时候我们会选择以下两种可能：</p>
<ul>
<li><p><strong>禁止复制</strong>。许多时候允许RAII对象被复制并不合理。对一个像Lock这样的class这是有可能的，因为很少能够合理拥有“同步化基础器物”的副本。如果复制动作对RAII class并不合理，我们便应该禁止它。将copyin操作声明为private。对Lock而言看起来是这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>:</span> <span class="keyword">private</span> Uncopyable &#123;  <span class="comment">//禁止复制</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对底层资源祭出“引用计数法”</strong>。有时候我们希望保有资源，直到它对最后一个使用者（某对象）被销毁。这种情况下复制RAII对象时，应该将资源的“被引用数”递增。shared_ptr便是如此。</p>
<p>&emsp;&emsp;通常只要内含一个shared_ptr成员变量，RAII class便可实现出上述行为。它可以改变mutexPtr的类型，将它从Mutex*改为shared_ptr&lt;Mutex&gt;。然而很不幸shared_ptr的缺省行为是“当引用次数为0时删除其所指物”，这不是我们想要的行为。当我们用上一个Mutex，我们想要做的释放动作是解除锁定而非删除。</p>
<p>&emsp;&emsp;幸运的是shared_ptr允许指定所谓的“删除器”，这是一个函数或函数对象，当引用次数为0时便可被调用。删除器对shared_ptr构造函数而言是可有可无的第二参数，所以代码看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock</span><span class="params">(Mutex* pm)</span>: <span class="title">mutexPtr</span><span class="params">(pm, unlock)</span> </span>&#123;</span><br><span class="line">        lock(mutexPtr.<span class="built_in">get</span>());</span><br><span class="line">    &#125;  <span class="comment">//以某个Mutex初始化shared_ptr并以unlock函数为删除器</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;  <span class="comment">//使用shared_ptr替换raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本例的Lock class不再声明析构函数。因为没有必要。class析构函数（无论是编译器生成的，或用户自定的）会自动调用其non-static成员变量（本例为mutexPtr）的析构函数。而mutexPtr的析构函数会在互斥器的引用次数为0时自动调用shared_ptr的删除器（本例为unlock）。</p>
</li>
<li><p><strong>复制底部数据</strong>。有时候，只要我们喜欢，可以针对一份资源拥有其任意数量的副本。而我们需要“资源管理类”的唯一理由是，当我们不再需要某个复件时确保它被释放。在此情况下复制资源管理对象，应该同时也复制其所包含的资源。也就是说，复制资源管理对象时，进行的是“深度拷贝”。</p>
<p>&emsp;&emsp;某些标准字符串类型是由“指向heap内存”的指针构成。这种字符串对象内含一个指针指向一块heap内存。当这样一个字符串对象被复制，不论指针或其所指内存都会被制作出一个复件，这样的字符串展现出深度复制行为。</p>
</li>
<li><p><strong>转移底部资源的拥有权</strong>。某些罕见场合下我们可能希望确保永远只有一个RAII对象指向一个未加工资源，即使RAII对象被复制依然如此。此时资源的拥有权会从被复制物转移到目标物。</p>
</li>
</ul>
<blockquote>
<p>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</p>
<p>普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法。不过其他行为也都可能被实现。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>在资源管理类中提供对原始资源的访问</title>
    <url>/2020/07/29/%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<hr>
<h1 id="在资源管理类中提供对原始资源的访问"><a href="#在资源管理类中提供对原始资源的访问" class="headerlink" title="在资源管理类中提供对原始资源的访问"></a>在资源管理类中提供对原始资源的访问</h1><p>&emsp;&emsp;资源管理类很棒。它们是你对抗资源泄漏的堡垒。排除此等泄漏是良好设计系统的根本性质。在一个完美世界中我们将依赖这样的class来处理和资源之间的所有互动，而不是玷污双手直接处理原始资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//使用智能指针保存factory函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Investment* pi)</span></span>;                    <span class="comment">//返回投资天数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> days = daysHeld(pInv);                             <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;dayHelds需要的是Investment*指针，我们传给它的却是个类型为std::shared_ptr&lt;Investment&gt;的对象。</p>
<a id="more"></a>

<p>&emsp;&emsp;这时候我们需要一个函数可将RAII class对象转换为其所内含的原始资源。有两个做法可以达成目标：显式转换和隐式转换。</p>
<p>&emsp;&emsp;shared_ptr提供一个get成员函数，用来执行显式转换，也就是它会返回智能指针内部的原始指针（的复件）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> days = daysHeld(pInv.<span class="built_in">get</span>());  <span class="comment">//将pInv内的原始指针传给daysHeld</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;shared_ptr重载了指针取值操作符（operator-&gt;和operator*），它们允许隐式转换至底部原始指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTaxFree</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;                       <span class="comment">//factory函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pi</span><span class="params">(createInvestment())</span></span>;  <span class="comment">//令指针指针管理一笔资源</span></span><br><span class="line"><span class="keyword">bool</span> taxable1 = !(pi-&gt;isTaxFree());                  <span class="comment">//经由operator-&gt;访问资源</span></span><br><span class="line"><span class="keyword">bool</span> taxable2 = !((*pi).isTaxFree());                <span class="comment">//经由operator*访问资源</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;再考虑下面这个用语字体的RAII class（对C API而言字体是一种原生数据结构）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FontHandle <span class="title">getFont</span><span class="params">()</span></span>;  <span class="comment">//这是个C API，为求简化省略参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseFont</span><span class="params">(FontHandle fh)</span></span>;  <span class="comment">//来自同一组C API</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Font</span><span class="params">(FontHandle fh)</span>: <span class="title">f</span><span class="params">(fh)</span> </span>&#123;&#125;</span><br><span class="line">    ~Font() &#123; releaseFont(f); &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FontHandle f;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;假设有大量与字体相关的C API，它们处理的是FontHandle，那么“将Font对象转换为FontHandle”会是一种很频繁的需求。Font class可为此提供一个显式转换函数，像get那样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FontHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;  <span class="comment">//显式转换函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不幸的是这使得客户每当想要使用API时就必须调用get：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeFontSize</span><span class="params">(FontHandle f, <span class="keyword">int</span> newSize)</span></span>;  <span class="comment">//C API</span></span><br><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="keyword">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line">changeFontSize(f.<span class="built_in">get</span>(), newFontSize);  <span class="comment">//显式地将Font转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;某些程序员可能会认为，如此这般地到处要求显式转换，足以使人们倒尽胃口，不再愿意使用这个class，从而增加了泄漏字体的可能性，而Font class的主要设计目的就是为了防止资源（字体）泄漏。</p>
<p>&emsp;&emsp;另一个办法是令Font提供隐式转换函数，转型为FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">FontHandle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">//隐式转换函数</span></span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//另外一种构造转换函数，与隐式转换函数相反，</span></span><br><span class="line">    <span class="comment">//是将其他类型转换为本类型，其也是构造函数的一种。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这使得客户调用C API时比较轻松且自然：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f</span><span class="params">(getFont())</span></span>;</span><br><span class="line"><span class="keyword">int</span> newFontSize;</span><br><span class="line">...</span><br><span class="line">changeFontSize(f, newFontSize);  <span class="comment">//将Font隐式转换为FontHandle</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是这个隐式转换会增加错误发生机会。例如客户可能会在需要Font时意外创建一个FontHandle：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Font <span class="title">f1</span><span class="params">(getFont())</span></span>;</span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1;</span><br><span class="line"><span class="comment">//原意是要拷贝一个Font对象，</span></span><br><span class="line"><span class="comment">//却反而将f1隐式转换为其底部的FontHandle</span></span><br><span class="line"><span class="comment">//然后才复制它。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;是否该提供一个显式转换函数（例如get成员函数）将RAII class转换为其底部资源，或是应该提供隐式转换，答案主要取决于RAII class被设计执行的特性工作，以及它被使用的情况。</p>
<p>&emsp;&emsp;RAII class并不是为了封装某物而存在的；它们的存在是为了确保一个特殊行为——资源释放——会发生。此外也有某些RAII class结合十分松散的底层资源封装，借以获得真正的封装实现。例如shared_ptr将它的所有引用计数机构封装了起来，但还是让外界很容易访问其所内含的原始指针。就像多数设计良好的class一样，它隐藏了客户不需要看的部分，但备妥客户需要的所有东西。</p>
<blockquote>
<p>API往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理的资源”的办法。</p>
<p>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>复制对象时勿忘其每一个成分</title>
    <url>/2020/07/26/%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%8B%BF%E5%BF%98%E5%85%B6%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%88%90%E5%88%86/</url>
    <content><![CDATA[<hr>
<h1 id="复制对象时勿忘其每一个成分"><a href="#复制对象时勿忘其每一个成分" class="headerlink" title="复制对象时勿忘其每一个成分"></a>复制对象时勿忘其每一个成分</h1><p>&emsp;&emsp;设计良好的面向对象系统会将对象的内部封装起来，只留两个函数负责对象拷贝，这便是copy构造函数和copy assignment操作符，称它们为copying函数。</p>
<p>&emsp;&emsp;如果我们声明自己的copying函数，意思就是告诉编译器我们并不喜欢缺省实现中的某些行为，编译器仿佛被冒犯似得，会以一种奇怪的方式回敬：当我们的实现代码几乎必然出错时却不告诉我们。</p>
<p>&emsp;&emsp;考虑一个class用来表现顾客，其中手工写出copying函数，使得外界对它们的调用会被志记（logged）下来：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logCall</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; funcName)</span></span>;  <span class="comment">//制造一个log entry</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; rhs): name(rhs.name) &#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"Customer copy assignment operator"</span>);</span><br><span class="line">    name = rhs.name;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的每一件事情都看起来很好，而实际上每件事情也的确都好，直到另一个成员变量加入战局：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span> ... &#125;;  <span class="comment">//日期</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...              <span class="comment">//同前</span></span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Date lastTrasaction;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这时候现有的copying函数执行的是局部拷贝，并没有复制新添加的lastTransaction。大多数编译器对此不会发出任何怨言——即使在最高警告级别中。这是编译器对“我们自己写出copying函数”的报复行为。结论很明显：如果我们为class添加一个成员变量，我们必须同时修改copying函数。如果我们忘记，编译器不太可能提醒我们。</p>
<p>&emsp;&emsp;一旦发生继承，可能会出现一个隐患：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityCustomer</span>:</span> <span class="keyword">public</span> Customer &#123;  <span class="comment">//一个derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    PriorityCustomer（<span class="keyword">const</span> PriorityCustomer&amp; rhs）;</span><br><span class="line">    PriorityCustomer&amp; <span class="keyword">operator</span>=（<span class="keyword">const</span> PriorityCustomer&amp; rhs）;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line">PriorityCustomer::PriorityCustomer（<span class="keyword">const</span> PriorityCustomer&amp; rhs）</span><br><span class="line">: priority(rhs.priority) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy assignment operator"</span>);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来PriorityCustomer的copying函数好像复制了其内的每一样东西，但是它所继承的Customer成员变量却并未被复制。PriorityCustomer的copy构造函数并没有指定实参传给其base class构造函数（也就是说它在它的成员初值列中没有提到Customer），因此PriorityCustomer对象的Customer成分会被不带实参的Customer构造函数（即default构造函数）初始化。default构造函数将针对name和lastTransaction执行缺省的初始化动作。</p>
<p>&emsp;&emsp;以上情况在PriorityCustomer的copy assignment操作符身上只有轻微不同。它不曾试图修改其base class的成员变量，所以那些成员变量保持不变。</p>
<p>&emsp;&emsp;任何时候只要我们承担起“为derived class撰写copying函数”的重任，必须很小心地也复制其base class成分。那些成分往往是private，所以无法直接访问它们，我们应该让derived class的copying函数调用相应的base class函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PriorityCustomer::PriorityCustomer(<span class="keyword">const</span> PriorityCustomer&amp; rhs)</span><br><span class="line">: Customer(rhs), priority(rhs.priority) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line">PriorityCustomer&amp;</span><br><span class="line">PriorityCustomer::<span class="keyword">operator</span>=(<span class="keyword">const</span> PriorityCustomer&amp; rhs) &#123;</span><br><span class="line">    logCall(<span class="string">"PriorityCustomer copy assignment operator"</span>);</span><br><span class="line">    Customer::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    priority = rhs.priority;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当我们编写一个copying函数，请确保（1）复制所有local成员变量，（2）调用所有base class内的适当copying函数。</p>
<p>&emsp;&emsp;如果你发现你的copy构造函数和copy assignment操作符有着相近的代码，消除重复代码的做法是，建立一个新成员函数给两者调用。这样的函数往往是private而且常被命名为init。这个策略可以安全地消除copy构造函数和copy assignment操作符之间的代码重复。</p>
<blockquote>
<p>Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。</p>
<p>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>多重继承中的数据成员的布局</title>
    <url>/2021/10/25/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<hr>
<h1 id="多重继承中的数据成员的布局"><a href="#多重继承中的数据成员的布局" class="headerlink" title="多重继承中的数据成员的布局"></a>多重继承中的数据成员的布局</h1><h2 id="包含empty-virtual-base-class的多重继承的布局"><a href="#包含empty-virtual-base-class的多重继承的布局" class="headerlink" title="包含empty virtual base class的多重继承的布局"></a>包含empty virtual base class的多重继承的布局</h2><p>&emsp;&emsp;考虑以下类的继承关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;上述X，Y，Z和A中没有任何一个class拥有明显的数据，仅仅表示继承关系。乍一看，似乎每一个class的大小都应该是0。错，即使是class X的大小也不为0：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> X : <span class="number">1</span></span><br><span class="line"><span class="keyword">sizeof</span> Y : <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span> Z : <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span> A : <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>以上为64位UNIX的GCC编译器的编译结果。</p>
<p>&emsp;&emsp;一个空的class如class X，事实上，它并不是空的。它有一个隐藏的1byte大小，这是被编译器安插进去的一个char。这使得这一个class的多个objects得以在内存中拥有独一无二的地址。</p>
<p>&emsp;&emsp;那么为什么Y和Z的大小却是8呢？其实这个大小和机器（32位或是64位）有关，也和编译器有关。事实上Y，Z和A的大小受到三个因素的影响：</p>
<ol>
<li><strong>语言本身所造成的额外负担</strong>，当语言支持virtual base classes时，就会导致一些额外负担。在derived class中，这个额外负担反映在指针身上，它或是指向virtual base class subobject，或者指向一个相关表格；表格中存放的不是virtual base class subobject的地址，就是其偏移位置（offset）。32位系统中的指针是4bytes，而64位系统中的指针是8bytes。</li>
<li><strong>编译器对于特殊情况所提供的优化处理</strong>，virtual base class X subobject的1bytes大小也出现在class Y 和 Z 身上。传统上它被放在derived class的固定部分的尾端。某些编译器会对empty virtual class提供特殊支持，例如在我的UNIX上就提供了这种特殊优化。</li>
<li><strong>Alignment的限制</strong>，class Y 和 Z 的大小截至目前为8字节（8bytes的alignment）。它们的有效对齐值为8bytes，因此无需填补额外字节。有关字节对齐见“<a href="/2021/04/17/C%EF%BC%8FC++%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/" title="C／C++中的字节对齐">C／C++中的字节对齐</a>”。</li>
</ol>
<p>&emsp;&emsp;Empty virtual base class已经成为C++OO设计的一个特有术语了。它提供一个virtual interface，没有定义任何数据。某些较新的编译器对此提供了特殊处理（例如GCC编译器与VC编译器）。在这个策略下，一个empty virtual base class被视为derived class object最开头的一部分，也就是说它并没有花费任何额外空间。这就节省了上述第2点的1byte。只剩下第1点所说的额外负担。在此模型下，Y和Z的大小都是8。</p>
<p>&emsp;&emsp;那么class A的大小是什么呢？记住，一个virtual base class subobject只会在derived class中存在一份实例，不管它在class继承体系中出现多少次！很明显，class A的大小某种程度上必须视你所使用的编译器与机器而定：</p>
<ol>
<li><p>32位机器，没有特殊处理empty virtual base class的编译器：</p>
<ul>
<li>被大家共享的唯一一个class X实例，大小为1byte。</li>
<li>Base class Y的大小，减去“virtual base class X而配置”的大小（见上述第2点），结果是4bytes，Base class Z同理也是4bytes。加起来就是8bytes。</li>
<li>class A自己的大小：0bytes。</li>
<li>class A的alignment数量（如果有的话），前述3项总和，也就是调整对齐前的大小为9bytes。class A必须调整至4bytes边界，所以需要填补3bytes。结果就是12bytes。</li>
</ul>
</li>
<li><p>64位机器，没有特殊处理empty virtual base class的编译器：</p>
<ul>
<li>被大家共享的唯一一个class X实例，大小为1byte。</li>
<li>Base class Y的大小，减去“virtual base class X而配置”的大小（见上述第2点），结果是8bytes，Base class Z同理也是8bytes。加起来就是16bytes。</li>
<li>class A自己的大小：0byte。</li>
<li>class A的alignment数量（如果有的话），前述3项总和，也就是调整对齐前的大小为17bytes。class A必须调整至8bytes边界，所以需要填补7bytes。结果就是24bytes。</li>
</ul>
</li>
<li><p>32位机器，有特殊处理empty virtual base class的编译器：</p>
<ul>
<li>前述class X实例的那个1byte将被拿掉。</li>
<li>Base class Y的大小是4bytes，同理Base class Z也是4bytes。</li>
<li>class A自己的大小：0byte。</li>
<li>class A的alignment数量（如果有的话），前述2项总和，也就是调整对齐前的大小为8bytes。不需要进行填补。结果就是8bytes。</li>
</ul>
</li>
<li><p>64位机器，有特殊处理empty virtual base class的编译器：</p>
<ul>
<li>前述class X实例等那个1byte将被拿掉。</li>
<li>Base class Y的大小是8bytes，同理Base class Z也是8bytes。</li>
<li>class A自己的大小：0byte。</li>
<li>class A的alignment数量（如果有的话），前述2项总和，也就是调整对齐前的大小为16bytes。不需要进行填补。结果就是16bytes。（也是我的机器上的运行结果）</li>
</ul>
</li>
</ol>
<p>&emsp;&emsp;注意，如果我们在virtual base class X中放置一个（以上）的data members，两种编译器（“有特殊处理”者和“没有特殊处理”者）就会产出完全相同的对象布局。因为它们的“特殊处理”只针对于empty virtual base class。</p>
<p>&emsp;&emsp;C++Standard并不强制规定如“base class subobjects的排列顺序”或“不同存取层级的data members的排列顺序”这种琐碎细节。它也不规定virtual functions或virtual base classes的实现细节。C++Standard只说：那些细节由各家厂商决定。本系列博客各处，都会区分“C++Standard”和“目前的C++实现标准”两种情况进行讨论。</p>
<h2 id="包含virtual-functions的virtual-base-class的多重继承的布局"><a href="#包含virtual-functions的virtual-base-class的多重继承的布局" class="headerlink" title="包含virtual functions的virtual base class的多重继承的布局"></a>包含virtual functions的virtual base class的多重继承的布局</h2><p>&emsp;&emsp;考虑以下类的继承关系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~X();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> X &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="keyword">public</span> Z &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>class X，Y，Z和A都各自有一个虚函数表指针（vptr），它们的位置可能因编译器不同而不同，C++Standard允许vptr被放在对象中的任何位置，但是在此例中，并无区别，因为这些class都没有任何data members。同一个类的不同实例共用同一份虚函数表，它们都通过各自的vptr指向该虚函数表（编译器在编译期就为我们创建好了）。在64位机器上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> X : <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span> Y : <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span> Z : <span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span> A : <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在多重继承下，一个derived class内含<code>n-1</code>个额外的virtual tables，<code>n</code>表示其上一层base classes的个数（因此，单一继承将不会有额外的virtual tables）。对于class Y，Z和A中的virtual tables分别有如下讨论：</p>
<ul>
<li><strong>class Y</strong>，它覆盖了class X的foo函数，因此，它的vptr指向的虚函数表，也仅仅是在class X的虚函数表的基础上，覆盖了foo函数的入口地址。</li>
<li><strong>class Z</strong>，它有自己的虚函数，它的vptr指向的虚函数表，是在class X的虚函数表的基础上，在尾部添加了Z的虚函数的指针。如果定义了多个自己的虚函数，将按照声明次序依次添加到虚表的尾部。</li>
<li><strong>class A</strong>，它有两个virtual tables被编译器产出：<ul>
<li>一个主要实例，与Y（最左端base class）共享。</li>
<li>一个次要实例，与Z（第二个base class）有关。</li>
</ul>
</li>
</ul>
<p>&emsp;&emsp;上述情况都是在X，Y，Z和A都有虚函数的情景下讨论的，那么如果class Y没有虚函数表，class Z有虚函数，class A的成员布局又是如何呢？这种情况下，class A的第一个虚函数表将与class Z的虚函数表共享。那么如果class Y和class Z都没有虚函数表，class A有虚函数呢？这种情况下，class A的第一个虚函数表将会是其自己的虚函数表。所以我们不难推断，谁有虚函数表，谁就放前面。</p>
<p>&emsp;&emsp;考虑以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point2D</span> &#123;</span>                                                                               </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line">    Point2D() &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point2D's             address: %p\n"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Point2D() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point2D::x's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;x));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point2D::y's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;y));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3D</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2D &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line">    Point3D() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D's             address: %p\n"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D::x's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;x));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D::y's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;y));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Point3D::z's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;z));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Point2D &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"> </span><br><span class="line">    Line() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Line's                address: %p\n"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Line::x's             address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;x));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Line::y's             address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;y));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Line::length's        address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;length));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cube</span> :</span> <span class="keyword">public</span> Point3D, <span class="keyword">public</span> Line &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> area;</span><br><span class="line"> </span><br><span class="line">    Cube() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cube's                address: %p\n"</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cube::x's             address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;x));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cube::y's             address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;y));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cube::z's             address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;z));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cube::length's        address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;length));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cube::area's          address: %p\n"</span>, &amp;(<span class="keyword">this</span>-&gt;area));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编译后各class object的内存布局如下：</p>
<ul>
<li>Point2D的内存布局：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-04%20%E4%B8%8B%E5%8D%8811.12.42%281%29.png" alt="1"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Point2D），vptr_Point2D</td>
<td>0</td>
</tr>
<tr>
<td>Point2D::x</td>
<td>8</td>
</tr>
<tr>
<td>Point2D::y</td>
<td>12</td>
</tr>
</tbody></table>
<ul>
<li>Point3D的内存布局：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-04%20%E4%B8%8B%E5%8D%8811.31.24%282%29.png" alt="2"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Point3D），vptr_Point3D</td>
<td>0</td>
</tr>
<tr>
<td>Point3D::z</td>
<td>8</td>
</tr>
<tr>
<td>Padding（字节补齐）</td>
<td>12</td>
</tr>
<tr>
<td>（Point2D），vptr_Point2D</td>
<td>16</td>
</tr>
<tr>
<td>Point3D::Point2D::x</td>
<td>24</td>
</tr>
<tr>
<td>Point3D::Point2D::y</td>
<td>28</td>
</tr>
</tbody></table>
<ul>
<li>Line的内存布局：</li>
</ul>
<p>&emsp;&emsp;其内存布局同Point3D。</p>
<ul>
<li>Cube的内存布局：</li>
</ul>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80/2021-11-04%20%E4%B8%8B%E5%8D%8811.37.28%283%29.png" alt="3"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Address(offset)</th>
</tr>
</thead>
<tbody><tr>
<td>（Cube，Cube::Point3D），vptr_Cube</td>
<td>0</td>
</tr>
<tr>
<td>Cube::Point3D::z</td>
<td>8</td>
</tr>
<tr>
<td>Padding（字节补齐）</td>
<td>12</td>
</tr>
<tr>
<td>（Cube::Line），vptr_Line</td>
<td>16</td>
</tr>
<tr>
<td>Cube::Line::length</td>
<td>24</td>
</tr>
<tr>
<td>Cube::area</td>
<td>28</td>
</tr>
<tr>
<td>（virtual::Point2D），vptr_Point2D</td>
<td>32</td>
</tr>
<tr>
<td>virtual::Point2D::x</td>
<td>40</td>
</tr>
<tr>
<td>Virtual::Point2D::y</td>
<td>44</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>学习处理模版化基类内的名称</title>
    <url>/2020/11/15/%E5%AD%A6%E4%B9%A0%E5%A4%84%E7%90%86%E6%A8%A1%E7%89%88%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%86%85%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<hr>
<h1 id="学习处理模版化基类内的名称"><a href="#学习处理模版化基类内的名称" class="headerlink" title="学习处理模版化基类内的名称"></a>学习处理模版化基类内的名称</h1><p>&emsp;&emsp;假设我们需要撰写一个程序，它能够传送信息到若干不同的公司去。信息要不译成密码，要不就是未经加工的文字。如果编译期间我们有足够信息来决定哪一个信息传至哪一家公司，就可以采用基于template的解法：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyA</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyB</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendCleartext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line">...                     <span class="comment">//针对其他公司设计的class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgInfo</span> &#123;</span> ... &#125;;  <span class="comment">//这个class用来保存信息，以备将来产生信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClear</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> msg;</span><br><span class="line">            <span class="comment">//在这里，根据info产生信息</span></span><br><span class="line">            Company c;</span><br><span class="line">            c.sendCleartext(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            ...  <span class="comment">//类似sendClear，唯一不同的是这里调用c.sendEncrypted</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个做法行得通。但假设我们有时候想要在每次送出信息时志记某些信息。derived class可轻易加上这样的生产力，那似乎是个合情合理的解法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将“传送前”的信息写至log</span></span><br><span class="line">            sendClear(info);  <span class="comment">//调用base class函数，这段代码无法通过编译。</span></span><br><span class="line">            <span class="comment">//将“传送后”的信息写至log</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意这个derived class的信息传送函数有一个不同的名称（sendClearMsg），与其base class内的名称（sendClear）不同。那是个好设计，因为它避免遮掩“继承而得的名称”，也避免重新定义一个继承而得的non-virtual函数。但上述代码无法通过编译，至少对严守规律的编译器而言。这样的编译器会抱怨sendClear不存在。我们的眼睛可以看到sendClear的确在base class内，编译器却看不到它们。为什么？</p>
<p>&emsp;&emsp;问题在于，当编译器遭遇class template LoggingMsgSender定义式时，并不知道它继承什么样的class。当然它继承的是MsgSender&lt;Company&gt;，但其中的Company是个template参数，不到后来（当LoggingMsgSender被具现化）无法确切知道它是什么，而如果不知道Company是什么，就无法知道class MsgSender&lt;Company&gt;看起来像什么——更明确地说是没办法知道它是个sendClear函数。</p>
<p>&emsp;&emsp;为了让问题更具现化，假设我们有个class CompanyZ坚持使用加密通讯：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyZ</span> &#123;</span>  <span class="comment">//这个class不提供sendClearText函数</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendEncrypted</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般性的MsgSender template对CompanyZ并不合适，因为那个template提供了一个sendClear函数（其中针对其类型参数Company调用了sendCleartext函数），而这对CompanyZ对象并不合理。欲矫正这个问题，我们可以针对CompanyZ产生一个MsgSender特化版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span> &lt;CompanyZ&gt; &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendSecret</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意class定义式最前头的“template &lt;&gt;”语法象征这既不是template也不是标准class，而是个特化版的MsgSender template，在template实参是CompanyZ时被使用。这是所谓的模版全特化：template MsgSender针对类型CompanyZ特化了，而且其特化是全面性的，也就是说一旦类型参数被定义为CompanyZ，再没有其他template参数可供变化。</p>
<p>&emsp;&emsp;现在，MsgSender针对CompanyZ进行了全特化，让我们再次考虑derived class LoggingMsgSender：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogginMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将“传送前”的信息写至log</span></span><br><span class="line">            sendClear(info);  <span class="comment">//如果Company == CompanyZ，这个函数不存在。</span></span><br><span class="line">            <span class="comment">//将“传送后”的信息写至log</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;正如注释所言，当base class被指定为MsgSender&lt;CompanyZ&gt;时这段代码不合法，因为那个class并未提供sendClear函数！那就是为什么C++拒绝这个调用的原因：它知道base class template有可能被特化，而那个特化版本不可能提供和一般性template相同的接口。因此它往往拒绝在templatized base class（模版化基类，本例的MsgSender&lt;Company&gt;）内寻找继承而来的名称（本例的SendClear）。就某种意义而言，当我们从Object Oriented C++跨进Template C++。继承就不像以前那般畅行无阻了。</p>
<p>&emsp;&emsp;为了重头来过，我们必须有某种办法令C++“不进入templatized base class观察”的行为失效。有三个办法，第一是在base class函数调用动作之前加上“this-&gt;”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogginMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//将“传送前”的信息写至log</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;sendClear(info);  <span class="comment">//成立，假设sendClear将被继承</span></span><br><span class="line">            <span class="comment">//将“传送后”的信息写至log</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第二是使用using声明式。“”描述using声明式如何将“被遮掩的base class名称”带入一个derived class作用域内。我们可以这样写下sendClearMsg：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> MsgSender&lt;Company&gt;::sendClear;  <span class="comment">//告诉编译器，请它假设</span></span><br><span class="line">        ...                                   <span class="comment">//sendClear位于base class内。</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendClearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            sendClear(info);  <span class="comment">//OK，假设sendClear将被继承下来</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;（虽然using声明式在这里或在“”都可有效运行，但两处解决的问题其实不同。这里的情况并不是base class名称被derived class名称遮掩，而是编译器不进入base class作用域内查找，于是我们通过using告诉它，请它那么做。）</p>
<p>&emsp;&emsp;第三个做法，明白指出被调用函数位于base class内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingMsgSender</span> :</span> <span class="keyword">public</span> MsgSender&lt;Company&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sendCLearMsg</span><span class="params">(<span class="keyword">const</span> MsgInfo&amp; info)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            MsgSender&lt;Company&gt;::sendClear(info);  <span class="comment">//OK，假设sendClear将被继承下来。</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但这往往是最不让人满意的一个解法，因为如果被调用的是virtual函数，上述的明确资格修饰会关闭“virtual绑定行为”。</p>
<p>&emsp;&emsp;从名称可视点的角度出发，上述每一个解法做的事情都相同：对编译器承诺“base class template的任何特化版本都将支持其一般（泛化）版本所提供的接口”。这样一个承诺是编译器在解析像LoggingMsgSender这样的derived class template时需要的。但如果这个承诺最终未被实践出来，往后的编译最终还是会还给事实一个公道。举个例子，如果稍后的源码内含这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">LoggingMsgSender&lt;CompanyZ&gt; zMsgSender;</span><br><span class="line">MsgInfo msgData;</span><br><span class="line">...                                <span class="comment">//在msgData内放置信息。</span></span><br><span class="line">zMsgSender.sendClearMsg(msgData);  <span class="comment">//错误！无法通过编译。</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中对sendClearMsg的调用动作将无法通过编译，因为在那个点上，编译器知道base class是个template特化版本MsgSender&lt;CompanyZ&gt;，而且它们知道那个class不提供sendClear函数，而后者却是sendClearMsg尝试调用的函数。</p>
<p>&emsp;&emsp;根本而言，本条款探讨的是，面对“指涉base class members”之无效reference，编译器的诊断时间可能发生在早期（当解析derived class template的定义式时）。C++的政策是宁愿较早诊断，这就是为什么“当base class从template中被具现化时”它假设它对那些base class的内容毫无所悉的缘故。</p>
<blockquote>
<ul>
<li>可在derived class template内通过“this-&gt;”指涉base class template内的成员名称，或藉由一个明白写出的“base class资格修饰符”完成。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>宁以pass-by-reference-to-const替换pass-by-value</title>
    <url>/2020/08/01/%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/</url>
    <content><![CDATA[<hr>
<h1 id="宁以pass-by-reference-to-const替换pass-by-value"><a href="#宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="宁以pass-by-reference-to-const替换pass-by-value"></a>宁以pass-by-reference-to-const替换pass-by-value</h1><p>&emsp;&emsp;缺省情况下C++以by value方式（继承自C的方式）传递对象至（或来自）函数，除非我们另外指定，否则函数参数都是以实际实参的副本为初值，而调用端所获得的亦是函数返回值的一个副本。这些副本是由对象 copy构造函数产出，这可能使得pass-by-value成为昂贵的操作。考虑一下继承体系：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person();</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> address;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student();</span><br><span class="line">    ~Student();</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> schoolName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> schoolAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑一下代码，其中调用函数validateStudent，后者需要一个Student实参（by value）并返回它是否有效：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(Student s)</span></span>;  <span class="comment">//以by value方式接受学生</span></span><br><span class="line">Student plato;</span><br><span class="line"><span class="keyword">bool</span> platoIsOk = validateStudent(plato);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当上述函数被调用时，发生什么事？</p>
<p>&emsp;&emsp;无疑地Student的copy构造函数会被调用，以plato为蓝本将s初始化。同样明显地，当validateStudent返回s会被销毁。因此，对此函数而言，参数的传递成本是“一次Student copy构造函数被调用，加上一次Student析构函数被调用”。</p>
<p>&emsp;&emsp;但那还不是整个故事哦。Student对象内有两个string对象，所以每次构造一个Student对象也就构造了两个string对象。此外Student对象继承自Person对象，所以每次构造Student对象也必须构造出一个Person对象。一个Person对象又有两个string对象在其中，因此每一次Person构造动作又需承担两个string构造动作。最终总体成本是“六次构造函数和六次析构函数”！</p>
<p>&emsp;&emsp;要是有什么方法可以回避所有那些构造和析构就太好了。有的！这就是pass by reference-to-const：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStudent</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种传递方式的效率高得多：没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。修订后的这个参数声明中的const是重要的。原先的validateStudent以by value方式接受一个Student参数，因此调用者知道他们受到保护，函数内绝不会对传入的Student做任何改变；validateStudent只能够对其副本做修改。现在Student以by reference方式传递，将它声明为const是必要的，因为不这样做的话调用者会忧虑validateStudent会不会改变他们传入的那个Student。</p>
<p>&emsp;&emsp;以by reference方式传递参数也可以避免slicing（对象切割）问题。当一个derived class对象以by value方式传递并被视为一个base class对象，base class的copy构造函数会被调用，而“造成此对象的行为像个derived class对象”的那些特化性质全被切割掉了，仅仅留下一个base class对象。这实在不怎么让人惊讶，因为正是base class构造函数建立了它。但这几乎绝不会是我们想要的。假设我们在一组class上工作，用来实现一个图形窗口系统：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//返回窗口名称</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//显示窗口和其内容</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowWithScrollBars</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;所有Window对象都带有一个名称，你可以通过name函数取得它。所有窗口都可显示，你可以通过display函数完成它。display是个virtual函数，这意味着简单朴素的base class Window对象的显示方式和华丽高贵的WindowWithScrollBars对象的显示方式不同。</p>
<p>&emsp;&emsp;现在假设你希望写个函数打印窗口名称，然后显示该窗口。下面是错误示范：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(Window w)</span> </span>&#123;  <span class="comment">//不正确！参数可能被切割</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; w.name;</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当你调用上述函数并交给它一个WindowWithScrollBars对象，会发生什么事呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">WindowWithScrollBars wwsb；</span><br><span class="line">printNameAndDisplay(wwsb);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;参数w会被构造成为一个Window对象；它是passed by value。在printNameAndDisplay函数内不论传递过来的对象原本是什么类型，参数w就像一个Window对象（因为其类型是Window）。因此在printNameAndDisplay内调用display调用的总是Window::display，绝不会是WindowWithScrollBars::display。</p>
<p>&emsp;&emsp;解决切割问题的办法，就是以by reference-to-const的方式传递w：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNameAndDisplay</span><span class="params">(<span class="keyword">const</span> Window&amp; w)</span> </span>&#123;  <span class="comment">//很好，参数不会被切割</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; w.name();</span><br><span class="line">    w.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，传进来的窗口是什么类型，w就表现出那种类型。</p>
<p>&emsp;&emsp;如果窥视C++编译器的底层，我们会发现，reference往往以指针实现出来，因此pass by reference通常意味真正传递的是指针。因此如果我们有个对象属于内置类型（例如int），pass by value往往比pass by reference的效率高些。对内置类型而言，当我们有机会选择采用pass-by-value或pass-by-reference-to-const时，选择pass-by-value并非没有道理。这个忠告也适用于STL对迭代器和函数对象，因为习惯上它们都被设计为passed by value。迭代器和函数对象的实践者有责任看看它们是否高效且不受切割问题的影响。</p>
<p>&emsp;&emsp;一般而言，你可以合理假设“pass-by-value并不昂贵”的唯一对象就是内置类型和STL的迭代器和函数对象。至于其它任何东西都请遵守本条款的忠告，尽量以pass-by-reference-to-const替换pass-by-value。</p>
<blockquote>
<p>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。</p>
<p>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>宁以non-member、non-friend替换member函数</title>
    <url>/2020/08/03/%E5%AE%81%E4%BB%A5non-member%E3%80%81non-friend%E6%9B%BF%E6%8D%A2member%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="宁以non-member、non-friend替换member函数"><a href="#宁以non-member、non-friend替换member函数" class="headerlink" title="宁以non-member、non-friend替换member函数"></a>宁以non-member、non-friend替换member函数</h1><p>&emsp;&emsp;想象有个class用来表示网页浏览器。这样的class可能提供的众多函数中，有一些用来清除下载元素高速缓存区、清除访问过的URL的历史记录、以及移除系统中的所有cookies：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearCache</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearHistory</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeCookies</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多用户会想一整个执行所有这些动作，因此WebBrowser也提供这样一个函数：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearEverything</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，这一机能也可由一个non-member函数调用适当的member函数而提供出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span> </span>&#123;</span><br><span class="line">    wb.clearCache();</span><br><span class="line">    wb.clearHistory();</span><br><span class="line">    wb.removeCookies();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;那么，哪一个比较好呢？是member函数clearEverything还是non-member函数clearBrowser？</p>
<p>&emsp;&emsp;面向对象守则要求，数据以及操作数据的那些函数应该被捆绑在一块，这意味它建议member函数是好的选择。不幸的是这个建议不正确。这是基于面向对象真实意义的一个误解。面向对象守则要求数据应该尽可能被封装，然而与直观相反地，member函数clearEverything带来的封装性比non-member函数clearBrowser低。此外，提供non-member函数可允许对WebBrowser相关机能有较大的包裹弹性，而那最终导致较低的编译相依度，增加WebBrowser的可延伸性。因此在许多方面non-member做法比member做法好。重要的是，我们必须了解其原因。</p>
<p>&emsp;&emsp;让我们从封装开始讨论。如果某些东西被封装，它就不再可见。越多东西被封装，越少人可以看到它。而越少人看到它，我们就有越大的弹性去改变它，因为我们的改变仅仅直接影响看到改变的那些人事物。因此，越多东西被封装，我们改变那些东西的能力也就越大。这就是我们首先推崇封装的原因：它使我们能够改变事物而只影响有限客户。</p>
<p>&emsp;&emsp;成员变量应该是private，因为如果它们不是，就有无限量的函数可以访问它，它们也就毫无封装性。能够访问private成员变量的函数只有class的member函数加上friend函数而已。如果要你在一个member函数和一个non-member，non-friend函数之间做抉择，而且两者提供相同机能，那么，导致较大封装性的是non-member non-friend函数，因为它并不增加“能够访问class内的private成分”的函数变量。这就解释了为什么clearBrowser比clearEverything更受欢迎的原因：它导致WebBrowser class有较大的封装性。</p>
<p>&emsp;&emsp;在这一点上有两件事情值得注意。第一，这个论述只适用于non-member non-friend函数。friend函数对class private成员的访问权力和member函数相同，因此两者对封装的冲击力道也相同。从封装的角度看，这里的选择关键并不在member和non member函数之间，而是在member和non-member non-friend函数之间。</p>
<p>&emsp;&emsp;第二件值得注意的事情是，只因在意封装性而让函数“成为class的non-member”，并不意味它“不可以是另一个class的member”。这对那些习惯于“所有函数都必须定义于class内”的语言（如Java，C#）的程序员而言，可能是个温暖的慰藉。例如我们可以令clearBrowser成为某工具类的一个static member函数。只要它不是WebBrowser的一部分（或成为其friend），就不会影响WebBrowser的private成员封装性。</p>
<p>&emsp;&emsp;在C++内，比较自然的做法是让clearBrowser成为一个non-member函数并且位于WebBrowser所在的同一个namespace内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBrowser</span><span class="params">(WebBrowser&amp; wb)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然而这不只是为了看起来自然而已。要知道namespace和class不同，前者可跨越多个源码文件而后者不能。这很重要。</p>
<p>&emsp;&emsp;一个像WebBrowser这样的class可能拥有大量便利函数。某些与书签有关，某些与打印有关，还有一些与cookie的管理有关…… 通常大多数客户只对其中某些感兴趣。分离它们的最直接做法就是将书签相关便利函数声明于一个头文件，将cookie相关便利函数声明于另一个头文件，再将打印相关便利函数声明于第三个头文件，以此类推：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头文件“webbrowser.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebBrowser</span> &#123;</span> ... &#125;;</span><br><span class="line">...  <span class="comment">//核心机能，例如几乎所有客户都需要的non-member函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件“webbrowserbookmarks.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">...  <span class="comment">//与书签相关的便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件“webbrowsercookies.h”</span></span><br><span class="line"><span class="keyword">namespace</span> WebBrowserStuff &#123;</span><br><span class="line">...  <span class="comment">//与cookie相关的便利函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这正是C++标准程序库的组织方式。标准程序库并不是拥有单一、整体、庞大的&lt;C++StandardLibrary&gt;头文件并在其中内含std命名空间的每一样东西，而是有数十个头文件，每个头文件声明std的某些机能。如果客户只想使用vector相关机能，他不需要#include &lt;memory&gt;；如果客户不想使用list，也不需要#include&lt;list&gt;。这允许客户只对他们所用的那一小部分系统形成编译相依。以此种方式切割机能并不适用于class成员函数，因为一个class必须整体定义，不能被分割为片片段段。</p>
<p>&emsp;&emsp;将所有便利函数放在多个头文件内但隶属同一个命名空间，意味着客户可以轻松扩展这一组便利函数。他们需要做的就是添加更多non-member non-friend函数到此命名空间内。举个例子，如果某个WebBrowser客户决定写些与影像下载相关的便利函数，他只需在WebBrowserStuff命名空间内建立一个头文件，内含那些函数的声明即可。新函数就像其它旧有的便利函数那样可用且整合为一体。这是class无法提供的另一个性质，因为class定义式对客户而言是不能扩展的。当然啦，客户可以派生出新的class，但derived class无法访问base class中被封装的成员，于是如此的“扩展机能”拥有的只是次级身份。此外，并非所有class都被设计用来作为base class。</p>
<blockquote>
<p>宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充行。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>对new-handler这一技术的探讨</title>
    <url>/2020/11/23/%E5%AF%B9new-handler%E8%BF%99%E4%B8%80%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8E%A2%E8%AE%A8/</url>
    <content><![CDATA[<hr>
<h1 id="什么是new-handler？"><a href="#什么是new-handler？" class="headerlink" title="什么是new-handler？"></a>什么是new-handler？</h1><p>&emsp;&emsp;在调用operator new动作时，如果没有满足要求的内存可供分配，该动作会抛出一个异常。而在此“抛出异常”动作之前，它operator new会先调用一个客户指定的错误处理函数，也就是所谓的new-handler。（其实operator new正真做的事情稍微更加复杂些）。</p>
<a id="more"></a>

<h1 id="使用new-handler的一个简单实例"><a href="#使用new-handler的一个简单实例" class="headerlink" title="使用new-handler的一个简单实例"></a>使用new-handler的一个简单实例</h1><p>&emsp;&emsp;为了指定这个“用以处理内存不足”的函数，客户必须调用set_new_handler，这是声明于&lt;new&gt;的一个标准程序库函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span> <span class="params">()</span></span>;                      <span class="comment">//new_handler是个函数指针</span></span><br><span class="line">    <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">//不抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> &emsp;&emsp;set_new_handler的参数是一个指针，指向operator new无法分配足够内存时该被调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要被替换）的那个new-handler函数。</p>
<p>&emsp;&emsp;你可以这样使用set_new_handler：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是当operator new无法分配足够内存时，该被调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Unable to satisfy request for memory\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::set_new_handler(outOfMem);</span><br><span class="line">    <span class="keyword">int</span>* pBigDataArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000L</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就本例而言，如果operator new无法为100000000分配足够空间，outOfMem就会被调用。</p>
<p>&emsp;&emsp;当operator new无法满足内存申请时，它会不断调用new-handler函数，直到找到足够内存。</p>
<h1 id="设计良好的new-handler函数必须要做的事"><a href="#设计良好的new-handler函数必须要做的事" class="headerlink" title="设计良好的new-handler函数必须要做的事"></a>设计良好的new-handler函数必须要做的事</h1><ul>
<li><strong>让更多内存可被使用</strong>。这样的策略可能会使operator new内的下一次内存分配动作成功。实现此策略的一个做法是，程序一开始执行就分配一大块内存，然后当new-handler第一次被调用，将它们释放还给程序使用。</li>
<li><strong>安排另一个new-handler</strong>。如果目前这个new-handler无法取得更多可用内存，或许它知道另外哪个new-handler有这个能力。那么，目前这个new-handler就可以安装另外那个new-handler来替换自己（只要调用set_new_handler）。下次当operator new调用new-handler，调用的将是最新安装的那个。关于new-handler有一件值得关注的事，我们可以让new-handler修改自己的行为，于是当它下次被调用，就会做某些不同的事。为了达到这个功效，做法之一就是令new-handler修改“会影响new-handler行为”的static数据、namespace数据或global数据。</li>
<li><strong>卸除new-handler</strong>。也就是将null指针传给set_new_handler。一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。</li>
<li><strong>抛出bad_alloc（或派生自bad_alloc）的异常</strong>。这样的异常不会被operator new捕捉，因此会被传播到内存索求处。</li>
<li><strong>不返回</strong>。通常调用abort或exit。</li>
</ul>
<h1 id="C-并不支持class的专属new-handler"><a href="#C-并不支持class的专属new-handler" class="headerlink" title="C++并不支持class的专属new-handler"></a>C++并不支持class的专属new-handler</h1><p>&emsp;&emsp;虽然说C++并不支持class的专属new-handler，但其实也不需要。你可以自己实现出这种行为。只需要令每一个class提供自己的set_new_handler和operator new即可。其中set_new_handler允许客户指定class专属的new-handler（就像标准的set_new_handler允许客户指定global new-handler），至于operator new则确保在分配class对象内存的过程中以class专属的new-handler替换global new-handler。</p>
<h1 id="定制专属class的set-new-handler和operator-new"><a href="#定制专属class的set-new-handler和operator-new" class="headerlink" title="定制专属class的set_new_handler和operator new"></a>定制专属class的set_new_handler和operator new</h1><h2 id="普通版本"><a href="#普通版本" class="headerlink" title="普通版本"></a>普通版本</h2><p>&emsp;&emsp;现在我们拥有一个Widget class，假设我们打算处理Widget class的内存分配情况。当operator new无法为一个Widget对象分配足够内存时，我们需要声明一个类型为new_handler的static成员，用以指向class Widget的new-handler，相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::new_handler <span class="title">set_new_handler</span><span class="params">(<span class="built_in">std</span>::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;static成员必须在class定义式之外被定义（除非它们是const而且是整数型），所以需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::new_handler Widget::currentHandler = <span class="number">0</span>;  <span class="comment">//初始化为null</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Widget内的set_new_handler函数会将它获得的指针存储起来，然后返回先前（在此调用之前）存储的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::new_handler <span class="title">Widget::set_new_handler</span><span class="params">(<span class="built_in">std</span>::new_handler p)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::new_handler oldHandler= currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后，Widget的operator new会做以下事情：</p>
<ol>
<li>调用标准set_new_handler，告知Widget的错误处理函数。这会将Widget的new-handler安装为global new-handler。</li>
<li>调用global operator new，执行实际的内存分配。如果分配失败，global operator new会调用Widget的new-handler，因为这个函数才刚被安装为global new-handler。如果global operator new最终无法分配足够内存，会抛出一个bad_alloc异常。在此情况下Widget的operator new必须恢复原本的global new-handler，然后再传播该异常。为确保原本的new-handler总是能够被重新安装回去，Widget将global new-handler视为资源，并运用资源管理对象（例如智能指针）防止资源泄漏。</li>
<li>如果global operator new能够分配足够一个Widget对象所用的内存，Widget的operator new会返回一个指针，指向分配所得的内存空间。Widget析构函数会管理global new-handler，它会自动将Widget的operator new被调用前的那个global new-handler恢复回来。</li>
</ol>
<p>&emsp;&emsp;下面用C++作为实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerHolder</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">NewHandlerHolder</span><span class="params">(<span class="built_in">std</span>::new_handler nh)</span> : <span class="title">handler</span><span class="params">(nh)</span> </span>&#123;&#125;</span><br><span class="line">        ~NewHandlerHolder() &#123;</span><br><span class="line">            <span class="built_in">std</span>::set_new_handler(handler);</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::new_handler handler;</span><br><span class="line">        NewHandlerHolder(<span class="keyword">const</span> NewHandlerHolder&amp;);  <span class="comment">//阻止copying	</span></span><br><span class="line">        NewHandler&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NewHandlerHolder&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这就使得Widget的operator new的实现相当简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Widget::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(<span class="built_in">std</span>::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Widget的客户应该类似这样使用其new-handler：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>;  <span class="comment">//函数声明。此函数在Widget对象分配失败时被调用。</span></span><br><span class="line"></span><br><span class="line">Widget::set_new_handler(outOfMem);  <span class="comment">//设定outOfMem为Widget的new-handler函数。</span></span><br><span class="line"></span><br><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;  <span class="comment">//如果内存分配失败，调用outOfMem。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;  <span class="comment">//如果内存分配失败，调用global new-handler函数（如果有的话）。</span></span><br><span class="line"></span><br><span class="line">Widget::set_new_handler(<span class="number">0</span>);  <span class="comment">//设定Widget专属的new-handler函数为null。</span></span><br><span class="line"></span><br><span class="line">Widget* pw2 = <span class="keyword">new</span> Widget;  <span class="comment">//如果内存分配失败，立刻抛出异常（class Widget并没有专属的new-handler函数）。</span></span><br></pre></td></tr></table></figure>

<h2 id="template版本"><a href="#template版本" class="headerlink" title="template版本"></a>template版本</h2><p>&emsp;&emsp;现在让我们用template方式来实现上述代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewHandlerSupport</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::new_handler <span class="title">set_new_handler</span><span class="params">(<span class="built_in">std</span>::new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alooc)</span></span>;</span><br><span class="line">        ...  <span class="comment">//其他的operator版本</span></span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">std</span>::new_handler currentHandler;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::new_handler</span><br><span class="line">NewHandlerSuppport&lt;T&gt;::set_new_handler(<span class="built_in">std</span>::new_handler p) <span class="keyword">throw</span>() &#123;</span><br><span class="line">    <span class="built_in">std</span>::new_handler oldHandler = currentHandler;</span><br><span class="line">    currentHandler = p;</span><br><span class="line">    <span class="keyword">return</span> oldHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span>* NewHandlerSupport&lt;T&gt;::<span class="function"><span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="function">NewHandlerHolder <span class="title">h</span><span class="params">(<span class="built_in">std</span>::set_new_handler(currentHandler))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下将每一个currentHandler初始化为null</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有了这个class template，为Widget添加set_new_handler支持能力就轻而易举了：只要令Widget继承自NewHandlerSupport&lt;Widget&gt;就可以了，像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">public</span> NewHandlerSupport&lt;Widget&gt; &#123;</span><br><span class="line">    ...  <span class="comment">//和之前一样，但不必声明set_new_handler或operator new</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="operator-new的异常处理"><a href="#operator-new的异常处理" class="headerlink" title="operator new的异常处理"></a>operator new的异常处理</h1><p>&emsp;&emsp;直到1993年，C++都还要求operator new必须在无法分配足够内存时返回null。新一代的operator new则应该抛出bad_alloc异常，但很多C++程序是在编译器开始支持新修改规范前写出来的。C++标准委员会不想抛弃那些“侦测null”的族群，于是提供了另一形式的operator new，负责支持传统的“分配失败便返回null”行为。这个形式被称为“nothrow”形式——某种程度上是因为他们在new的使用场合用了nothrow对象（定义于头文件&lt;new&gt;）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">Widget* pw1 = <span class="keyword">new</span> Widget;  <span class="comment">//如果分配失败，抛出bad_alloc</span></span><br><span class="line"><span class="keyword">if</span>(pw1 == <span class="number">0</span>) ...  <span class="comment">//这个结果一定为false</span></span><br><span class="line">Widget* pw2 = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) Widget;  <span class="comment">//如果分配Widget失败，返回0</span></span><br><span class="line"><span class="keyword">if</span>(pw2 == <span class="number">0</span>) ...  <span class="comment">//这个结果可能为true</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;nothrow new对异常的强制性保证并不会像你所想的那样如此的可靠。要知道，表达式“new (std::nothrow) Widget”发生两件事，第一，nothrow版的operator new被调用，用以分配足够内存给Widget对象。如果分配失败便会返回null指针。如果分配成功，接下来Widget构造函数会被调用，而这之后之前nothrow new所做的保证便一去不复返了，因为Widget构造函数可以做它想做的任何事。它有可能又new一些内存，而没人可以强迫它再次使用nothrow new。因此虽然“new (std::nothrow) Widget”调用的operator new并不抛出异常，但Widget构造函数却可能会。</p>
<p>&emsp;&emsp;结论就是：使用nothrow new只能保证operator new不抛出异常，不保证像“new (nothrow) Widget”这样的表达式绝不导致异常。因此你其实没有使用nothrow new的必要。</p>
<p>&emsp;&emsp;无论使用正常（会抛出异常）的new，还是其或多或少有点发育不良等nothrow兄弟，重要的是你需要了解new-handler的行为，因为两种形式都使用它。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><blockquote>
<ul>
<li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。</li>
<li>nothrow new是一个有局限性的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>将文件间的编译依存关系降至最低</title>
    <url>/2020/08/13/%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E/</url>
    <content><![CDATA[<hr>
<h1 id="将文件间的编译依存关系降至最低"><a href="#将文件间的编译依存关系降至最低" class="headerlink" title="将文件间的编译依存关系降至最低"></a>将文件间的编译依存关系降至最低</h1><p>&emsp;&emsp;假设你对C++程序的某个class实现文件做了些轻微修改。注意，修改的不是class接口，而是实现，而且只改private成分。然后重新建置这个程序，并预计只花数秒就好。毕竟只有一个class被修改。你按下“Build”按钮或键入make（或其它类似命令），然后大吃一惊，然后感到困惑，因为你意识到整个世界都被重新编译和连接了！当这种事情发生，难道你不气恼吗？</p>
<a id="more"></a>

<p>&emsp;&emsp;问题出在C++并没有把“将接口从实现中分离”这事做得很好。class的定义式不只详细描述了class接口，还包括十足的实现细目。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">           <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> cosnt</span>;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的class Person无法通过编译——如果编译器没有取得其实现代码所用到的class string，Date和Address的定义式。这样的定义式通常由#include指示符提供，所以Person定义式的最上方很可能存在这样的东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"date.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不幸的是，这么一来便是在Person定义文件和其含入文件之间形成了一种编译依存关系。如果这些头文件中有任何一个被改变，或这些头文件所倚赖的其它头文件有任何改变，那么每一个含入Person class的文件就得重新编译，任何使用Person class的文件也必须重新编译。这样的连串编译依存关系会对许多项目造成难以形容的灾难。</p>
<p>&emsp;&emsp;你或许会奇怪，为什么C++坚持将class的实现细目置于class定义式中？为什么不这样定义Person，将实现细目分开叙述？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string</span>;</span>   <span class="comment">//前置声明（不正确，详下）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>     <span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span>  <span class="comment">//前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">           <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果可以那么做，Person的客户就只需要在Person接口被修改过时才重新编译。</p>
<p>&emsp;&emsp;这个想法存在两个问题。第一，string不是个class，它是个typedef（定义为basic_string&lt;char&gt;）。因此上述针对string而做的前置声明并不正确；正确的前置声明比较复杂，因为涉及额外的template。然而那并不要紧，因为你本来就不该尝试手工声明一部分标准程序库。你应该仅仅使用适当的#include完成目的。标准头文件不太可能成为编译器瓶颈，特别是如果你的建置环境允许你使用预编译头文件。如果解析标准头文件真的是个问题，你可能需要改变你的接口设计，避免使用标准程序库中“引发不受欢迎之#include”那一部分。</p>
<p>&emsp;&emsp;关于“前置声明每一件东西”的第二个（同时也是比较重要的）困难是，编译器必须在编译期间知道对象的大小。考虑这个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;               <span class="comment">//定义一个int</span></span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">( params )</span></span>;  <span class="comment">//定义一个Person</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译器看到x的定义式，它知道必须分配多少内存（通常位于stack内）才够持有一个int。没问题，每个编译器都知道一个int有多大。当编译器看到p的定义式，它也知道必须分配足够空间以放置一个Person，但它如何知道一个Person对象有多大呢？编译器获得这项信息的唯一办法就是询问class定义式。然而如果class定义式可以合法地不列出实现细目，编译器如何知道该分配多少空间？</p>
<p>&emsp;&emsp;此问题在Java等语言上并不存在，因为当我们以那种语言定义对象时，编译器只分配足够空间给一个指针（用以指向该对象）使用。也就是说它们将上述代码视同这样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;      <span class="comment">//定义一个int</span></span><br><span class="line">    Person* p;  <span class="comment">//定义一个指针指向Person对象</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这当然也是合法的C++代码，所以你也可以自己玩玩“将对象实现细目隐藏于一个指针背后”的游戏。针对Person我们可以这样做：把Person分割为两个class，一个只提供接口，另一个负责实现该接口。如果负责实现的那个所谓implementation class取名为PersonImpl，Person将定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  //标准程序库组件不该被前置声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonImpl</span>;</span>  <span class="comment">//Person实现类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>        <span class="comment">//Person接口用到的class的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">           <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;  <span class="comment">//指针，指向实现物</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这里，main class（Person）只内含一个指针成员（这里使用shared_ptr），指向其实现类。这般设计常被称为pimpl idiom。这种class内的指针名称往往就是pImpl，就像上面代码那样。</p>
<p>&emsp;&emsp;这样的设计之下，Person的客户就完全与Date，Address以及Person的实现细目分离了。那些class的任何实现修改都不需要Person客户端重新编译。此外由于客户无法看到Person的实现细目，也就不可能写出什么“取决于那些细目”的代码。这真正是“接口与实现分离”！</p>
<p>&emsp;&emsp;这个分离的关键在于以“声明的依存性”替换“定义的依存性”，那正是编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让它与其它文件内的声明式（而非定义式）相依。其它每一件事都源自于这个简单的设计策略：</p>
<ul>
<li><p><strong>如果使用object reference或object pointer可以完成任务，就不要使用object</strong>。你可以只靠一个类型声明式就 定义出指向该类型的reference和pointer；但如果定义某类型的object，就需要用到该类型的定义式。</p>
</li>
<li><p><strong>如果能够，尽量以class声明式替换class定义式</strong>。注意，当你声明一个函数而它用到某个class时，你并不需要该class的定义式；纵使函数以by value方式传递该类型的参数（或返回值）亦然：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，pass-by-value一般而言是个糟糕的注意（见“<a href="/2020/08/01/%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/" title="宁以pass-by-reference-to-const替换pass-by-value">宁以pass-by-reference-to-const替换pass-by-value</a>”），但如果你发现因为某些因素被迫使用它，并不能够就此为“非必要之编译依存关系”导入正当性。</p>
<p>&emsp;&emsp;声明today函数和clearAppointments函数而无需定义Date，这种能力可能会令你惊讶，但它并不是真的那么神奇。一旦任何人调用那些函数，调用之前Date定义式一定得先曝光才行。那么或许你会纳闷，何必费心声明一个没人调用的函数呢？嗯，并非没人调用，而是并非每个人都调用。假设你有一个函数库内含数百个函数声明，不太可能每个客户叫遍每一个函数。如果能够将“提供class定义式”的义务从“函数声明所在”之头文件转移到“内含函数调用”之客户文件，便可将“并非真正必要之类型定义”与客户端之间的编译依存性去除掉。</p>
</li>
<li><p><strong>为声明式和定义式提供不同的头文件</strong>。为了促进严守上述准则，需要两个头文件，一个用于声明式，一个用于定义式。当然，这些文件必须保持一致性，如果有个声明式被改变了，两个文件都得改变。因此程序库客户应该总是#include一个声明文件而非前置声明若干函数，程序库作者也应该提供这两个头文件。举个例子，Date的客户如果希望声明today和clearAppointments，他们不该像先前那样以手工方式前置声明Date，而是应该#include适当的、内含声明式的头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"datefwd.h"</span>  <span class="comment">//这个头文件内声明（但未定义）class Date</span></span></span><br><span class="line"><span class="function">Date <span class="title">today</span><span class="params">()</span></span>;         <span class="comment">//同前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppointments</span><span class="params">(Date d)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只含声明式的那个头文件名为“datefwd.h”，命名方式取法C++标准程序库头文件的&lt;iosfwd&gt;。&lt;iosfwd&gt;内含iostream各组件的声明式，其对应定义则分布在若干不同的头文件内，包括&lt;sstream&gt;，&lt;streambuf&gt;，&lt;fstream&gt;和&lt;iostream&gt;。</p>
<p>&emsp;&emsp;&lt;iosfwd&gt;深具启发意义的另一个原因是，它分外彰显“本条款适用于template也适用于non-template”。虽然“<a href="/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/" title="透彻了解inlining的里里外外">透彻了解inlining的里里外外</a>”说过，在许多建置环境中template定义式通常被置于头文件内，但也有些建置环境允许template定义式放在“非头文件”内，这么一来就可以将“只含声明式”的头文件提供给template。&lt;iosfwd&gt;就是这样一份头文件。</p>
<p>&emsp;&emsp;C++也提供关键字export，允许将template声明式和template定义式分割于不同的头文件内。不幸的是支持这个关键字的编译器目前非常少，因此现实中使用这个关键字的经验也非常少。目前若要评论export在高效C++编程中扮演什么角色，恐怕言之过早。</p>
</li>
</ul>
<p>&emsp;&emsp;像Person这样使用pimpl idiom的class，往往被称为Handle class。也许你会纳闷，这样的class如何真正做点事情。办法之一是将它们的所有函数转交给相应的实现类并由后者完成实际工作。例如下面是Person两个成员函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Person.h"</span>  <span class="comment">//我们正在实现Person class，</span></span></span><br><span class="line">                     <span class="comment">//所以必须#include其class定义式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"PersonImpl.h"</span>  <span class="comment">//我们也必须#include PersonImpl的</span></span></span><br><span class="line">                         <span class="comment">//class定义式，否则无法调用其成员函数；</span></span><br><span class="line"></span><br><span class="line">Person::Person(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr)</span><br><span class="line">  : pImpl(<span class="keyword">new</span> PersonImpl(name, birhday, addr)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Person::name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pImpl-&gt;name();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;请注意，Person构造函数以new调用PersonImpl构造函数，以及Person::name函数内调用PersonImpl::name。这是很重要的，让Person变成一个Handle class并不会改变它做的事，只会改变它做事的方法。</p>
<p>&emsp;&emsp;另一个制作Handle class的办法是，令Person成为一种特殊的abstract base class（抽象基类），称为interface class。这种class的目的是详细一一描述derived class的接口，因此它通常不带成员变量，也没有构造函数，只有一个virtual析构函数以及一组pure virtual函数，用来叙述整个接口。</p>
<p>&emsp;&emsp;interface class类似Java的interface，但C++的interface class并不需要负担Java的interface所需负担的责任。举个例子，Java不允许在interface内实现成员变量或成员函数，但C++不禁止这两样东西。C++这种更巨大的弹性有其用途，“non-virtual函数的实现”对继承体系内的所有class都应该相同，所以将此等函数实现为interface class的一部分也是合理的。</p>
<p>&emsp;&emsp;一个针对Person而写的interface class或许看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Person();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个class的客户必须以Person的pointer和reference来撰写应用程序，因为它不可能针对“内含pure virtual函数”的Person class具现出实体。（然而却有可能对派生自Person的class具现出实体）就像Handle class的客户一样，除非interface class的接口被修改否则其客户不需重新编译。</p>
<p>&emsp;&emsp;interface class的客户必须有办法为这种class创建对象。他们通常调用一个特殊函数，此函数扮演“真正将被具现化”的那个derived class的构造函数角色。这样的函数通称为factory函数或virtual构造函数。它们返回指针（或更为可取的智能指针），指向动态分配所得对象，而该对象支持interface class的接口。这样的函数又往往在interface class内被声明为static：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt;</span><br><span class="line">      create(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span><br><span class="line">             <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">             <span class="keyword">const</span> Address&amp; addr);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>客户会这样使用它们：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">Date dateOfBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//创建一个对象，支持Person接口</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">pp</span><span class="params">(Person::create(name, dateOfBirth, address))</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; pp-&gt;name  <span class="comment">//通过Person的接口使用这个对象</span></span><br><span class="line">          &lt;&lt; <span class="string">" was born on "</span></span><br><span class="line">          &lt;&lt; pp-&gt;birthDate()</span><br><span class="line">          &lt;&lt; <span class="string">" and now lives at"</span></span><br><span class="line">          &lt;&lt; pp-&gt;address();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，支持interface class接口的那个具象类必须被定义出来，而且真正的构造函数必须被调用。一切都在virtual构造函数实现码所在的文件内秘密发生。假设interface class Person有个具象的derived class RealPerson，后者提供继承而来的virtual函数的实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealPerson</span>:</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RealPerson(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> Date&amp; birthday,</span><br><span class="line">               <span class="keyword">const</span> Address&amp; addr)</span><br><span class="line">      : theName(name), theBirthDate(birthday), theAddress(addr) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~RealPerson() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    Date theBirthDate;</span><br><span class="line">    Address theAddress;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了RealPerson之后，写出Person::create就真的一点也不稀奇了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt; <span class="title">Person::create</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> Date&amp; birthday,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> Address&amp; addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Person&gt;(<span class="keyword">new</span> RealPerson(name, birthday, addr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一个更现实的Person::create实现代码会创建不同类型的derived class对象，取决于诸如额外参数值、读自文件或数据库的数据、环境变量等等。</p>
<p>&emsp;&emsp;RealPerson示范实现interface class的两个最常见机制之一：从interface class（Person）继承接口规格，然后实现出接口所覆盖的函数。interface class的第二个实现算法涉及多重继承。</p>
<p>&emsp;&emsp;handle class和interface class解除了接口和实现之间的耦合关系，从而降低文件间的编译依存性。</p>
<p>&emsp;&emsp;在handle class身上，成员函数必须通过implementation pointer取得对象数据。那会为每一次访问增加一层间接性。而每一个对象消耗掉的内存数量必须增加implementation pointer的大小。最后，implementation pointer必须初始化（在handle class构造函数内），指向一个动态分配得来的implementation object，所以你将蒙受因动态内存分配（及其后的释放动作）而来的额外开销，以及遭遇bad_alloc异常（内存不足）的可能性。</p>
<p>&emsp;&emsp;至于interface class，由于每个函数都是virtual，所以你必须为每次函数调用付出一个间接跳跃成本（见“<a href="/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" title="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</a>”）。此外interface class派生的对象必须内含一个vptr（再次见“<a href="/2020/07/22/%E4%B8%BA%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" title="为多态基类声明virtual析构函数">为多态基类声明virtual析构函数</a>”），这个指针可能会增加存放对象所需的内存数量——实际取决于这个对象除了interface class之外是否还有其他virtual函数来源。</p>
<p>&emsp;&emsp;最后，不论handle class或interface class，一旦脱离inline函数都无法有太大作为。“<a href="/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/" title="透彻了解inlining的里里外外">透彻了解inlining的里里外外</a>”解释过为什么函数本体为了被inlined必须（很典型地）置于头文件内，但handle class和interface class正是特别被设计用来隐藏实现细节如函数本体。</p>
<p>&emsp;&emsp;然而，如果只因为若干额外成本便不考虑handle class和interface class，将是严重的错误。virtual函数不也带来成本吗？你并不会想要弃绝它们对不对？你应该考虑以渐近方式使用这些技术。在程序开发过程中使用handle class和interface class以求实现码有所变化时对客户带来最小冲击。而当它们导致速度和大小差异过于重大以至于class之间的耦合相形之下不成为关键时，就以具象类替换handle class和interface class。</p>
<blockquote>
<ul>
<li>支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是handle class和interface class。</li>
<li>程序库头文件应该以“完全且仅有声明式”的形式存在。这种做法不论是否涉及template都适用。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽可能使用const</title>
    <url>/2020/07/18/%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const/</url>
    <content><![CDATA[<hr>
<h1 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h1><p>&emsp;&emsp;关键字const多才多艺。我们可以用它在classes外部修饰global或namespace作用域中的常量，或修饰文件、函数、或区块作用域中被声明为static的对象。我们也可以用它修饰classes内部的static和non-static成员变量。面对指针，我们也可以指出指针自身、指针所指物，或者两者都（或都不）是const：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span>* p = greeting;              <span class="comment">//non-const pointer,non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting;        <span class="comment">//non-const pointer,const data</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;        <span class="comment">//const pointer,non-const data</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting;  <span class="comment">//const pointer,const data</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;STL迭代器是以指针为基础塑模出来的，所以迭代器的作用就像个T*指针。声明迭代器为const就像声明指针为const一样（即声明一个T*const指针），表示这个迭代器不得指向不同的东西，但它所指的东西的值是可以改动的。如果我们希望迭代器所指的东西不可被改动，我们需要的是const_iterator：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = vec.<span class="built_in">begin</span>();</span><br><span class="line">*iter = <span class="number">10</span>;  <span class="comment">//没问题，改变iter所指物</span></span><br><span class="line">++iter;  <span class="comment">//错误！iter是const</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator cIter = vec.<span class="built_in">begin</span>();</span><br><span class="line">*cIter = <span class="number">10</span>;  <span class="comment">//错误！*cIter是const</span></span><br><span class="line">++cIter;  <span class="comment">//没问题，改变cIter</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;const最具威力的用法是面对函数声明时的应用。在一个函数声明式内，const可以和函数返回值、各参数、函数自身（如果是成员函数）产生关联。</p>
<p>&emsp;&emsp;令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。举个例子，考虑有理数的operator&#42;声明式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;许多程序员第一次看到这个声明时不免斜着眼睛说，为什么返回一个const对象？原因是如果不这样客户就能实现这样的暴行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line">(a * b) = c;  <span class="comment">//在a * b的结果上调用operator=</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我不知道为什么会有人想对两个数值的乘积再做一次赋值，也许只是因为单纯的打字错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a * b = c) ...  <span class="comment">//其实是想做一个比较动作</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果a和b都是内置类型，这样的代码就是不合法的。而一个良好的用户自定义类型的特征是它们不会无端地与内置类型不兼容，因此允许对两值乘积做赋值动作也就没什么意思了。将operator*的回传值声明为const可以预防这个“没意思的赋值动作”，这就是该那么做的原因。</p>
<p>&emsp;&emsp;至于const参数，没有什么特别的解释，它们不过就像是local const对象一样，我们应该在必要的时候使用它们。除非我们有改动参数或local对象，否则应该声明为const。只不过多打6个字符，却可以省下烦人的错误，像是“想要键入‘==’却意外键入‘=’”的错误。</p>
<h1 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h1><p>&emsp;&emsp;将const用于成员函数的目的，是为了确认该成员函数可作用于const对象身上，这一类成员函数之所以重要，基于两个理由。第一，它们使class接口比较容易被理解。这是因为，得知哪个函数可以改动对象内容而哪个函数不行，非常重要。第二，它们使“操作const对象”成为可能。这是编写高效代码的关键所在，改善C++程序效率的一个根本办法是以pass by reference-to-const方式传递对象，而此技术可行的前提是，我们有const成员函数可用来处理取得（并经修饰而成）的const对象。</p>
<p>&emsp;&emsp;许多人漠视一个事实：两个成员函数如果只是常量性不同，可以被重载。这是一个重要的C++特性。考虑以下class，用来表现大一块文字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>:<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TextBlock的operator[]s可被这么使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tb[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">"World"</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>顺带一提，真实程序中const对象大多用于passed by pointer-to-const或passed by reference-to-const的传递效果。上述的ctb例子太过造作，下面这个比较真实：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> TextBlock&amp; ctb)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要注意的是，non-const operator[]的返回类型是个reference to char，不是char。如果operator[]只是返回一个char，下面这样的句子就无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tb[<span class="number">0</span>] = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是因为，如果函数的返回类型是个内置类型，那么改动函数返回值从来就不合法。纵使合法，C++以by value返回对象这一事实意味着被改动的其实是tb.text[0]的一个副本，不是tb.text[0]自身，我们也不会想要这样愚蠢的行为。</p>
<h2 id="bitwise-constness-amp-logical-constness"><a href="#bitwise-constness-amp-logical-constness" class="headerlink" title="bitwise constness &amp; logical constness"></a>bitwise constness &amp; logical constness</h2><p>&emsp;&emsp;成员函数如果是const意味着什么？这里有两个流行的概念：bitwise constness（又称physical constness）和logical constness。</p>
<p>&emsp;&emsp;bitwise const阵营的人相信，成员函数只有在不更改对象的任何成员变量（static除外）时才可以说是const。也就是说它不更改对象内的任何一个bit。这种论点的好处是很容易侦测违反点：编译器只需寻找成员变量的赋值动作即可。bitwise constess正是C++对常量性的定义，因此const成员函数不可以更改对象内任何non-static成员变量。</p>
<p>&emsp;&emsp;不幸的是许多成员函数虽然不完全具备const性质却能通过bitwise测试。更具体地说，一个更改了“指针所指物”的成员函数虽然不能算是const，但如果只有指针（而非其所指物）隶属于对象，那么可以说此函数为bitwise const不会引起编译器的抗议。这导致反直观结果。假设我们有一个TextBlock-like class，它将数据存储为char*而不是string，因为它需要和一个不认识string对象的C API沟通：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;  <span class="comment">//bitwise const声明</span></span><br><span class="line">        <span class="keyword">return</span> pText[<span class="built_in">position</span>];                     <span class="comment">//但其实不恰当。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个class不适当地将其operator[]声明为const成员函数，而该函数却返回一个reference指向对象内部值。假设暂时不管这个事实，注意，operator[]实现代码并不更改pText。于是编译器很开心地为operator[]产出目标码。它是bitwise const，所有编译器都这么认定。但是我们来看下它会允许发生些什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> CTextBlock <span class="title">cctb</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span>* pc = &amp;cctb[<span class="number">0</span>];</span><br><span class="line">*pc = <span class="string">'J'</span>;  <span class="comment">//现在cctb有了“Jello”这样的内容</span></span><br></pre></td></tr></table></figure>

<p>这其中当然不该有任何错误：我们创建一个常量对象并设置某值，而且只对它调用const成员函数。但我们终究还是改变了它的值。</p>
<p>&emsp;&emsp;这种情况引出了所谓的logical constness。这一派拥护者主张，一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。例如我们的CTextBlock class有可能高速缓存文本区块的长度以便应付询问：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);  <span class="comment">//错误！在const成员函数内不能赋值给</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;             <span class="comment">//textLength和lengthIsValid。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;length的实现当然不是bitwise const，因为textLength和lengthIsValid都可能被修改。这两个数据被修改对const CTextBlock对象而言虽然可接受，但编译器不同意。它们坚持bitwise constness。怎么办？</p>
<p>&emsp;&emsp;解决办法很简单：利用C++的一个与const相关的关键字：mutable。mutable释放掉non-static成员变量的bitwise constness约束：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* pText;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> textLength;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> lengthIsValid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">CTextBlock::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!lengthIsValid) &#123;</span><br><span class="line">        textLength = <span class="built_in">std</span>::<span class="built_in">strlen</span>(pText);  <span class="comment">//现在，可以这样</span></span><br><span class="line">        lengthIsValid = <span class="literal">true</span>;             <span class="comment">//这样也可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> textLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h2><p>&emsp;&emsp;对于“bitwise-constness非所我欲”的问题，mutable是个解决办法，但它不能解决所有的const相关难题。举个例子，假设TextBlock（和CTextBlock）内的operator[]不单只是返回一个reference指向字符，也执行边界检验、日志访问信息、甚至可能进行数据完善性检验。把所有这些同时放进const和non-const operator[]中，导致这样的怪物：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ...  <span class="comment">//边界检验</span></span><br><span class="line">        ...  <span class="comment">//日志数据访问</span></span><br><span class="line">        ...  <span class="comment">//检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        ...  <span class="comment">//边界检验</span></span><br><span class="line">        ...  <span class="comment">//日志数据访问</span></span><br><span class="line">        ...  <span class="comment">//检验数据完整性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">text</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们真正该做的是实现operator[]的功能一次并使用它两次。也就是说，我们必须令其中一个调用另一个。这促使我们将常量性消除。</p>
<p>&emsp;&emsp;就一般守则而言，转型是一个糟糕的想法。然而代码重复也一样使我们恼火。这面是避免代码重复的安全做法的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) <span class="keyword">const</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">text</span>[<span class="built_in">position</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">position</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[<span class="built_in">position</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码有两个转型动作。我们打算让non-const operator[]调用其const兄弟，但non-const operator[]内部若只是单纯调用operator[]，会递归调用自己。那大概会……唔……进行一百万次。为了避免无穷递归，我们必须明确指出调用的是const operator[]，但C++缺乏直接的语法可以那么做。因此这里将*this从其原始类型TextBlock&amp;转型为const TextBlock&amp;。这里的两次转型，第一次使用来为*this添加const（这使接下来调用operator[]时得以调用const版本），第二次则是从const operator[]的返回值中移除const。</p>
<p>&emsp;&emsp;至于其他动作，由于本例调用的是操作符，所以语法有一点奇特，恐怕无法赢得选美大赛，但却有我们渴望的“避免代码重复”的效果，因为它运用const operator[]实现出non-const版本。为了达到这个目标而写出如此难看的语法是否值得，只能由自己来决定了。但“运用const成员函数实现出non-const孪生兄弟”的技术是值得了解的。</p>
<p>&emsp;&emsp;更值得我们了解的是，反向做法——令const版本调用non-const版本以避免重复——这并不是我们该做的事。记住，const成员函数决不允许改变其对象的逻辑状态，non-const成员函数却没有这样的强制要求。如果在const函数内调用non-const函数，就会冒这样的风险：我们不想改变的那个对象被改动了。这就是为什么“const成员函数调用non-const成员函数”是一个错误行为：因为对象有可能因此被改动。实际上若要这样的代码通过编译，我们必须使用一个const_cast将*this身上的const性质解放掉，这是世界末日的前兆。之前的调用才是安全的：non-const成员函数本来就可以对其对象做任何操作，所以在其中调用一个const成员函数并不会带来风险。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li><p>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</p>
</li>
<li><p>编译器强制实施bitwise constness，但我们编写程序时应该使用“概念上的常量性”。</p>
</li>
<li><p>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽量以const,enum,inline替换define</title>
    <url>/2020/07/17/%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%E6%9B%BF%E6%8D%A2define/</url>
    <content><![CDATA[<h1 id="尽量以const-enum-inline替换-define"><a href="#尽量以const-enum-inline替换-define" class="headerlink" title="尽量以const,enum,inline替换#define"></a>尽量以const,enum,inline替换#define</h1><p>&emsp;&emsp;宁可以编译器替换预处理器，因为或许#define不被视为语言的一部分。这正是问题的所在，当我们写出一下代码时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;记号名称ASPECT_RATIO也许从未被编译器看见；也许在编译器开始处理源代码之前它就被预处理器移走了。于是记号名称ASPECT_RATIO有可能没进入记号表内。于是当我们运行此常量但获得一个编译错误信息时，可能会有所困惑，因为这个错误信息也许会提到1.653而不是ASPECT_RATIO。如果ASPECT_RATIO被定义在一个非我们所写的头文件内，我们肯定对1.653以及它来自何处毫无头绪，于是我们将因为追踪它而浪费时间。这个问题也可能出现在记号式调试器中，原因相同：我们所使用的名称可能并未进入记号表。</p>
<a id="more"></a>

<p>&emsp;&emsp;解决之道是以一个常量替换上述的宏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span>;  <span class="comment">//大写名称通常用于宏</span></span><br><span class="line">                                   <span class="comment">//因此这里改变名称写法</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;作为一个语言常量，AspectRatio肯定会被编译器看到，当然就会进入记号表内。此外对浮点常量而言，使用常量可能比使用#define导致较小量的码，因为预处理器“盲目地将宏名称ASPECT_RATIO替换为1.653”可能导致目标码出现多份1.653，若改用常量AspectRatio绝不会出现相同情况。</p>
<p>&emsp;&emsp;当我们以常量替换#define，有两种特殊情况值得说说。第一是定义常量指针。由于常量定义式通常被放在头文件内（以便被不同的源码含入），因此有必要将指针声明为const。例如若要在头文件内定义一个常量char*-based字符串，我们必须写const两次：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> authorName = <span class="string">"Guan Zhe"</span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;关于const的意义和使用（特别是当它与指针结合时），之后有完整的讨论。这里这里值得提醒的是，string对象通常比其前辈char*-based更佳适合，所以上述的authorName往往定义成这样更好些：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>:<span class="function"><span class="built_in">string</span> <span class="title">authorName</span><span class="params">(<span class="string">"Guan Zhe"</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第二个值得注意的是class专属常量。为了将常量的作用域限制于class内，你必须让它成为class的一个成员；而为确保此常量至多只有一份实体，我们必须让它成为一个static成员：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">//常量声明式  </span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];           <span class="comment">//使用该常量</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然而我们所看到的是NumTurns的声明式而非定义式。通常C++要求我们对我们所使用的任何东西提供一个定义式，但如果它是个class专属常量又是static且为整数类型，则需特殊处理。只要不取它们的地址，我们可以声明并使用它们而无须提供定义式。但如果我们取某个class专属常量的地址，或纵使我们不取其地址而我们的编译器却（不正确地）坚持要看到一个定义式，我们就必须另外提供定义式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;  <span class="comment">//NumTurns的定义</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;请把这个式子放进一个实现文件而非头文件。由于class常量已在声明时获得初值，因此定义时不可以再设初值。</p>
<p>&emsp;&emsp;顺带一提，请注意，我们无法利用#define创建一个class专属常量，因为#define并不重视作用域。一旦宏被定义，它就在其后的编译过程中有效（除非在某处被#undef）。这意味着#defines不仅不能够用来定义class专属常量，也不能够提供任何封装性，也就是说没有所谓private #define这样的东西。而当然const成员变量是可以被封装的，NumTurns就是。</p>
<p>&emsp;&emsp;旧式编译器也许不支持上述语法，它们不允许static成员在其声明式上获得初值。此外所谓的“in-class初值设定“也只允许对整数常量进行。如果我们的编译器不支持上述语法，则可以将初值放在定义时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CostEstimate</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> FudgeFactor;  <span class="comment">//static class常量声明，位于头文件</span></span><br><span class="line">&#125;；</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> CostEstimate::FudgeFactor = <span class="number">1.35</span>;  <span class="comment">//static class常量定义，位于实现文件内</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这几乎是我们在任何时候唯一需要做的事。唯一例外的是当我们在class编译期间需要一个class常量值，例如在上述的GamePlayer::scores的数组声明式中（编译器坚持必须在编译期间之道数组的大小）。这时候万一我们的编译器（错误地）不允许“static整数型class常量”完成“in class初值设定”，可改用所谓的“the enum hack”补偿做法。其理论基础是：“一个属于枚举类型的数值可当ints被使用，于是GamePlayer可定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span> &#125;;  <span class="comment">//"the enum hack"令NumTurns成为5的一个记号名称</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;基于数个理由enum hack值得我们认识。第一，enum hack的行为某方面比较像#define而不像const，有时候这正是我们想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法。如果我们不想让别人获得一个pointer或reference指向我们的某个整数常量，enum可以帮助我们实现这个约束。此外虽然优秀的编译器不会为“整数型const对象”设定另外的存储空间（除非我们创建一个pointer或reference指向该对象），不够优秀的编译器却可能如此，而这可能不是我们想要的。Enum和#define一样绝不会导致非必要的内存分配。</p>
<p>&emsp;&emsp;认识enum hack的第二个理由纯粹是为了实用主义。许多代码用了它。事实上“enum hack”是template metaprogramming的基础技术。</p>
<p>&emsp;&emsp;把焦点拉回预处理器。另一个常见的#define误用情况是以它实现宏（macros）。宏看起来像函数，但不会导致函数调用带来的额外开销。下面这个宏家呆着宏实参，调用函数f：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以a和b的较大值调用f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a) : (b))</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这般长相的宏有着太多缺点，光是想到它们就让人痛苦不堪。</p>
<p>&emsp;&emsp;无论何时当我们写出这种宏，我们必须记住为宏中的所有实参加上小括号，否则某些人在表达式中调用这个宏时可能会遭遇麻烦。但纵使我们为所有实参加上小括号，也会出现一些不可思议的事情：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0</span>;</span><br><span class="line">CALL_WITH_MAX(++a,b);     <span class="comment">//a被累加两次</span></span><br><span class="line">CALL_WITH_MAX(++a,b+<span class="number">10</span>);  <span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;幸运的是我们可以避免这种让人火大的事情发生。我们可以享受宏带来的效率以及一般函数的所有可预料行为和类型安全——只要我们写出template inline函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个template产出一个组函数，每个函数都接受两个同型对象，并以其中较大者调用f。此外这里的callWithMax是个真正的函数，它遵循作用域和访问规则。例如我们绝对可以写出一个“class内的private inline函数”。一般而言宏无法完成此事。</p>
<p>&emsp;&emsp;有了consts、enums和inlines，我们对于预处理器的需求降低了，但并非完全消除。#include仍然是必需品，而#ifdef／#ifndef也继续扮演着控制编译的重要角色。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li><p>对于单纯变量，最好以const对象或enum替换#define。</p>
</li>
<li><p>对于形似函数的宏，最好改用inline函数替换#define。</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽量少做转型动作</title>
    <url>/2020/08/08/%E5%B0%BD%E9%87%8F%E5%B0%91%E5%81%9A%E8%BD%AC%E5%9E%8B%E5%8A%A8%E4%BD%9C/</url>
    <content><![CDATA[<hr>
<h1 id="尽量少做转型动作"><a href="#尽量少做转型动作" class="headerlink" title="尽量少做转型动作"></a>尽量少做转型动作</h1><p>&emsp;&emsp;C++规则的设计目标之一是，保证“类型错误”绝不可能发生。理论上如果你的程序很“干净地”通过编译，就表示它并不企图在任何对象身上执行任何不安全、无意义、愚蠢荒谬的操作。这是个极具价值的保证，可别草率地放弃它。</p>
<p>&emsp;&emsp;不幸的是，转型破坏了类型系统。那可能导致任何种类的麻烦，有些容易辨识，有些非常隐晦。如果你来自C，Java或C#阵营，请特别注意，因为那些语言中的转型比较必要而无法避免，也比较不危险（与C++相较）。但C++不是C，也不是Java或C#。在C++中转型是一个你会想带着极大尊重去亲近的一个特性。</p>
<a id="more"></a>

<p>&emsp;&emsp;让我们首先回顾转型语法，因为通常有三种不同的形式，可写出相同的转型动作。C风格的转型动作看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(T)expression  <span class="comment">//将expression转型为T</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;函数风格的转型动作看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T(expression)  <span class="comment">//将expression转型为T</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;两种形式并无差别，纯粹只是小括号的摆放位置不同而已。为称此二种形式为“旧式转型”。</p>
<p>&emsp;&emsp;C++还提供四种新式转型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">dynamic_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;T&gt;( expression )</span><br><span class="line"><span class="keyword">static_cast</span>&lt;T&gt;( expression )</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;各有不同的目的：</p>
<ul>
<li>const_cast通常被用将对象的常量性转除。它也是唯一有此能力的C++-style转型操作符。</li>
<li>dynamic_cast主要用来执行“安全向下转型”，也就是用来决定对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能消耗重大运行成本低转型动作。</li>
<li>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编译器，这也就表示它不可移植。例如将一个pointer to int转型为一个int。这一类转型在低级代码以外很少见。</li>
<li>static_cast用来强迫隐式转换，例如将non-const对象转为const对象，或将int转为double等等。它也可以用来执行上述多种转换的反向转换，例如将void*指针转为typed指针，将pointer-to-derived转为pointer-to-base。但它无法将const转为non-const——这个只有const_cast才办得到。</li>
</ul>
<p>&emsp;&emsp;旧式转型仍然合法，但新式转型较受欢迎。原因是：第一，它们很容易在代码中被辨识出来，因而得以简化“找出类型系统在哪个地点被破坏”的过程。第二，各种转型动作的目标愈窄化，编译器愈可能诊断出错误的运用。举个例子，如果你打算将常量性去掉，除非使用新式转型中的const_cast否则无法通过编译。</p>
<p>&emsp;&emsp;我唯一使用旧式转型的时机是，当为要调用一个explicit构造函数将一个对象传递给一个函数时。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeWork</span><span class="params">(<span class="keyword">const</span> Widget&amp; w)</span></span>;</span><br><span class="line"></span><br><span class="line">doSomeWork(Widget(<span class="number">15</span>));               <span class="comment">//以一个int加上“函数风格”的转型动作创建一个Widget</span></span><br><span class="line"></span><br><span class="line">doSomeWork(<span class="keyword">static_cast</span>&lt;Widget&gt;(<span class="number">15</span>));  <span class="comment">//以一个int加上“C++风格”的转型动作创建一个Widget</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从某个角度来说，蓄意的“对象生成”动作感觉不怎么像“转型”，所以我很可能使用函数风格的转型而不适用static_cast。但我要再说一次，当我我们写下一段日后出错导致“core dump”的代码时，撰写之时我们往往“觉得”通情达理，所以或许最好是忽略你的感觉，始终理智地使用新式转型。</p>
<p>&emsp;&emsp;许多程序员相信，转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型。这是错误的概念。任何一个类型转换往往真的令编译器编译出运行期间执行的码。例如在这段程序中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(x) / y;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;将int x转型为double几乎肯定会产生一些代码，因为在大部分计算器体系结构中，int的底层表述不同于double的底层表述。这或许不会让你惊讶，但下面这个例子就有可能让你稍微睁大眼睛了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base* pb = &amp;d;  <span class="comment">//隐喻地将Derived*转换为Base*</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里我们不过是建立一个base class指针指向一个derived class对象，但有时候上述的两个指针值并不相同。这种情况下会有个偏移量在运行期被施行于Derived*指针身上，用以取得正确的Base*指针值。</p>
<p>&emsp;&emsp;上个例子表明，单一对象（例如一个类型为Derived的对象）可能拥有一个以上的地址（例如“以Base*指向它”时的地址和“以Derived*指向它”时的地址。）。C不可能发生这种事，Java不可能发生这种事，C#也不可能发生这种事。但C++可能！实际上一旦使用多重继承，这事几乎一直发生着。即使在单一继承中也可能发生。虽然这还有其它涵义但至少意味你通常应该避免做出“对象在C++中如何如何布局”的假设。当然更不该以此假设为基础执行任何转型动作。例如，将对象地址转型为char*指针然后在它们身上进行指针算术。几乎总是会导致无定义行为。</p>
<p>&emsp;&emsp;但请注意，我说的是有时候需要一个偏移量。对象的布局方式和它们的地址计算方式随编译器的不同而不同，那意味着“由于知道对象如何布局”而设计的转型，在某一平台行得通，在其它平台不一定行得通。这个世界有许多悲惨的程序员，他们历尽千辛万苦才学到这个教训。</p>
<p>&emsp;&emsp;另一件关于转型的有趣事情是：我们很容易写出某些似是而非的代码。例如许多应用框架都要求derived class内的virtual函数代码的第一个动作就先调用base class的对应函数。假设我们有个Window base class和一个SpecialWindow derived class，两者都定义了virtual函数onResize。进一步假设SpecialWindow的onResize函数被要求首先调用Window的onResize。下面是实现方式之一，它看起来对，但实际上错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Windwo&gt;(*<span class="keyword">this</span>).onResize();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我在代码中强调了转型动作。一如你所预期，这段程序将*this转型为Window，对函数onResize的调用也因此调用了Window::onResize。但恐怕你没想到，它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个“*this对象之base class成分”的暂时副本身上的onResize！再说一次，上述代码并非在当前对象身上调用Window::onResize之后又在该对象身上执行SpecialWindow专属动作。如果Window::onResize修改了对象内容（不能说没有可能性，因为onResize是个non-const成员函数），当前对象其实没被改动，改动的是副本。然而SpecialWindow::onResize内如果也修改对象，当前对象真的会被改动，这使当前对象进入一种“伤残”状态：其base class成分的更改没有落实，而derived class成分倒是落实。</p>
<p>&emsp;&emsp;解决之道是拿掉转型动作，代之以你真正想说的话。你并不想哄编译器将*this视为一个base class对象，你只是想调用base class版本的onResize函数，令它作用于当前对象身上，所以请这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Window::onResize();  <span class="comment">//调用Window::onResize作用于*this身上</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个例子也说明，如果你发现你自己打算转型，那活脱是个警告信号：你可能正将局面发展至错误的方向上。如果你用的是dynamic_cast更是如此。</p>
<p>&emsp;&emsp;在探究dynamic_cast设计意涵之前，值得注意的是，dynamic_cast的许多实现版本执行速度相当慢。例如至少有一个很普遍的实现版本基于“class名称之字符串比较”，如果你在四层深的单继承体系内的某个对象身上执行dynamic_cast，刚才说的那个实现版本所提供的每一次dynamic_cast可能会耗用多达四次的strcmp调用，用以比较class名称。深度继承或多重继承的成本更高！某些实现版本这样做是有其原因（它们必须支持动态连接）。然而我还是要强调，除了对一般转型保持机敏与猜疑，更应该在注重效率的代码中对dynamic_cast保持机敏与猜疑。</p>
<p>&emsp;&emsp;之所以需要dynamic_cast，通常是因为你想在一个你认定为derived class对象身上执行derived class操作函数，但你手上却只有一个“指向base”的pointer或reference，你只能靠它们来处理对象。有两个一般性做法可以避免这个问题。</p>
<p>&emsp;&emsp;第一，使用容器并在其中存储直接指向derived class对象的指针（通常是智能指针），如此便消除了“通过base class接口处理对象”的需要。假设先前的Window/SpecialWindow继承体系中只有SpecialWindow才支持闪烁效果，试着不要这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span>(VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();</span><br><span class="line">      iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">      <span class="keyword">if</span>(SpecialWindow* psw = <span class="keyword">dynamic_cast</span>&lt;SpecialWindow*&gt;(iter-&gt;<span class="built_in">get</span>()))</span><br><span class="line">          psw-&gt;<span class="built_in">blink</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>应该改而这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SpecialWindow&gt; &gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPSW::iterator iter = winPtrs.<span class="built_in">begin</span>();  <span class="comment">//这样写比较好</span></span><br><span class="line">    iter != winPtrs.<span class="built_in">end</span>(); ++iter)          <span class="comment">//不使用dynamic_cast</span></span><br><span class="line">(*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然啦，这种做法使你无法在同一个容器内存储指针“指向所有可能之多种Window派生类”。如果真要处理多种窗口类型，你可能需要多个容器，它们都必须具备类型安全性。</p>
<p>&emsp;&emsp;另一种做法可让你通过base class接口处理“所有可能之各种window派生类”，那就是在base class内提供virtual函数做你想对各个Window派生类做的事。举个例子，虽然只有SpecialWindow可以闪烁，但或许将闪烁函数声明于base class内并提供一份“什么也没做”的缺省实现代码是有意义的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">//缺省实现代码“什么也没做”</span></span><br><span class="line">    ...                      <span class="comment">//缺省实现代码可能是个馊主意</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialWindow</span>:</span> <span class="keyword">public</span> Window &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">blink</span><span class="params">()</span> </span>&#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::share_ptr&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();</span><br><span class="line">    iter != winPtrs.<span class="built_in">end</span>();</span><br><span class="line">    ++iter)</span><br><span class="line">(*iter)-&gt;<span class="built_in">blink</span>();</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不论哪种写法——“使用类型安全容器”或“将virtual函数往继承体系上方移动”——都并非放之四海而皆准，但在许多情况下它们都提供一个可行的dynamic_cast替代方案。当它们有此功效时，你应该欣然拥抱它们。</p>
<p>&emsp;&emsp;绝对必须避免的一件事是所谓的“连串dynamic_cast”，也就是看起来像这样的东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> &#123;</span> ... &#125;;</span><br><span class="line">...  <span class="comment">//derived class定义在这里</span></span><br><span class="line"><span class="keyword">typedef</span> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Window&gt; &gt; VPW;</span><br><span class="line">VPW winPtrs;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(VPW::iterator iter = winPtrs.<span class="built_in">begin</span>();</span><br><span class="line">    iter != winPtrs.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    <span class="keyword">if</span>(SpecialWindow1* psw1 =</span><br><span class="line">       <span class="keyword">dynamic_cast</span>&lt;SpecialWindow1*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(SpecialWindow2* psw2 =</span><br><span class="line">            <span class="keyword">dynamic_cast</span>&lt;SpecialWindow2*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(SpecialWindow3* psw3 =</span><br><span class="line">            <span class="keyword">dynamic_cast</span>&lt;SpecialWindow3*&gt;(iter-&gt;<span class="built_in">get</span>())) &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样生产出来的代码又大又慢，而且基础不稳，因为每次Window class继承体系一有改变，所有这一类代码都必须再次检阅看看是否需要修改。例如一旦加入新的derived class，或许上述连串判断中需要加入新的条件分支。这样的代码应该总是以某些“基于virtual函数调用”的东西取而代之。</p>
<p>&emsp;&emsp;优良的C++代码很少使用转型，但若说要完全摆脱它们又太过不切实际。例如之前的例子从int转型为double就是转型的一个通情达理的使用，虽然它并非绝对必要（那段代码可以重新写过，声明一个类型为double的新变量并以x值初始化）。就像面对众多蹊跷可疑的构造函数一样，我们应该尽可能隔离转型动作，通常是把它隐藏在某个函数内，函数的接口会保护调用者不受函数内部任何肮脏龌龊的动作影响。</p>
<blockquote>
<p>如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。</p>
<p>如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进它们自己的代码内。</p>
<p>宁可使用C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较又着分门别类的职掌。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>尽量延后变量定义式的出现时间</title>
    <url>/2020/08/07/%E5%B0%BD%E9%87%8F%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<hr>
<h1 id="尽量延后变量定义式的出现时间"><a href="#尽量延后变量定义式的出现时间" class="headerlink" title="尽量延后变量定义式的出现时间"></a>尽量延后变量定义式的出现时间</h1><p>&emsp;&emsp;只要你定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。即使这个变量最终并未被使用，仍需耗费这些成本，所以你应该尽可能避免这种情形。</p>
<p>&emsp;&emsp;或许你会认为，你不可能定义一个不使用的变量，但话不要说得太早！考虑下面这个函数，它计算通行密码的加密版本而后返回，前提是密码够长。如果密码太短，函数会丢出一个异常，类型为logic_error：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数过早定义变量“encrypted”</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="built_in">string</span> encrypted;</span><br><span class="line">    <span class="keyword">if</span>(password.length() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">"Password is too short"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...  <span class="comment">//必要动作，将一个加密后的密码置入变量encrypted内</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对象encrypted在此函数中并非完全未被使用，但如果有个异常被丢出，它就真的没被使用。也就是说如果函数encryptPassword丢出异常，你仍得付出encrypted的析构成本和构造成本。所以最好延后encrypted的定义式，直到确实需要它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个函数延后“encrypted”的定义，直到真正需要它</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span>(password.length() &lt; MinimumPasswordLength) &#123;</span><br><span class="line">        <span class="keyword">throw</span> logic_error(<span class="string">"Password is too shrot"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> encrypted;</span><br><span class="line">    ...  <span class="comment">//必要动作，将一个加密后的密码置入变量encrypted内</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是这段代码仍然不够秾纤合度，因为encrypted虽获定义却无任何实参作为初值。这意味调用的是其default构造函数。许多时候你该对对象做的第一件事就是给它个值，通常是通过一个赋值动作达成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//终于，这是定义并初始化encrypted的最佳做法</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encryptPassword</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; password)</span> </span>&#123;</span><br><span class="line">    ...                               <span class="comment">//检查长度</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">encrypted</span><span class="params">(password)</span></span>;  <span class="comment">//通过copy构造函数定义并初始化</span></span><br><span class="line">    encrypt(encrypted);               <span class="comment">//在encrypt函数内对其加密</span></span><br><span class="line">    <span class="keyword">return</span> encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这让我们联想起所谓“尽可能延后”的真正意义。你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。如果这样，不仅能够避免构造（和析构）非必要对象，还可以避免无意义的default构造行为。更深一层说，以“具明显意义之初值”将变量初始化，还可以附带说明变量的目的。</p>
<p>&emsp;&emsp;“但循环怎么办？”你可能会感到疑惑。如果变量只在循环内使用，那么把它定义于循环外并在每次循环迭代时赋值给它比较好，还是该把它定义于循环内？也就是说下面两个一般性结构，哪一个比较好？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法A</span></span><br><span class="line">Widget w;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    w = i;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法B</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="function">Widget <span class="title">w</span><span class="params">(i)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在Widget函数内部，以上两种写法的成本如下：</p>
<ul>
<li>做法A：1个构造函数 + 1个析构函数 + n个赋值操作</li>
<li>做法B：n个构造函数 + n个析构函数</li>
</ul>
<p>&emsp;&emsp;如果class的一个赋值成本低于一组构造+析构成本，做法A大体而言比较高效。尤其当n值很大时。否则做法B或许较好。此外做法A造成名称w的作用域（覆盖整个循环）比做法B更大，有时那对程序的可理解性和易维护性造成冲突。因此除非（1）你知道赋值成本比“构造+析构”成本低，（2）你正在处理代码中效率高度敏感的部分，否则你应该使用做法B。</p>
<blockquote>
<p>尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>必须返回对象时，别妄想返回其reference</title>
    <url>/2020/08/02/%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/</url>
    <content><![CDATA[<hr>
<h1 id="必须返回对象时，别妄想返回其reference"><a href="#必须返回对象时，别妄想返回其reference" class="headerlink" title="必须返回对象时，别妄想返回其reference"></a>必须返回对象时，别妄想返回其reference</h1><p>&emsp;&emsp;一旦程序员领悟了pass-by-value的效率牵连层面，往往变成十字军战士，一心一意根除pass-by-value带来的种种邪恶。在坚定追求pass-by-reference的纯度中，他们一定会犯下一个致命错误：开始传递一些reference指向并不存在的对象。这可不是件好事。</p>
<a id="more"></a>

<p>&emsp;&emsp;考虑一个用以表现有理数的class，内含一个函数用来计算两个有理数的乘积：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>,</span><br><span class="line">             <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> n, d;  <span class="comment">//分子和分母</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                                    <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个版本的operator*是以by value方式返回其计算结果（一个对象）。如果我们完全不担心该对象的构造和析构成本，我们其实是明显逃避了我们的专业责任。若非必要，没有人会想要为这样的对象付出太多代价，问题是需要付出任何代价吗？</p>
<p>&emsp;&emsp;如果可以改而传递reference，就不需付出代价。但是记住，所谓reference只是个名称，代表某个既有对象。任何时候看到一个reference声明式，我们都应该立刻问自己，它的另一个名称是什么？因为它一定是某物的另一个名称。以上述operator*为例，如果它返回一个reference，后者一定指向某个既有的Rational对象，内含两个Rational对象的乘积。</p>
<p>&emsp;&emsp;我们当然不可能期望这样一个（内含乘积的）Rational对象在调用operator*之前就存在，也即是说，如果有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">b</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">Rational c = a * b;</span><br></pre></td></tr></table></figure>

<p>期望“原本就存在一个其值为3/10点Rational对象”并不合理。如果operator*要返回一个reference指向此数值，它必须自己创建那个对象。</p>
<p>&emsp;&emsp;函数创建对象的途径有二：在stack空间或在heap空间创建之。如果定义一个local变量，就是在stack空间创建对象。根据这个策略写operator*如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                           <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="function">Rational <span class="title">result</span><span class="params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;  <span class="comment">//警告！糟糕的代码</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以拒绝这种做法，因为我们的目标是避免调用构造函数，而result却必须像任何对象一样地由构造函数构造起来。更严重的是：这个函数返回一个reference指向result，但result是个local对象，而local对象在函数退出前被销毁了。因此，这个版本的operator*并未返回reference指向某个Rational，它返回的reference指向一个“从前的”Rational：一个曾经被当作Rational但如今已经成空、发臭、败坏的残骸，因为它已经被销毁了。任何调用者甚至只是对此函数的返回值做任何一点点运用，都将立刻坠入“无定义行为”的恶地。事情的真相是，任何函数如果返回一个reference指向某个local对象，都将一败涂地。（如果函数返回指针指向一个local对象，也是一样）。</p>
<p>&emsp;&emsp;于是，让我们考虑在heap内构造一个对象，并返回reference指向它。Heap-base对象由new创建，所以我们得写出一个heap-based operator*如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                          <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    Rational* result = <span class="keyword">new</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们还是必须付出一个“构造函数调用”代价，因为分配所得的内存将以一个适当的构造函数完成初始化动作。但此外你现在又有了另一个问题：谁该对着被你new出来的对象实施delete？</p>
<p>&emsp;&emsp;即使调用者诚实谨慎，并且出于良好意识，他们还是不太能够在这样合情合理的用法下阻止内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里，同一语句内调用了两次operator*，因而两次使用new，也就需要两次delete。但却没有合理的办法让operator*使用者进行那些delete调用，因为没有合理的办法让他们取得operator*返回的reference背后隐藏的那个指针。这绝对导致资源泄漏。</p>
<p>&emsp;&emsp;但或许你注意到了，上述不论on-the-stack或on-the-heap做法，都因为对operator*返回的结果调用构造函数而受惩罚。或许你心里出现下面这样的实现代码，此法基于“让operator*返回的reference指向一个被定义于函数内部的static Rational对象”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Rational&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                          <span class="keyword">const</span> Rational&amp; rhs) &#123;  <span class="comment">//警告！又一堆烂代码</span></span><br><span class="line">    <span class="keyword">static</span> Rational result;                       <span class="comment">//static对象，此函数返回其reference</span></span><br><span class="line">    result = ...;                                 <span class="comment">//将lhs乘以rhs，并将结果置于result内</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;就像所有用上static对象的设计一样，这一个也立刻造成我们对多线程安全性的疑虑。不过那还只是它显而易见的弱点。如果想看看更深层的瑕疵，考虑下面这些完全合理的客户代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Rational&amp; lhs,</span><br><span class="line">                <span class="keyword">const</span> Rational&amp; rhs);</span><br><span class="line">Rational a, b, c, d;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>((a * b) == (c * d)) &#123;</span><br><span class="line">    <span class="comment">//当乘积相等时，做适当的相应动作；</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//当乘积不等时，做适当的相应动作；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;猜想怎么着？表达式（（a * b）==（c * d））总是被核算为true，不论a，b，c，d的值是什么！</p>
<p>&emsp;&emsp;一旦将代码重新写为等价的函数形式，很容易就可以了解了出什么意外：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="keyword">operator</span>*(a, b), <span class="keyword">operator</span>*(c, d)))</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在operator==被调用前，已有两个operator*调用式起作用，每一个都返回reference指向operator*内部定义的static Rational对象。因此operator==被要求将“operator*内的static Rational对象值”拿来和“operator*内的static Rational对象值”比较，如果比较结果不相等，那才奇怪呢。（两次operator*调用的确各自改变了static Rational对象值，但由于它们返回的都是reference，因此调用端看到的永远是static Rational对象的“现值”）</p>
<p>&emsp;&emsp;这应该足够说服你，欲令诸如operator*这样的函数返回reference，只是浪费时间而已，但现在或许又有些人这样想：“如果一个static不够，或许一个static array可以得分……”。</p>
<p>&emsp;&emsp;我不打算再次写出示例来驳斥这个想法以彰显自己多么厉害，但我可以简单描述为什么你该为了提出这个念头而脸红。首先你必须选择array大小n。如果n太小，你可能会耗尽“用以存储函数返回值”的空间，那么情况就回到了我们刚才讨论过的单一static设计。但如果n太小，会因此降低程序效率，因为array内的每一个对象都会在函数第一次被调用时构造完成。那么将消耗n个构造函数和n个析构函数——即使我们所讨论的函数只被调用一次。如果所谓“最优化”是改善软件效率的过程，我们现在所谈的这些应该成为“恶劣化”。最后，想一想如何将你需要的值放进array内，而那么做的成本又是多少。在对象之间搬移数值的最直接办法是通过赋值操作，但赋值的成本几何？对许多type而言它相当于调用一个析构函数（用以销毁旧值）加上一个构造函数（用以复制新值）。但你的目标是避免构造和析构成本耶！面对现实吧，这个做法不会成功的。就算以vector替换array也不会让情况更好些。</p>
<p>&emsp;&emsp;一个“必须返回新对象”的函数的正确写法是：就让那个函数返回一个新对象呗。对Rational的operator*而言意味以下写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lhs, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，我们需要承受operator*返回值的构造成本和析构成本，然而长远来看那只是为了获得准确行为而付出的一个小小代价。但万一账单很恐怖，我们承受不起，别忘了C++和所有编程语言一样，允许编译器实现者施行最优化，用以改善产出码的效率却不改变其可观察的行为。因此某些情况下operator*返回值的构造和析构可被安全地消除。如果编译器运用这一事实（它们也往往如此），我们的程序将继续保持它们该有的行为，而执行起来又比预期的更快。</p>
<p>&emsp;&emsp;当必须在“返回一个reference和返回一个object”之间抉择时，我们的工作就是挑出行为正确的那个。就让编译器厂商为“尽可能降低成本”鞠躬尽瘁吧，我们可以享受我们的生活。</p>
<blockquote>
<p>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>成对使用new和delete时要采取相同形式</title>
    <url>/2020/07/30/%E6%88%90%E5%AF%B9%E4%BD%BF%E7%94%A8new%E5%92%8Cdelete%E6%97%B6%E8%A6%81%E9%87%87%E5%8F%96%E7%9B%B8%E5%90%8C%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<hr>
<h1 id="成对使用new和delete时要采取相同形式"><a href="#成对使用new和delete时要采取相同形式" class="headerlink" title="成对使用new和delete时要采取相同形式"></a>成对使用new和delete时要采取相同形式</h1><p>&emsp;&emsp;以下动作有什么错？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringArray = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringArray;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每件事看起来都井然有序。使用了new，也搭配了对应的delete。但还是有某样东西完全错误：我们的程序未定义。stringArray所含的100个string对象中的99个不太可能被适当删除，因为它们的析构函数很可能没被调用。</p>
<a id="more"></a>

<p>&emsp;&emsp;当我们使用new（也就是通过new动态生成一个对象），有两件事发生。第一，内存被分配出来（通过名为operator new的函数）。第二，针对此内存会有一个（或更多）构造函数被调用。当我们使用delete，也会有两件事发生：针对此内存会有一个（或更多）析构函数被调用，然后内存才被释放（通过名为operator delete的函数）。delete的最大问题在于：即将被删除的内存之内究竟存有多少对象？这个问题的答案决定了有多少个析构函数必须被调用起来。</p>
<p>&emsp;&emsp;实际上这个问题可以更简单些：即将被删除的那个指针，所指的是单一对象或对象数组？这是个必不可缺的问题，因为单一对象的内存布局一般而言不同于数组的内存布局。更明确地说，数组所用的内存通常还包括“数组大小”的纪录，以便delete知道需要调用多少次析构函数。单一对象的内存则没有这笔纪录。</p>
<p>&emsp;&emsp;当我们对着一个指针使用delete，唯一能够让delete知道内存中是否存在一个“数组大小纪录”的办法就是：由我们来告诉它。如果我们使用delete时加上方括号，delete便认定指针指向一个数组，否则它便认定指针指向单一对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr1 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* stringPtr2 = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> stringPtr1;</span><br><span class="line"><span class="keyword">delete</span>[] stringPtr2;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个规则对于喜欢使用typedef的人也很重要，因为它意味着typedef的作者必须说清楚，当程序员以new创建该种typedef类型对象时，该以哪一种delete形式删除之，考虑下面这个typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> AddressLines[<span class="number">4</span>];  <span class="comment">//每个人的地址有4行</span></span><br><span class="line">                                      <span class="comment">//每一行是一个string</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于AddressLines是个数组，如果这样使用new：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>* pal = <span class="keyword">new</span> AddressLines;  <span class="comment">//注意，"new AddressLines"返回一个string*</span></span><br><span class="line">                                      <span class="comment">//就像"new string[4]"一样</span></span><br></pre></td></tr></table></figure>

<p>这就必须匹配“数组形式”的delete：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> pal;    <span class="comment">//未定义</span></span><br><span class="line"><span class="keyword">delete</span>[] pal;  <span class="comment">//很好</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为避免诸如此类的错误，最好尽量不要对数组形式做typedef动作。例如我们可以将本例的AddressLines定义为“由string组成的一个vector”，也就是其类型为vector&lt;string&gt;。</p>
<blockquote>
<p>如果我们在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果我们在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>控制进程终止的函数</title>
    <url>/2021/05/10/%E6%8E%A7%E5%88%B6%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h1><p>&emsp;&emsp;进程有5种正常终止以及3种异常终止方式。5种正常终止方式具体如下。</p>
<a id="more"></a>

<ol>
<li>在main函数内执行return语句。这等效于exit。</li>
<li>调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序（终止处理程序在调用atexit函数时登记），然后关闭所有标准I/O流等。因为ISO C并不处理文件描述符、多进程（父进程和子进程）以及作业控制，所以这一定义对UNIX系统而言是不完整的。</li>
<li>调用_exit或_Exit函数。ISO C定义_Exit，其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对标准I/O流是否进行冲洗，这取决于实现。在UNIX系统中，_Exit和_exit是同义的，并不冲洗标准I/O流。_exit函数由exit调用，它处理UNIX系统特定的细节。_exit是由POSIX.1说明的。</li>
</ol>
<blockquote>
<p>在大多数UNIX系统实现中，exit(3)是标准C库中的一个函数，而_exit(2)则是一个系统调用。</p>
</blockquote>
<ol start="4">
<li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用作进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回。</li>
<li>进程的最后一个线程调用<code>pthread_exit</code>函数。如同前面一样，在这种情况中，进程终止状态总是0，这与传送给<code>pthread_exit</code>的参数无关。</li>
</ol>
<p>&emsp;&emsp;3种异常终止具体如下。</p>
<ol>
<li>调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例。</li>
<li>当进程接收到某些信号时。信号可由进程自身（如调用abort函数）、其他进程或内核产生。例如，若进程引用进程地址空间之外的存储单元、或者除以0，内核就会为该进程产生相应的信号。</li>
<li>最后一个线程要求取消另一个线程，若干时间之后，目标线程终止。</li>
</ol>
<p>&emsp;&emsp;不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开的描述符，释放它们所使用的存储器等。</p>
<p>&emsp;&emsp;对于上述任意一种终止情况，我们都希望终止进程能够通知父进程它是如何终止的。对于3个终止函数（exit、_exit和_Exit），实现这一点的方法是，将其退出状态作为参数传送给函数。在异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态。在任意一种情况下，该终止进程的父进程都能用wait或waitpid函数取得其终止状态。</p>
<p>&emsp;&emsp;注意，这里使用了“退出状态”（它是传递给向3个终止函数的参数，或main的返回值）和“终止状态”两个术语，以表示有所区别。在最后调用_exit时，内核将退出状态转换成终止状态。如果子进程正常终止，则父进程可以获得子进程的退出状态。</p>
<h1 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h1><p>&emsp;&emsp;在“<a href="/2021/05/03/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84fork%E5%87%BD%E6%95%B0/" title="创建进程的fork函数">创建进程的fork函数</a>”说明了fork函数，显而易见，子进程是在父进程调用fork后生成的。上面又说明了子进程将其终止状态返回给父进程。但是父进程在子进程之前终止，又将如何？其回答是：对于父进程已经终止的所有进程，它们的父进程都改变为init进程。我们称这些进程由init进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1（init进程的ID）。这种处理方法保证了每个进程有一个父进程。</p>
<h1 id="僵死进程"><a href="#僵死进程" class="headerlink" title="僵死进程"></a>僵死进程</h1><p>&emsp;&emsp;另一个我们关心的情况是，如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时，可以得到这些信息。这些信息至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX术语中，一个已经终止、但是其父进程尚未对其做善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵死进程（zombie）。ps(1)命令将僵死进程的状态打印为Z。如果编写一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程。</p>
<p>&emsp;&emsp;最后一个要考虑的问题是：一个由init进程收养的进程终止时会发生什么？它会不会变成一个僵死进程？对此问题的答案是“否”，因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态。这样也就防止了在系统中塞满僵死进程。当提及“一个init的子进程”时，这指的可能是init直接产生的进程，也可能是其父进程已终止，由init收养的进程。</p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>线程进程</tag>
      </tags>
  </entry>
  <entry>
    <title>明智而审慎地使用private继承</title>
    <url>/2020/11/12/%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<hr>
<h1 id="明智而审慎地使用private继承"><a href="#明智而审慎地使用private继承" class="headerlink" title="明智而审慎地使用private继承"></a>明智而审慎地使用private继承</h1><p>&emsp;&emsp;条款“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”曾经论证过C++如何将public继承视为is-a关系。在那个例子中我们有个继承体系，其中class Student以public形式继承class Person，于是编译器在必要时刻（为了让函数调用成功）将Student暗自转换为Person。现在我再重复该例的一部分，并以private继承替换public继承：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">private</span> Person &#123; ... &#125;;  <span class="comment">//这次改用private继承</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;               <span class="comment">//任何人都会吃</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;            <span class="comment">//只有学生才在校学习</span></span><br><span class="line"></span><br><span class="line">Person p;                                <span class="comment">//p是人</span></span><br><span class="line">Student s;                               <span class="comment">//s是学生</span></span><br><span class="line"></span><br><span class="line">eat(p);                                  <span class="comment">//没问题，p是人，会吃。</span></span><br><span class="line">eat(s);                                  <span class="comment">//错误！难道学生不是人？！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;显然private继承并不意味is-a关系。那么它意味什么？</p>
<p>&emsp;&emsp;到底private继承的行为如何呢？如果class之间的继承关系是private，编译器不会自动地将一个derived class对象转换为一个base对象。这和public继承的情况不同。这也就是为什么通过s调用eat会失败的原因。第二条规则是，由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或public属性。</p>
<p>&emsp;&emsp;现在让我们开始讨论其意义。private继承意味implemented-in-terms-of（根据某物实现出）。如果你让class D以private形式继承class B，你的用意是为了采用class B内已经备妥的某些特性，不是因为B对象和D对象存在任何观念上的关系。private继承纯粹只是一种实现技术（这就是为什么继承自一个private base class的每样东西在你的class内都是private：因为它们都只是实现枝节而已）。借用条款“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”提出的术语，private继承意味只有实现部分被继承，接口部分应略去。如果D以private形式继承B，意思是D对象根据B对象实现而得，再没有其他意涵了。private继承在软件“设计”层面上没有意义，其意义只及于软件实现层面。</p>
<p>&emsp;&emsp;private继承意味is-implemented-in-terms-of（根据某物实现出），这个事实有点令人不安，因为复合（composition）的意义也是如此。如何在两者之间取舍？答案很简单：尽可能使用复合，必要时才使用private继承。何时才是必要？主要是当protected成员和／或virtual函数牵扯进来的时候。其实还有一种激进的情况，那是当空间方面的利害关系足以踢翻private继承的支柱时。稍后我们再来操这个心，毕竟它只是一种激进情况</p>
<p>&emsp;&emsp;假设我们的程序涉及Widget，而我们决定应该较好地了解如何使用Widget，例如我们不只想要知道Widget成员函数多么频繁地被调用，也想知道经过一段时间后调用比例如何变化。要知道，带有多个执行阶段的程序，可能在不同阶段拥有不同的行为轮廓。例如编译器在解析阶段所用的函数，大大不同于在最优化和代码生成阶段所使用的函数。</p>
<p>&emsp;&emsp;我们决定修改Widget class，让它记录每个成员函数的被调用次数。运行期间，我们将周期性地审查那份信息，也许再加上每个Widget的值，以及我们需要评估的任何其他数据。为了完成这项工作，我们需要设定某种定时器，使我们知道收集统计数据的时候是否到了。</p>
<p>&emsp;&emsp;我们宁可复用既有代码，尽量少写新代码，所以在自己的工具百宝箱中翻箱倒柜，并且很开心地发现了这个class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Timer</span><span class="params">(<span class="keyword">int</span> tickFrequency)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//定时器每滴答一次，</span></span><br><span class="line">        ...                           <span class="comment">//此函数就被自动调用一次。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这就是我们找到的东西。一个Timer对象，可调整为以我们需要的任何频率滴答前进，每次滴答就调用某个virtual函数。我们可以重新定义那个virtual函数，让后者取出Widget的当时状态。完美！</p>
<p>&emsp;&emsp;为了让Widget重新定义Timer内的virtual函数，Widget必须继承自Timer。但public继承在此例并不适当，因为Widget并不是个Timer。事呀，Widget客户总不该能够对着一个Widget调用onTick把，因为观念上那并不是Widget接口的的一部分。如果允许那样的调用动作，很容易造成客户不正确地使用Widget接口。在这里public继承不是个好策略。</p>
<p>&emsp;&emsp;我们必须以private形式继承Timer：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> :</span> <span class="keyword">private</span> Timer &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//查看Widget的数据等等。</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;藉由private继承，Timer的public onTick函数在Widget内变成private，而我们重新声明（定义）时仍然把它留在那儿。再说一次，把onTick放进public接口内会误导客户端以为他们可以调用它。</p>
<p>&emsp;&emsp;这是个好设计，但不值几文钱，因为private继承并非绝对必要。如果我们决定以复合取而代之，是可以的。只要在Widget内声明一个嵌套式private class，后者以public形式继承Timer并重新定义onTick，然后放一个这种类型的对象于Widget内。下面是这种解法的草样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">WidgetTimer</span> :</span> <span class="keyword">public</span> Timer &#123;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">                <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">                ...</span><br><span class="line">        &#125;;</span><br><span class="line">        WidgetTimer timer;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个设计只比使用private继承要复杂一些些，因为它同时涉及public继承和复合，并导入一个新class（WidgetTimer）。坦白说我展示它主要是为了提醒你，解决一个设计问题的方法不只一种，而训练自己思考多种做法是值得的。尽管如此，我可以想出两个理由，为什么你可能愿意（或说应该）选择这样的public继承加复合，而不是选择原先的private继承设计。</p>
<p>&emsp;&emsp;首先，你或许会想设计Wdiget使它得以拥有derived class，但同时你可能会想阻止derived class重新定义onTick。如果Widget继承自Timer，上面的想法就不可能实现，即使是private继承也不可能。（因为derived class可以重新定义virtual函数，即使它们不得调用它。）但如果WidgetTimer是Widget内部的一个private成员并继承Timer，Widget的derived class将无法取用WidgetTimer，因此无法继承它或重新定义它的virtual函数。如果你曾经以Java或C#编程并怀念“阻止derived class重新定义virtual函数”的能力（也就是Java的final和C#的sealed），现在你知道怎么在C++中模拟它了。</p>
<p>&emsp;&emsp;第二，你或许会想要将Widget的编译依存性降低最低。如果Widget继承Timer，当Widget被编译时Timer的定义必须可见，所以定义Widget的那个文件恐怕必须#include Timer.h。但如果WidgetTimer移出Widget之外而Widget内含指针指向一个WidgetTimer，Widget可以只带着一个简单的WidgetTimer声明式，不再需要#include任何与Timer有关的东西。对大型系统而言，如此的解耦可能是重要的措施。关于编译依存性的最小化，详见“<a href="/2020/08/13/%E5%B0%86%E6%96%87%E4%BB%B6%E9%97%B4%E7%9A%84%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB%E9%99%8D%E8%87%B3%E6%9C%80%E4%BD%8E/" title="将文件间的编译依存关系降至最低">将文件间的编译依存关系降至最低</a>”。</p>
<p>&emsp;&emsp;稍早我曾谈到，private继承主要用于“当一个意欲成为derived class者想访问一个意欲成为base class者的protected成分，或为了重新定义一或多个virtual函数”。但这时候两个class之间的概念关系其实是is-implemented-in-terms-of（根据某物实现出）而非is-a。然而我也说过，有一种激进情况涉及空间最优化，可能会促使你选择“private继承”而不是“继承加复合”。</p>
<p>&emsp;&emsp;这个激进情况真是有够激进，只适用于你所处理的class不带任何数据时。这样的class没有non-static成员变量，没有virtual函数（因为这种函数的存在会为每个对象带来一个vptr），也没有virtual base class（因为这样的base class也会招致体积上的额外开销）。于是这种所谓的empty class对象不使用任何空间，因为没有任何隶属对象的数据需要存储。然而由于技术上的理由，C++裁定凡是独立（非附属）对象都必须有非零大小，所以如果你这样做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span> &#125;;    <span class="comment">//没有数据，所以其对象应该不使用任何内存</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt</span> &#123;</span>  <span class="comment">//应该只需要一个int空间</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        Empty e;    <span class="comment">//应该不需要任何内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你会发现sizeof(HoldsAnInt) &gt; sizeof(int)；喔欧，一个Empty成员变量竟然要求内存。在大多数编译器中sizeof(Empty)获得1，因为面对“大小为零之独立对象”，通常C++官方勒令默默安插一个char到空对象内。然而齐位需求可能会造成编译器为类似HoldsAnInt这样的class加上一些衬垫，所以有可能HoldsAnInt对象不止获得一个char大小，也许实际上被放大到足够又存放一个int。在我试过的所有编译器中，的确有这种情况发生。</p>
<p>&emsp;&emsp;但或许你注意到了，我很小心地说“独立（非附属）”对象的大小一定不为零。也就是说，这个约束不适用于derived class内的base class成分，因为它们并非独立（非附属）。如果你继承Empty，而不是内含一个那种类型的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoldsAnInt</span> :</span> <span class="keyword">private</span> Empty &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;几乎可以确定sizeof(HoldsAnInt) == sizeof(int)。这是所谓的EBO（empty base optimization；空白基类最优化），我试过的所有编译器都有这样的结果。如果你是一个程序库开发人员，而你的客户非常在意空间，那么值得注意EBO。另外还值得知道的是，EBO一般只在单一继承（而非多重继承）下才可行，统治C++对象布局的那些规则通常表示EBO无法被施行于“拥有多个base”的derived class身上。</p>
<p>&emsp;&emsp;现实中的“empty”class并不真的是empty。虽然它们从未拥有non-static成员变量，却往往内含typedef，enum，static成员变量，或non-virtual函数。STL就有许多技术用途的empty class，其中内含有用的成员（通常是typedef），包括base class unary_function和binary_function，这些是“用户自定义之函数对象”通常会继承的class。感谢EBO的广泛实践，使这样的继承很少增加derived class的大小。</p>
<p>&emsp;&emsp;尽管如此，让我们回到根本。大多数class并非empty，所以EBO很少成为private继承的正当理由。更进一步说，大多数继承相当于is-a，这是指public继承，不是private继承。复合和private继承都意味is-implemented-in-terms-of，但复合比较容易理解，所以无论什么时候，只要可以，你还是应该选择复合。</p>
<p>&emsp;&emsp;当你面对“并不存在is-a关系”的两个class，其中一个需要访问另一个的protected成员，或需要重新定义一个或多个virtual函数，private继承极有可能成为正统设计策略。即便如此你也已经看到，一个混合了public继承和复合的设计，往往能够满足你要的行为，尽管这样的设计有较大的复杂度。“明智而审慎地使用private继承”意味，在考虑过所有其他方案之后，如果仍然认为private继承是“表现程序内两个class之间的关系”的最佳办法，这才用它。</p>
<blockquote>
<ul>
<li>private继承意味is-implemented-in-terms-of（根据某物实现出）。它通常比复合的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。</li>
<li>和复合不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>明智而审慎地使用多重继承</title>
    <url>/2020/11/13/%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<hr>
<h1 id="明智而审慎地使用多重继承"><a href="#明智而审慎地使用多重继承" class="headerlink" title="明智而审慎地使用多重继承"></a>明智而审慎地使用多重继承</h1><p>&emsp;&emsp;一旦涉及多重继承（MI），C++社群便分为两个基本阵营。其中之一认为如果单一继承（SI）是好的，多重继承一定更好。另一派阵营则主张，单一继承是好的，但多重继承不值得拥有（或使用）。本条款的主要目的是带领大家了解多重继承的两个观点。</p>
<p>&emsp;&emsp;最先需要认清的一件事是，当MI进入设计景框，程序有可能从一个以上的base class继承相同名称（如函数、typedef等等）。那会导致较多的歧义机会。例如：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BorrowableItem</span> &#123;</span>    <span class="comment">//图书馆允许你借某些东西</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">()</span></span>;  <span class="comment">//离开时进行检查</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ElectronicGadget</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">checkOut</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//执行自我检测，返回是否测试成功</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3Player</span> :</span> </span><br><span class="line">    <span class="keyword">public</span> BorrowableItem,</span><br><span class="line">    <span class="keyword">public</span> ElectronicGadget &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">MP3Player mp;</span><br><span class="line">mp.checkOut();  <span class="comment">//歧义！调用的是哪个checkOut？</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意此例之中对checkOut的调用是歧义（模棱两可）的，即使两个函数之中只有一个可取用（BorrowableItem内的checkOut是public，ElectronicGadget内的却是private）。这与C++用来解析重载函数调用的规则相符：在看到是否有个函数可取用之前，C++首先确认这个函数对此调用之言是最佳匹配。找出最佳匹配函数后才检验其可取用性。本例的两个checkOut有相同的匹配程度，没有所谓最佳匹配。因此ElectronicGadget::checkOut的可取用性也就从未被编译器审查。</p>
<p>&emsp;&emsp;为了解决这个歧义，你必须明白指出你要调用哪一个base class内的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mp.BorrowableItem::checkOut();  <span class="comment">//哎呀，原来是这个checkOut</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然你也可以尝试明确调用ElectronicGadget::checkOut，但然后你会获得一个“尝试调用private成员函数”的错误。</p>
<p>&emsp;&emsp;多重继承的意思是继承一个以上的base class，但这些base class并不常在继承体系中又有更高级的base class，因为那会导致要命的“钻石型多重继承”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputFile</span> :</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputFile</span> :</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOFile</span> :</span> <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;任何时候如果你有一个继承体系而其中某个base class和某个derived class之间有一条以上的相通路线（就像上述File和IOFile之间有两条路径，分别穿越InputFile和OutputFile），你就必须面对这样一个问题：是否打算让base class内的成员变量经由每一条路径被复制？假设File class有个成员变量fileName，那么IOFile内该有多少笔这个名称的数据呢？从某个角度说，IOFile从其每一个base class继承一份，所以其对象内应该有两份fileName成员变量。但从另一个角度说，简单的逻辑告诉我们，IOFile对象只该有一个文件名称，所以它继承自两个base class而来的fileName不该重复。</p>
<p>&emsp;&emsp;C++在这场辩论中并没有倾斜立场；两个方案它都支持——虽然其缺省做法是执行复制（也就是上一阶段所说的第一个做法）。如果那不是你要的，你必须令那个带有此数据的class（也就是File）成为一个virtual base class。为了这样做，你必须令所有直接继承自它的class采用“virtual继承”：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputFile</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OutputFile</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> <span class="built_in">File</span> &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOFile</span> :</span> <span class="keyword">public</span> InputFile, <span class="keyword">public</span> OutputFile &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;C++标准程序库内含一个多重继承体系，其结构就如上述那样，只不过其class其实是class template，名称分别是basic_ios，basic_istream，basic_ostream和basic_iostream，而非这里的File，InputFile，OutputFile和IOFile。</p>
<p>&emsp;&emsp;从正确行为的观点看，public继承应该总是virtual。如果这是唯一一个观点，规则很简单：任何时候当你使用public继承，请改用virtual public继承。但是，啊呀，正确性并不是唯一观点。为避免继承得来的成员变量重复，编译器必须提供若干幕后戏法，而其后果是：使用virtual继承的那些class所产生的对象往往比使用non-virtual继承的兄弟们体积大，访问virtual base class的成员变量时，也比访问non-virtual base class的成员变量速度慢。种种细节因编译器不同而异，但基本重点很清楚：你得为virtual继承付出代价。</p>
<p>&emsp;&emsp;virtual继承的成本还包括其他方面。支配“virtual base class初始化”的规则比起non-virtual base的情况远为复杂且不直观。virtual base的初始化责任是由继承体系中的最低层class负责，这暗示（1）class若派生自virtual base而需要初始化，必须认知其virtual base——不论那些base距离多远，（2）当一个新的derived class加入继承体系中，它必须承担其virtual base（不论直接或间接）的初始化责任。</p>
<p>&emsp;&emsp;我对virtual base class（也相当于对virtual继承）的忠告很简单。第一，非必要不使用virtual base。平常请使用non-virtual继承。第二，如果你必须使用virtual base class，尽可能避免在其中放置数据。这么一来你就不需担心这些class身上的初始化（和赋值）所带来的诡异事情了。Java和.NET的Interface值得注意，它在许多方面兼容于C++的virtual base class，而且也不允许含有任何数据。</p>
<p>&emsp;&emsp;现在让我们看看下面这个用来塑模“人”的C++Interface class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~IPerson();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> cosnt </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;IPerson的客户必须以IPerson的的pointer和reference来编写程序，因为抽象class无法被实体化创建对象。为了创建一些可被当作IPerson来使用的对象，IPerson的客户使用factory function（工厂函数）将“派生自IPerson的具象class”实体化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IPerson&gt; <span class="title">makePerson</span><span class="params">(DatabaseID personIdentifier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个函数从使用者手上取得一个数据库ID</span></span><br><span class="line"><span class="function">DatabaseID <span class="title">id</span><span class="params">(askUserForDatabaseID())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IPerson&gt; <span class="title">pp</span><span class="params">(makePerson(id))</span></span>;  <span class="comment">//创建一个对象支持IPerson接口，</span></span><br><span class="line">                                              <span class="comment">//藉由IPerson成员函数处理*pp。</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是makePerson如何创建对象并返回一个指针指向它呢？无疑地一定有某些派生自IPerson的具象class，在其中makePerson可以创建对象。</p>
<p>&emsp;&emsp;假设这个class名为CPerson。就像具象class一样，CPerson必须提供“继承自IPerson”的pure virtual函数的实现代码。我们可以从无到有写出这些东西，但更好的是利用既有组件，后者做了大部分或所有必要事情。例如，假设有个既有的数据库相关class，名为PersonInfo，提供CPeron所需要的实质东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~PersonInfo();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theBirthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你可以说这是个旧式class，因为其成员函数返回const char*而不是string对象。尽管如此，如果鞋子合脚，干嘛不穿它？这个class的成员函数的名称已经暗示我们其结果有可能很令人满意。</p>
<p>&emsp;&emsp;你会发现，PersonInfo被设计用来协助以各种格式打印数据库字段，每个字段值的起始点和结束点以特殊字符串为界。缺省的头尾界限符号是方括号（中括号），所以（例如）字段值“Ring-tailed Lemur”被格式化为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Ring-tailed Lemur]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但由于方括号并非放之四海人人喜爱的界限符号，所以两个virtual函数valueDelimOpen和valueDelimClose允许derived class设定它们自己的头尾界限符号。PersonInfo成员函数将调用这些virtual函数，把适当的界限符号添加到它们的返回值上。以PersonInfo::theName为例，代码看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">PersonInfo::valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"["</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">PersonInfo::valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">PersonInfo::theName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保留缓冲区给返回值使用；由于缓冲区是static，因此会被自动初始化为“全部是0”</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> value[Max_Formatted_Field_Value_Length];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//写入起始符号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcpy</span>(value, valueDelimOpen());</span><br><span class="line">    <span class="comment">//现在，将value内的字符串添附到这个对象的name成员变量中（小心，避免缓冲区超限）</span></span><br><span class="line">    <span class="comment">//写入结尾符号</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">strcat</span>(value, valueDelimClose());</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;或许有人质疑PersonInfo::theName的老旧设计（特别是它竟然使用固定大小的static缓冲区，那将充斥超限问题和线程问题），但是不妨暂时把这样的疑问放两旁，把以下焦点摆中间：theName调用valueDelimOpen产生字符串起始符号，然后产生name值，然后调用valueDelimClose。由于valueDelimOpen和valueDelimClose都是virtual函数，theName返回的结果不仅取决于PersonInfo也取决于从PersonInfo派生下去的class。</p>
<p>&emsp;&emsp;身为CPerson实现者，这是个好消息，因为仔细阅读IPerson文档后，你发现name和birthDate两函数必须返回未经装饰（不带起始符号和结尾符号）的值。也就是说如果有人名为Homer，调用其name函数理应获得“Homer”而不是“[Homer]”。</p>
<p>&emsp;&emsp;CPerson和PersonInfo的关系是，PersonInfo刚好有若干函数可帮助CPerson比较容易实现出来。就这样。它们的关系因此是is-implemented-in-terms-of（根据某物实现出），而我们知道这种关系可以两种技术实现：复合和private继承。复合通常是较受欢迎的做法，但如果需要重新定义virtual函数，那么继承是必要的。本例之中CPerson需要重新定义valueDelimOpen和valueDelimClose，所以单纯的复合无法应付。最直接的解法就是令CPerson以private形式继承PersonInfo。CPerson也可以结合“复合+继承”技术以求有效重新定义PersonInfo的virtual函数。此处我将使用private继承。</p>
<p>&emsp;&emsp;但CPerson也必须实现IPerson接口，那需得以public继承才能完成。这导致多重继承的一个通情达理的应用：将“public继承自某接口”和“private继承自某实现”结合在一起：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPerson</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~IPerson();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseID</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PersonInfo</span><span class="params">(DatabaseID pid)</span></span>;</span><br><span class="line">        <span class="keyword">virtual</span> ~PersonInfo();</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">theBirthDate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPerson</span> :</span> <span class="keyword">public</span> IPerson, <span class="keyword">private</span> PersonInfo &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">CPerson</span><span class="params">(DatabaseID pid)</span> : <span class="title">PersonInfo</span><span class="params">(pid)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> PersonInfo::theName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">birthDate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> PersonInfo::theBirthDate();</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimOpen</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">""</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">valueDelimClose</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">""</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个例子告诉我们，多重继承也有它的合理用途。</p>
<p>&emsp;&emsp;故事结束前，请容我说，多重继承只是面向对象工具箱里的一个工具而已。和单一继承比较，它通常比较复杂，使用上也比较难以理解，所以如果你有个单一继承的设计方案，而它大约等价于一个多重继承设计方案，那么单一继承设计方案几乎一定比较受欢迎。如果你唯一能够提出的设计方案涉及多重继承，你应该更努力想一想——几乎可以说一定会有某些方案让单一继承行得通。然而多重继承有时候的确是完成任务之最简洁、最易维护、最合理的做法，果真如此就别害怕使用它。只要确定，你的确是在明智而审慎地情况下使用它。</p>
<blockquote>
<ul>
<li>多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base class不带任何数据，将是最具实用价值的情况。</li>
<li>多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相组合。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>确定你的public继承塑模出is-a关系</title>
    <url>/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<hr>
<h1 id="确定你的public继承塑模出is-a关系"><a href="#确定你的public继承塑模出is-a关系" class="headerlink" title="确定你的public继承塑模出is-a关系"></a>确定你的public继承塑模出is-a关系</h1><p>&emsp;&emsp;在《Some Must Watch While Some Must Sleep》这本书中，作者William Dement说了一个故事，谈到他曾经试图让学生记下课程中最重要的一些教导。书上说，他告诉他的班级，一般英国学生对于发生在1066年的黑斯廷斯战役所知不多。如果有学生记得多一些，Dement强调，无非也只是记得1066这个数字而已。然后Dement继续其课程，其中只有少数重要信息，包括“安眠药反而造成失眠症”这类有趣的事情。他一再要求学生，纵使忘记了课程中的其他每一件事，也要记住这些数量不多的重要事件。Dement在整个学期中不断耳提面命这样的话。</p>
<p>&emsp;&emsp;课程结束后，期末考的最后一道题是：“写下你从本课程获得的一件永生不忘的事”。当Dement批改试卷，他目瞪口呆。几乎每一个人都写下“1066”。</p>
<a id="more"></a>

<p>&emsp;&emsp;以C++进行面向对象编程，最主要的一个规则是：public inheritance（公开继承）意味“is-a”（是一种）的关系。把这个规则牢牢地烙印在你的心中吧！</p>
<p>&emsp;&emsp;如果你令class D（“derived”）以public形式继承class B（“base”），你便是告诉C++编译器（以及你的代码读者）说，每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。也就是说你的本意是令B比D表现出更为一般化的概念，而D便是特殊化的体现。“任何B对象可派上用场的任何地方，D对象一样可以派上用场”这是C++对于“public继承”的解释。而需要D对象的场合，B对象则不一定会起到作用。</p>
<p>&emsp;&emsp;考虑以下例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;根据生活经验我们知道，每个学生都是人，但并非每个人都是学生。这就是一个public继承体系。我们预期，对人可以成立的每一件事——例如每个人都有生日——对学生也都成立。但我们并不预期对学生可成立的每一件事——例如他注册于某学校——对人也成立。人的概念比学生更一般化，学生是人的一种特殊形式。</p>
<p>&emsp;&emsp;于是，在C++领域中，任何函数如果期望获得一个类型为Person（或point-to-Person或reference-to-Person）的实参，都也愿意接受一个Student对象（或point-to-Student或reference-to-Student）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">const</span> Person&amp; p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">const</span> Student&amp; s)</span></span>;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"></span><br><span class="line">eat(p);  <span class="comment">//没问题</span></span><br><span class="line">eat(s);  <span class="comment">//没问题</span></span><br><span class="line">study(p);  <span class="comment">//错误！</span></span><br><span class="line">study(s);  <span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个论点只对public继承才成立。只有当Student以public形式继承Person，C++的行为才会如我所描述。private继承的意义与此完全不同，至于protected继承，那是一种其意义至今仍然困惑我的东西。</p>
<p>&emsp;&emsp;public继承和is-a之间的等价关系听起来颇为简单，但有时候你的直觉可能会误导你。举个例子，企鹅是一种鸟，这是事实。鸟可以飞，这也是事实。如果我们天真地以C++描述这层关系，结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;突然间我们感到了困惑，因为这个继承体系说企鹅可以飞，而我们知道那不是真的，怎么回事？</p>
<p>&emsp;&emsp;在这个例子中。当我们说鸟会飞的时候，我们真正的意思并不是说所有的鸟都会飞，我们要说的只是一般的鸟都有飞行能力。如果谨慎一点，我们应该承认一个事实：有数种鸟不会飞。看看以下代码，其构造出一种较为真实的继承体系：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyingBird</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的继承体系比原先的设计更能忠实反映出我们真正的意思。</p>
<p>&emsp;&emsp;即便如此，此刻我们仍然未能完全处理好这些鸟事，因为对某些软件系统而言，可能不需要区分会飞的鸟和不会飞的鸟。如果你的程序忙着处理鸟喙和鸟翅，完全不在乎飞行，原先的“双class继承体系”或许就相当令人满足了。这反映出一个事实，世界上并不存在一个“适用于所有软件”的完美设计。所谓最佳设计，取决于系统希望做什么事，包括现在与未来。如果你的程序对飞行一无所知，而且也不打算对飞行“有所知”，那么不去区分会飞的鸟和不会飞的鸟，不失为一个完美而有效的设计。实际上它可能比“对两者作出区隔”更受欢迎，因为这样的区隔在你企图塑模的世界中并不存在。</p>
<p>&emsp;&emsp;另有一种思想派别处理我所谓“所有的鸟都会飞，企鹅是鸟，但是企鹅不会飞”的问题，就是为企鹅重新定义fly函数，令它产生一个运行期错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; msg)</span></span>;  <span class="comment">//定义于另外某处</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123; error(<span class="string">"Attempt to make a penguin fly!"</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;很重要的是，你必须认知这里所说的某些东西可能和你所想的不同。这里并不是说“企鹅不会飞”，而是说“企鹅会飞，但尝试那么做是一种错误”。</p>
<p>&emsp;&emsp;如何描述其间的差异？从错误被侦测出来的时间点观之，“企鹅不会飞”这一限制可由编译器强制实施，但若违反“企鹅尝试飞行，是一种错误”这一条规则，只有运行期才能检测出来。</p>
<p>&emsp;&emsp;为了表现“企鹅不会飞，就这样”的限制，你不可以为Penguin定义fly函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Penguin</span> :</span> <span class="keyword">public</span> Bird &#123;</span><br><span class="line">    ...  <span class="comment">//没有声明fly函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，如果你试图让企鹅飞，编译器会对你的背信加以谴责：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Penguin p;</span><br><span class="line">p.fly();  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>“public继承”意味着is-a。适用于base class身上的每一件事情一定也适用于derived class身上，因为每一个derived class对象也都是一个base class对象。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>确定对象被使用前已先被初始化</title>
    <url>/2020/07/19/%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<hr>
<h1 id="C-反复无常的“对象初始化”"><a href="#C-反复无常的“对象初始化”" class="headerlink" title="C++反复无常的“对象初始化”"></a>C++反复无常的“对象初始化”</h1><p>&emsp;&emsp;关于“将对象初始化”这一点，C++似乎反复无常。如果我们这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure>

<p>在某些语境下x保证被初始化（为0），但在其他语境中却不保证。如果我们这么写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Point p;</span><br></pre></td></tr></table></figure>

<p>p的成员变量有时候被初始化（为0），有时候不会。</p>
<a id="more"></a>

<p>&emsp;&emsp;通常如果我们使用C part of C++而且初始化可能导致运行期成本，那么就不保证发生初始化。一旦进入了non-C parts of C++，规则就会有些改变。这就很好的解释了为什么array（来自C part of C++）不保证其内容被初始化，而vector（来自STL parts of C++）却有此保证。</p>
<p>&emsp;&emsp;表面上这似乎是个无法决定的状态，而最佳处理办法就是：永远在使用对象之前先将它初始化。对于任何成员的内置类型，我们必须手工完成此事。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">text</span> = <span class="string">"A C-style string"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; d;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至于内置类型以外的任何其他东西，初始化责任落在了构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。</p>
<p>&emsp;&emsp;这个规则很容易遵循，重点是别混淆了赋值和初始化。</p>
<h1 id="构造函数中的初始化"><a href="#构造函数中的初始化" class="headerlink" title="构造函数中的初始化"></a>构造函数中的初始化</h1><p>考虑一个用来表现通讯簿的class，其构造函数如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,</span><br><span class="line">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theName;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> theAddress;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt; thePhones;</span><br><span class="line">    <span class="keyword">int</span> numTimesConsulted;</span><br><span class="line">&#125;;</span><br><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones) &#123;</span><br><span class="line">    theName = name;  <span class="comment">//这些都是赋值而非初始化</span></span><br><span class="line">    theAddress = address;</span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这会导致ABEntry对象带有我们期望的值，但不是最佳做法。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。在ABEntry构造函数内，theName，theAddress和thePhones都不是被初始化，而是被赋值。初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之时。但这对numTimesConsulted却并非如此，因为它属于内置类型，不保证一定在我们所看到的那个赋值动作的时间点之前获得初值。</p>
<p>&emsp;&emsp;ABEntry构造函数的一个较佳写法是，使用所谓的member initialization list（成员初值列）替换赋值动作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; address,</span><br><span class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;PhoneNumber&gt;&amp; phones) </span><br><span class="line">    : theName(name),</span><br><span class="line">      theAddress(address),</span><br><span class="line">      thePhones(phones),</span><br><span class="line">      numTimesConsulted(<span class="number">0</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个构造函数和上一个的最终结果相同，但通常效率较高。对于大多数类型而言，比起先调用default构造函数然后再调用copy assignment操作符，单只调用一次copy构造函数是比较高效的，有时甚至高效的多。对于内置对象如numTimesConsulted，其初始化和赋值的成本相同，但为了一致性最好也通过成员初值列来初始化。同样的道理，甚至当我们想要default构造一个成员变量，我们都可以用成员初值列，只要指定nothing作为初始化实参即可，假设ABEntry有一个无参数构造函数，我们可以将其实现为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ABEntry::ABEntry() </span><br><span class="line">    : theName(),  <span class="comment">//调用theName的default构造函数</span></span><br><span class="line">      theAddress(),</span><br><span class="line">      thePhones(),</span><br><span class="line">      numTimesConsulted(<span class="number">0</span>)  <span class="comment">//记得将numTimesConsulted显式初始化为0</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>由于编译器会为用户自定义类型的成员变量自动调用default构造函数——如果那些成员变量在“成员初值列”中没有被指定初值的话，因而引发某些程序员过度夸张地采用以上写法，这是可以理解的，但请立下一个规定，总是在初值列中列出所有成员变量，以免还得记住哪些成员变量可以无需初值。举个例子，由于numTimesConsulted属于内置类型，如果成员初值列遗漏了它，它就没有初值，因而可能造成严重的后果。</p>
<p>&emsp;&emsp;有些情况下即使面对的成员变量属于内置类型（那么其初始化与赋值成本相同），也一定得使用初值列。没错，如果成员变量是const或reference，它们就一定需要初值，不能被赋值。为了避免需要记住成员变量何时必须在成员初值列中初始化，何时不需要，最简单的做法就是：总是使用成员初值列。这样做有时候绝对有必要，且往往比赋值更高效。</p>
<p>&emsp;&emsp;许多classes拥有多个构造函数，每个构造函数有自己的成员初值列；如果这种clasees存在许多成员变量和／或base classes，多份成员初值列的存在就会导致不受欢迎的重复（在初值列内）和无聊的工作。这种情况下可以合理地在初值列中遗漏哪些“赋值表现像初始化一样好”的成员变量，改用它们的赋值操作，并将哪些赋值动作移往某个函数（通常是private），供所有构造函数调用。这种做法在“成员变量的初值是由文件或数据库读入”时特别有用。然而，比起经由赋值操作完成的“伪初始化”，通过成员初值列完成的“真正初始化”通常更加可取。</p>
<p>&emsp;&emsp;C++有着十分固定的“成员初始化次序”。次序总是相同的：base classes更早于其derived classes被初始化，而class的成员变量总是以其声明次序被初始化。回头看看ABEntry，其theName成员永远最先被初始化，然后是theAddress，再来是thePhones，最后是numTimesConsulted。即使它们在成员初值列中以不同的次序出现（很不幸，这是合法的），也不会有任何影响。为避免我们或观看我们代码的人迷惑，当我们在编写成员初值列各个成员时，最好总是以其声明次序为次序。</p>
<h1 id="不同编译单元内定义的non-local-static对象的初始化次序"><a href="#不同编译单元内定义的non-local-static对象的初始化次序" class="headerlink" title="不同编译单元内定义的non-local static对象的初始化次序"></a>不同编译单元内定义的non-local static对象的初始化次序</h1><p>&emsp;&emsp;一旦我们已经很小心地将“内置型成员变量”明确地加以初始化，而且也确保我们的构造函数运用“成员初值列”初始化base classes和成员变量，那就只剩唯一一件事需要操心，那就是……呃……深呼吸……“不同编译单元内定义的non-local static对象”的初始化次序。</p>
<p>&emsp;&emsp;让我们一点一点地深钻这一长串词组。</p>
<p>&emsp;&emsp;所谓static对象，其寿命从被构造出来直到程序结束为止，因此stack和heap-base对象都被排除。这种对象包括global对象、定义于namespace作用域内的对象、在class内、在函数内、以及在file作用域内被声明为static的对象。函数内的static对象称为local static对象，其它static对象称为non-local static对象。程序结束时static对象会被自动销毁，也就是它们的析构函数会在main()结束时被自动调用。</p>
<p>&emsp;&emsp;所谓编译单元是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含入的头文件。</p>
<p>&emsp;&emsp;现在，我们关心的问题涉及至少两个源码文件，每一个内含至少一个non-local static对象。真正的问题是：如果某编译单元内的某个non-local static对象的初始化动作使用了另一编译单元的某个non-local static对象，它所用到的这个对象可能尚未被初始化，因为C++对“定义于不同编译单元内的non-local static对象”的初始化次序并无明确定义。</p>
<p>&emsp;&emsp;幸运的是一个小小的设计便可以完全消除这个问题。唯一需要做的是：将每个non-local static对象搬到自己的专属函数内（该对象在此函数内被声明为static）。这些函数返回一个reference指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static对象被local static对象替换了。Design Patterns迷哥迷妹们想必认出来了，这是Singleton模式的一个常见实现手法。</p>
<p>&emsp;&emsp;这个手法的基础在于：C++保证，函数内的local static对象会在“该函数被调用期间”“首次遇上该对象的定义式”时被初始化。所以如果我们以“函数调用”（返回一个reference指向local static对象）替换“直接访问non-local static对象”，我们就获得了保证，保证我们所获的的那个reference将指向一个经历过初始化的对象。更棒的是，如果我们从未调用non-local static对象的“仿真函数”，就绝不会引发构造和析构成本：真正的non-local static对象可没这等便宜。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li><p>为内置型对象进行手工初始化，因为C++不保证初始化它们。</p>
</li>
<li><p>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</p>
</li>
<li><p>为免除“跨编译单元的初始化次序”问题，以local static对象替换non-local static对象。</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>绝不在构造和析构过程中调用virtual函数</title>
    <url>/2020/07/24/%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="绝不在构造和析构过程中调用virtual函数"><a href="#绝不在构造和析构过程中调用virtual函数" class="headerlink" title="绝不在构造和析构过程中调用virtual函数"></a>绝不在构造和析构过程中调用virtual函数</h1><p>&emsp;&emsp;我们不该在构造函数和析构函数期间调用virtual函数，因为这样的调用不会带来我们预想的结果，就算有我们也不会高兴。如果你同时也是一位Java或C#程序员，那么就更加要注意了，因为这是C++与它们不同的一个地方。</p>
<p>&emsp;&emsp;假设我们有个class继承体系，用来塑模股市交易如买进、卖出的订单等等。这样的交易一定要经过审计，所以每当创建一个交易对象，在审计日志中也需要创建一笔适当记录。下面是一个看起来颇为合理的做法：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span>                           <span class="comment">//所有交易的base class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">//做出一份因类型不同而不同</span></span><br><span class="line">                                              <span class="comment">//的日志记录（log entry）</span></span><br><span class="line">    ...</span><br><span class="line">&#125;；</span><br><span class="line">Transaction::Transactionn() &#123;                 <span class="comment">//base class构造函数的实现</span></span><br><span class="line">    ...</span><br><span class="line">    logTransaction();                         <span class="comment">//最后动作是记录这笔交易</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;    <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//记录此类交易</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;   <span class="comment">//derived class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;      <span class="comment">//记录此类交易</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，当执行一下这行时，会发生什么事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;无疑会有一个BuyTransaction构造函数被调用，但首先Transaction构造函数一定会更早被调用；没错，derived class对象内的base class成分会在derived class自身成分被构造之前先构造妥当。Transaction构造函数的最后一行调用virtual函数logTransaction，这正是奇怪的地方。这时候被调用的logTransaction是Transaction内的版本，不是buyTransaction内的版本——即使目前即将建立的对象类型是buyTransaction。没错，base class构造期间virtual函数绝不会下降到derived classs阶层。取而代之的是，对象的作为就像隶属base类型一样。非正式的说法或许比较传神：在base class构造期间，virtual函数不是virtual函数。</p>
<p>&emsp;&emsp;这一似乎反直觉的行为有个好的解释。由于base class构造函数的执行更早于derived class构造函数，当base class构造函数执行时derived class的成员变量尚未初始化。如果此期间调用的virtual函数下降至derived class阶层，要知道derived class的函数几乎必然取用local成员变量，而那些成员变量尚未初始化。这将是一张通往不明确行为和彻夜调试大会的直达车票。“使用对象内部尚未初始化的成分”是及其危险的，所以C++允许我们这样做。</p>
<p>&emsp;&emsp;其实还有比上述理由更根本的原因：在derived class对象的base class构造期间，对象的类型是base class而不是derived class。不只virtual函数会被编译器解析至base class，若使用运行期类型信息（例如dynamic_cast和typeid），也会把对象视为base class类型。本例之中，当Transaction构造函数正执行起来打算初始化“BuyTransaction对象内的base class成分”时，该对象的类型时Transaction。这个对象内的“BuyTransaction专属成分”尚未被初始化，所以面对它们，最安全的做法就是视它们不存在。对象在derived class构造函数开始执行前不会成为一个derive的对象。</p>
<p>&emsp;&emsp;相同的道理也适用于析构函数。一旦derived class析构函数开始执行，对象内的derived class成员变量便呈现未定义值，所以C++视它们仿佛不再存在。进入base class析构函数后对象就成为一个base class对象，而C++的任何部分包括virtual函数、dynamic_cast等等也就会那么看待它。</p>
<p>&emsp;&emsp;在上述示例中，Transaction构造函数直接调用一个virtual函数，这很明显而且容易看出来，某些编译器会为此发出一个警告信息。即使没有这些警告信息，这个问题在执行前也几乎肯定会变得显而易见，因为logTransaction函数在Transaction内是个pure virtual。除非它被定义（不太有可能）否则程序无法连接，因为连接器找不到必要的Transaction::logTransaction实现代码。</p>
<p>&emsp;&emsp;但是侦测“构造函数或析构函数运行期是否调用virtual函数”并不总是这样轻松。如果Transaction有多个构造函数，每个都需要执行某些相同的工作，那么避免代码重复的一个优秀做法是把共同的初始化代码（其中包括对logTransaction的调用）放进一个初始化函数如init内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Transaction() &#123; init(); &#125;  <span class="comment">//调用non-virtual</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        logTransaction();  <span class="comment">//这里调用virtual！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码概念上和之前版本相同，但它比较隐蔽，因为它通常不会引发任何编译器和连接器的抱怨。此时由于logTransaction是Transaction内的一个pure virtual函数，当pure virtual函数被调用，大多数执行系统会中止程序（通常会对此结果发出一个信息）。然而如果logTransaction是个正常的virtual函数并在Transaction内带有一份实现代码，该版本就会被调用，而程序也就会兴高采烈地继续向前执行，之后我们便会百思不得其解：为什么建立一个derived class对象时会调用错误版本的logTransaction。唯一能够避免此问题的做法就是：确定我们的构造函数和析构函数都没有（在对象被创建和被销毁期间）调用virtual函数，而它们调用的所有函数也都服从同一个约束。</p>
<p>&emsp;&emsp;但我们如何确保每次一有Transaction继承体系上的对象被创建，就会有适当版本的logTransaction被调用呢？很显然，在Transaction构造函数内对对象调用virtual函数是一种错误做法。</p>
<p>&emsp;&emsp;有其他方案可以解决这个问题，一种做法是在class Transaction内将logTransaction函数改为non-virtual，然后要求derived class构造函数传递必要信息给Transaction构造函数，而后那个构造函数便可安全地调用non-virtual logTransaction。像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Transaction</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logTransaction</span><span class="params">(cosnt <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo)</span> cosnt</span>;  <span class="comment">//如今是个non-virtual函数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Transaction::Transaction(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; logInfo) &#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo);  <span class="comment">//如今是个non-virtual调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BuyTransaction(parameters)</span><br><span class="line">        : Transaction(createLogString(parameters)) &#123;  <span class="comment">//将log信息传给base class构造函数</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">createLogString</span><span class="params">(parameters)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;换句话说由于我们无法使用virtual函数从base class向下调用，在构造期间，我们可以藉由“令derived class将必要的构造信息向上传递至base class构造函数”替换之而加以弥补。</p>
<p>&emsp;&emsp;在本例中BuyTransaction内的private static函数createLogString的作用：比起在成员初值列内给予base class所需数据，利用辅助函数创建一个值传给base class构造函数往往比较方便（也比较可读）。令此函数为static，也就不可能意外指向“初期未成熟的BuyTransaction对象内尚未初始化的成员变量”。这很重要，正是因为“那些成员变量处于未定义状态”，所以“在base class构造和析构期间调用的virtual函数不可下降至derived class”。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>绝不重新定义继承而来的non-virtual函数</title>
    <url>/2020/11/11/%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84non-virtual%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="绝不重新定义继承而来的non-virtual函数"><a href="#绝不重新定义继承而来的non-virtual函数" class="headerlink" title="绝不重新定义继承而来的non-virtual函数"></a>绝不重新定义继承而来的non-virtual函数</h1><p>&emsp;&emsp;假设我告诉你，class D系由class B以public形式派生而来，class B定义有一个public成员函数mf。由于mf的参数和返回值都不重要，所以我们假设两者皆为void。换句话说我的意思是： </p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;虽然我们对B，D和mf一无所知，但面对一个类型为D的对象x：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D x;  <span class="comment">//x是一个类型为D的对象</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果以下行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">B* pB = &amp;x;  <span class="comment">//获得一个指针指向x</span></span><br><span class="line">pB-&gt;mf();    <span class="comment">//经由该指针调用mf</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;异于以下行为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">D* pD = &amp;x;  <span class="comment">//获得一个指针指向x</span></span><br><span class="line">pD-&gt;mf();    <span class="comment">//经由该指针调用mf</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你可能会相当惊讶。毕竟两者都通过对象x调用成员函数mf。由于两者所调用的函数都相同，凭借的对象也相同，所以行为也应该相同，是吗？</p>
<p>&emsp;&emsp;是的，理应如此，但事实可能不是如此。更明确地说，如果mf是个non-virtual函数而D定义有自己的mf版本，那就不是如此：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf</span><span class="params">()</span></span>;  <span class="comment">//遮掩了B::mf;</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pB-&gt;mf();  <span class="comment">//调用B::mf</span></span><br><span class="line">pD-&gt;mf();  <span class="comment">//调用D::mf</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;造成此一两面行为的原因是，non-virtual函数如B::mf和D::mf都是静态绑定。这意思是，由于pB被声明为一个pointer-to-B，通过pB调用的non-virtual函数永远是B所定义的版本，即使pB指向一个类型为“B派生之class”的对象，一如本例。</p>
<p>&emsp;&emsp;但另一方面，virtual函数却是动态绑定，所以它们不受这个问题之苦。如果mf是个virtual函数，不论是通过pB或pD调用mf，都会导致调用D::mf，因为pB和pD真正指的都是一个类型为D的对象。</p>
<p>&emsp;&emsp;如果你正在编写class D并重新定义继承自class B的non-virtual函数mf，D对象很可能展现出精神分裂的不一致行径。更明确地说，当mf被调用，任何一个D对象都可能表现出B或D的行为；决定因素不在对象自身，而在于“指向该对象之指针”当初的声明类型。References也会展现和指针一样难以理解的行径。</p>
<p>&emsp;&emsp;但那只是务实面上的讨论。我知道你真正想要的是理论层面的理由（关于“绝不重新定义继承而来的non-virtual函数”这回事）。我很乐意为你服务。</p>
<p>&emsp;&emsp;条款“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”已经说过，所谓public继承意味is-a的关系。条款“<a href="/2020/10/29/%E5%8C%BA%E5%88%86%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/" title="区分接口继承和实现继承">区分接口继承和实现继承</a>”则描述为什么在class内声明一个non-virtual函数会为该class建立起一个不变性，凌驾其特异性。如果你将这两个观点施行于两个class B和D以及non-virtual成员函数B::mf身上，那么：</p>
<ul>
<li>适用于B对象的每一件事，也适用于D对象，因为每个D对象都是一个B对象；</li>
<li>B的derived class一定会继承mf的接口和实现，因为mf是B的一个non-virtual函数。</li>
</ul>
<p>&emsp;&emsp;现在，如果D重新定义mf，你的设计便出现矛盾。如果D真有必要实现出与B不同的mf，并且每一个B对象——不管多么特化——真的必须使用B所提供的mf实现码，那么“每个D都是一个B”就不为真。既然如此D就不该以public形式继承B。另一方面，如果D真的必须以public方式继承B，并且如果D真有需要实现出与B不同的mf，那么mf就无法为B反映出“不变性凌驾特异性”的性质。既然这样mf应该声明为virtual函数。最后，如果每个D真的是一个B，并且如果mf真的为B反映出“不变性凌驾特异性”的性质，那么D便不需要重新定义mf，而且它也不应该尝试这样做。</p>
<p>&emsp;&emsp;不论哪一个观点，结论都相同：任何情况下都不该重新定义一个继承而来的non-virtual函数。</p>
<blockquote>
<ul>
<li>绝对不要重新定义继承而来的non-virtual函数。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>编写有兼容性的成员函数模版</title>
    <url>/2020/11/18/%E7%BC%96%E5%86%99%E6%9C%89%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<hr>
<h1 id="编写有兼容性的成员函数模版"><a href="#编写有兼容性的成员函数模版" class="headerlink" title="编写有兼容性的成员函数模版"></a>编写有兼容性的成员函数模版</h1><p>&emsp;&emsp;STL容器的迭代器几乎总是智能指针，其优点不言而喻：可以在正确的时机自动删除heap-based资源。对于真实指针而言，做的较好的一件事是，支持隐式转换。Derived class指针可以隐式转换为base class指针，“指向non-const对象”的指针可以转换为“指向const对象”等等。以下为三层继承体系中的转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Top</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> :</span> <span class="keyword">public</span> Top &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottom</span> :</span> <span class="keyword">public</span> Middle &#123; ... &#125;;</span><br><span class="line">Top* pt1 = <span class="keyword">new</span> Middle;</span><br><span class="line">Top* pt2 = <span class="keyword">new</span> Bottom;</span><br><span class="line"><span class="keyword">const</span> Top* cpt = pt1;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;那么在智能指针中的转换又是如何呢？接下来我们希望以下代码可以通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">SmartPtr</span><span class="params">(T* realPtr)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;Top&gt; pt1 = SmartPtr&lt;Middle&gt;(<span class="keyword">new</span> Middle);</span><br><span class="line">SmartPtr&lt;Top&gt; pt2 = SmartPtr&lt;Bottom&gt;(<span class="keyword">new</span> Bottom);</span><br><span class="line">SmartPtr&lt;<span class="keyword">const</span> Top&gt; cpt = pt1;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但是从同一个tamplate具现出来的不同具现体之间并没有任何“关系”，也就是说如果以带有base-derived关系的B，D类型分别具现化某个template，产生出来的两个具现体并不带有base-derived关系。所以编译器视SmartPtr&lt;Middle&gt;和SmartPtr&lt;Top&gt;为两个不同的class。为了使SmartPtr class之间具有转换能力，我们必须更进一步的将它们编写出来。</p>
<p>&emsp;&emsp;在对上述代码进行修改前，你似乎会构思出这样的想法：根据一个SmartPtr&lt;Middle&gt;或一个SmartPtr&lt;Bottom&gt;构造出一个SmartPtr&lt;Top&gt;，以此来完成转换。但是如果这个继承体系未来将进一步扩充的话，我们需要的构造函数数量也会进一步扩充，对于一个template来说，这样的扩充似乎无穷无尽，因为template可以被无限量地具现化。因此，让我们换个思路来解决上述问题，我们需要的不是为SmartPtr写一个构造函数，而是为它写一个构造模版。这样的模版也就是所谓的member function template，其作用是为class生成函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;以上代码意思是，对于任何T类型和任何U类型，这里可以根据SmartPtr&lt;U&gt;生成一个SmartPtr&lt;T&gt;——因为SmartPtr&lt;T&gt;它的构造函数接受的是一个SmartPtr&lt;U&gt;参数。这一类构造函数根据对象u创建对象t（例如根据SmartPtr&lt;U&gt;创建一个SmartPtr&lt;T&gt;），而u和v的类型是同一个template的不同具现体，这类构造函数也就是泛化copy构造函数。</p>
<p>&emsp;&emsp;你会注意到上述泛化copy构造函数并未被声明为explicit。因为原始指针类型之间的转换（例如从derived class指针转为base class指针）是隐式转换，没有必要写出转型动作（cast），所以为了让我们的智能指针也表现出这种行为，在模版化构造函数时，我们略去了explicit。</p>
<p>&emsp;&emsp;现在我们可以对这个代码进行更进一步的优化。期望可以根据一个SmartPtr&lt;Bottom&gt;创建一个SmartPtr&lt;Top&gt;，而且我们不会期望根据一个SmartPtr&lt;Top&gt;创建一个SmartPtr&lt;Bottom&gt;，因为这对于public继承来说是矛盾的。当然，我们肯定也不会希望根据一个SmartPtr&lt;double&gt;创建出一个SmartPtr&lt;int&gt;，因为实际情况中并不会存在这样一个行为“将int*转换为double*”。也就是，我们必须要从某个方面来对member template所创建的成员函数簇进行一个剔除或筛选。</p>
<p>&emsp;&emsp;现在让我们一步一步创建起来的SmartPtr遵循std::shared_ptr那样的模版，也提供一个get成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模版”实现代码中约束转换行为，使它符合我们对它的期望：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">        SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other) </span><br><span class="line">            : heldPtr(other.<span class="built_in">get</span>()) &#123; ... &#125;</span><br><span class="line">        <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> heldPtr; &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* heldPtr;  <span class="comment">//SmartPtr持有的内置（原始）指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我使用成员初值列来初始化SmartPtr&lt;T&gt;之类型为T*的成员变量，并用类型U*的指针（由SmartPtr&lt;U&gt;持有）作为初值。啊哈，这个结果正是我们想要的：只有当U*指针可以隐式转换为T*指针时该代码才可以通过编译。那么经过这一轮的优化，最终得到了我们想要的结果——这个构造函数只有在其所获得的实参属于兼容类型时才可以通过编译。</p>
<p>&emsp;&emsp;同样的，member function template也常用于赋值操作。例如std::shared_ptr支持所有“来自兼容类型的内置指针、std::shared_ptr和std::weak_ptr”的构造行为。以及所有来自上述各物（std::weak_ptr除外）的赋值操作。以下是关于std::shared_ptr的一份简单摘要码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt; </span></span><br><span class="line"><span class="class">        <span class="title">explicit</span> <span class="title">shared_ptr</span>(<span class="title">Y</span>* <span class="title">p</span>);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">share_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">explicit</span> <span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">weak_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>&amp; <span class="title">operator</span>=(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你会注意到上述所有构造函数都是explicit，除了“泛化copy构造函数”。这意味着从某个shared_ptr类型隐式转换至另一个shared_ptr类型是被允许的，但从某个内置指针或从其它智能指针类型进行隐式转换则不被允许（如果是显式转换，例如cast强制转型动作倒是可以）。</p>
<p>&emsp;&emsp;虽然member function template（成员函数模版）趣味无穷，但它们并不影响语言基本规则的运行。那意味着编译器仍然可能会为我们产生四个成员函数，其中两个是copy构造函数和copy assignment操作符。问题来了，让我们把关注点放到std::shared_ptr的泛化copy构造函数上，一旦T和Y的类型相同，泛化copy构造函数会被具现化为“正常的”copy构造函数。那么究竟编译器会暗自为std::shared_ptr生成一个copy构造函数呢？亦或是当某个std::shared_ptr对象根据另一个同型的std::shared_ptr对象展开构造行为时，编译器会将“泛化copy构造函数”具现化呢？</p>
<p>&emsp;&emsp;就像我所说的member template并不会改变语言规则，而语言规则说，如果程序需要一个copy构造函数，你却没有声明它，编译器会为你暗自生成一个。在class内声明泛化copy构造函数并不会阻止编译器生成它们自己的copy构造函数，所以如果你想要控制copy构造的方方面面，你必须同时声明泛化copy构造函数和“正常的”copy构造函数。这对于赋值操作也同样适用。以下代码展示了这一要点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; r);  <span class="comment">//copy构造函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        <span class="built_in">shared_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; r);</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Y</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">shared_ptr</span>&amp; <span class="title">operator</span>=(<span class="title">const</span> <span class="title">shared_ptr</span>&lt;Y&gt;&amp; <span class="title">r</span>);</span></span><br><span class="line">  </span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>请使用member function template（成员函数模版）生成“可接受所有兼容类型”的函数。</li>
<li>如果你声明member template用于“泛化copy构造函数”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>绝不重新定义继承而来的缺省参数值</title>
    <url>/2020/11/11/%E7%BB%9D%E4%B8%8D%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<hr>
<h1 id="绝不重新定义继承而来的缺省参数值"><a href="#绝不重新定义继承而来的缺省参数值" class="headerlink" title="绝不重新定义继承而来的缺省参数值"></a>绝不重新定义继承而来的缺省参数值</h1><p>&emsp;&emsp;让我们一开始就将讨论简化。你只能继承两种函数：virtual和non-virtual函数。然而重新定义一个继承而来的non-virtual函数永远是错误的，所以我们可以安全地将本条款的讨论局限于“继承一个带有缺省参数值的virtual函数”。</p>
<p>&emsp;&emsp;这种情况下，本条款成立的理由就非常直接而明确了：virtual函数系动态绑定，而缺省参数值却是静态绑定。</p>
<p>&emsp;&emsp;对象的所谓静态绑定类型，就是它在程序中被声明时所采用的类型。考虑以下的class继承体系：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用以描述几何形状的class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue &#125;;</span><br><span class="line">        <span class="comment">//所有形状都必须提供一个函数，用来绘出自己</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//注意，赋予不同的缺省参数值。这真糟糕！</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="comment">//译注：请注意，以上这么写则当客户以对象调用此函数，一定要指定参数值。</span></span><br><span class="line">        <span class="comment">//     因为静态绑定下这个函数并不从其base继承缺省参数值。</span></span><br><span class="line">        <span class="comment">//     但若以指针（或reference）调用此函数，可以不指定参数值。</span></span><br><span class="line">        <span class="comment">//     因为动态绑定下这个函数会从其base继承缺省参数值。</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在考虑这些指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Shape* ps;                  <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pc = <span class="keyword">new</span> Circle;     <span class="comment">//静态类型为Shape*</span></span><br><span class="line">Shape* pr = <span class="keyword">new</span> Rectangle;  <span class="comment">//静态类型为Shape*</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本例中ps，pc，pr都被声明为pointer-to-Shape类型，所以它们都以它为静态类型。注意，不论它们真正指向什么，它们的静态类型都是Shape*。</p>
<p>&emsp;&emsp;对象的所谓动态类型则是指“目前所指对象的类型”。也就是说，动态类型可以表现出一个对象将会有什么行为。以上例而言，pc的动态类型是Circle*，pr的动态类型是Rectangle*。ps没有动态类型，因为它尚未指向任何对象。</p>
<p>&emsp;&emsp;动态类型一如其名称所示，可在程序执行过程中改变（通常是经由赋值动作）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ps = pc;  <span class="comment">//ps的动态类型如今是Circle*</span></span><br><span class="line">ps = pr;  <span class="comment">//ps的动态类型如今是Rectangle*</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;virtual函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pc-&gt;draw(Shape::Red);  <span class="comment">//调用Circle::draw(Shape::Red)</span></span><br><span class="line">pr-&gt;draw(Shape::Red);  <span class="comment">//调用Rectangle::draw(Shape::Red)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我知道这些都是老调重弹；是的，你当然已经了解virtual函数。但是当你考虑带有缺省参数值的virtual函数，花样来了，因为就如我稍早所说，virtual函数是动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用base class为它所指定的缺省参数值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pr-&gt;draw();  <span class="comment">//调用Rectangle::draw(Shape::Red)！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此例之中，pr的动态类型是Rectangle<em>，所以调用的是Rectangle的virtual函数，一如你所预期。Rectangle::draw函数的缺省参数值应该是GREEN，但由于pr的静态类型是Shape\</em>，所以此一调用的缺省参数值来自Shape class而非Rectangle class！结局是这个函数调用有着奇怪并且几乎绝对没人预料得到的组合，由Shape class和Rectangle class的draw声明式各出一半力。</p>
<p>&emsp;&emsp;以上事实不只局限于“ps，pc和pr都是指针”的情况；即使把指针换成reference问题仍然存在。重点在于draw是个virtual函数，而它有个缺省参数值在derived class中被重新定义了。</p>
<p>&emsp;&emsp;为什么C++坚持以这种乖张的方式来运作呢？答案在于运行期效率。如果缺省参数值是动态绑定，编译器就必须有某种方式在运行期为virtual函数决定适当的参数缺省值。这比目前实行的“在编译期决定”的机制更慢而且更复杂。为了程序的执行速度和编译器实现上的简易度，C++做了这样的取舍，其结果就是你如今所享受的执行效率。</p>
<p>&emsp;&emsp;这一切都很好，但如果你试着遵守这条规则，并且同时提供缺省参数值给base和derived class的用户，又会发生什么事呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;喔欧，代码重复。更糟的是，代码重复又带着相依性：如果Shape内的缺省参数值改变了，所有“重复给定缺省参数值”的那些derived class也必须改变，否则它们最终会导致“重复定义一个继承而来的缺省参数值”。怎么办？</p>
<p>&emsp;&emsp;当你想令virtual函数表现出你所想要的行为但却遭遇麻烦，聪明的做法是考虑替代设计。提条款“<a href="/2020/10/31/%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9/" title="考虑virtual函数以外的其他选择">考虑virtual函数以外的其他选择</a>”列了不少virtual函数的替代设计，其中之一是NVI手法：令base class内的一个public non-virtual函数调用private virtual函数，后者可被derived class重新定义。这里我们可以让non-virtual函数指定缺省参数，而private virtual函数负责真正的工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">enum</span> ShapeColor &#123; Red, Green, Blue &#125;;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(ShapeColor color = Red)</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">//如今它是non-virtual</span></span><br><span class="line">            doDraw(color);                         <span class="comment">//调用一个virtual</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  <span class="comment">//真正的工作在此完成</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(ShapeColor color)</span> <span class="keyword">const</span></span>;  <span class="comment">//注意，不须指定缺省参数值。</span></span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于non-virtual函数应该绝对不被derived class覆写，这个设计很清楚地使得draw函数的color缺省参数值总是Red。</p>
<blockquote>
<ul>
<li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>考虑virtual函数以外的其他选择</title>
    <url>/2020/10/31/%E8%80%83%E8%99%91virtual%E5%87%BD%E6%95%B0%E4%BB%A5%E5%A4%96%E7%9A%84%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9/</url>
    <content><![CDATA[<hr>
<h1 id="考虑virtual函数以外的其他选择"><a href="#考虑virtual函数以外的其他选择" class="headerlink" title="考虑virtual函数以外的其他选择"></a>考虑virtual函数以外的其他选择</h1><p>&emsp;&emsp;假设你正在写一个游戏，你打算为游戏内的人物设计一个继承体系。你的游戏属于砍杀类型，游戏中人物被伤害或因其他因素而降低健康状态的情况并不罕见。你因此决定提供一个成员函数healthValue，它会返回一个整数，表示人物的健康程度。由于不同的人物可能以不同的方式计算他们的健康指数，将healthValue声明为virtual似乎是再明白不过的做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">//返回人物的健康指数；</span></span><br><span class="line">        ...                               <span class="comment">//derived class可重新定义它</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;healthValue并未被声明为pure virtual，这暗示我们将会有个计算健康指数的缺省算法。</p>
<p>&emsp;&emsp;这的确是再明白不过的设计，但是从某个角度说却反而成为了它的弱点。由于这个设计如此明显，你可能因此没有认真考虑其他替代方案。为了帮助你跳脱面向对象设计上的常轨，让我们考虑其他一些解法。</p>
<h2 id="藉由Non-Virtual-Interface手法实现Template-Method模式"><a href="#藉由Non-Virtual-Interface手法实现Template-Method模式" class="headerlink" title="藉由Non-Virtual Interface手法实现Template Method模式"></a>藉由Non-Virtual Interface手法实现Template Method模式</h2><p>&emsp;&emsp;我们将从一个有趣的思想流派开始，这个流派主张virtual函数应该几乎总是private。这个流派的拥护者建议，较好的设计是保留healthValue为public成员函数，但让它成为non-virtual，并调用一个private virtual函数（例如doHealthValue）进行实际工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;            <span class="comment">//derived class不重新定义它。</span></span><br><span class="line">            ...                              <span class="comment">//做一些事前工作。</span></span><br><span class="line">            <span class="keyword">int</span> retVal = doHealthValue();    <span class="comment">//做真正的工作。</span></span><br><span class="line">            ...                              <span class="comment">//做一些事后工作。</span></span><br><span class="line">            <span class="keyword">return</span> retVal;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">doHealthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;  <span class="comment">//derived class可重新定义它。</span></span><br><span class="line">            ...                              <span class="comment">//缺省算法，计算健康指数。</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这段代码中，我直接在class定义式内呈现成员函数本体。这也就让它们全部暗自成为了inline。但其实我以这种方式呈现代码只是为了让你比较容易阅读。我所描述的设计与inlining其实没有关联，所以请不要认为成员函数在这里被定义于class内有特殊用意。不，它没有。</p>
<p>&emsp;&emsp;这一基本设计，也就是“令客户通过public non-virtual成员函数间接调用private virtual函数”，称为non-virtual interface（NVI）手法。它是所谓Template Method设计模式的一个独特表现形式。我把这个non-virtual函数（healthValue）称为virtual函数的外覆器（wrapper）。</p>
<p>&emsp;&emsp;NVI手法的一个优点隐身在上述代码注释“做一些事前工作”和“做一些事后工作”之中。那些注释用来告诉你当时的代码保证在“virtual函数进行真正工作之前和之后”被调用。这意味外覆器确保得以在一个virtual函数被调用之前设定好适当场景，并在调用结束之后清理场景。“事前工作”可以包括锁定互斥器、制造运转日志记录项、验证class约束条件、验证函数先决条件等等。“事后工作”可以包括互斥器接触锁定、验证函数的事后条件、在此验证class约束条件等等。如果你让客户直接调用virtual函数，就没有任何好办法可以做这些事。</p>
<p>&emsp;&emsp;有件事或许会妨碍你跃跃欲试的心：NVI手法涉及在derived class内重新定义private virtual函数。啊，重新定义若干个derived class并不调用的函数！这里并不存在矛盾。“重新定义virtual函数”表示某些事“如何”被完成，“调用virtual函数”则表示它“何时”被完成。这些事情都是各自独立互不相干的。NVI手法允许derived class重新定义virtual函数，从而赋予它们“如何实现机能”的控制能力，但base class保留诉说“函数何时被调用”的权利。一开始这些听起来似乎诡异，但C++的这种“derived class可重新定义继承而来的private virtual函数”的规则似乎合情合理。</p>
<p>&emsp;&emsp;在NVI手法下其实没有必要让virtual函数一定得是private。某些class继承体系要求derived class在virtual函数的实现内必须调用其base class的对应兄弟，而为了让这样的调用合法，virtual函数必须是protected，不能是private。有时候virtual函数甚至一定得是public（例如具备多态性质的base class的析构函数），这么一来就不能实施NVI手法了。</p>
<h2 id="藉由Function-Pointers实现Strategy模式"><a href="#藉由Function-Pointers实现Strategy模式" class="headerlink" title="藉由Function Pointers实现Strategy模式"></a>藉由Function Pointers实现Strategy模式</h2><p>&emsp;&emsp;NVI手法对public virtual函数而言是一个有趣的替代方案，但从某种设计角度观之，它只比窗饰花样更强一些而已。毕竟我们还是使用virtual函数来计算每个人物的健康指数。另一个更戏剧性的设计主张“人物健康指数的计算与人物类型无关”，这样的计算完全不需要“人物”这个成分。例如我们可能会要求每个人物的构造函数接受一个指针，指向一个健康计算函数，而我们可以调用该函数进行实际计算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>  <span class="comment">//前置声明</span></span><br><span class="line"><span class="comment">//以下函数是计算健康指数的缺省算法。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HealthCalcFunc)</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : <span class="title">healthFunc</span><span class="params">(hcf)</span></span></span><br><span class="line"><span class="function">        </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个做法是常见的Strategy设计模式的简单应用。拿它和“植基于GameCharacter继承体系内之virtual函数”的做法比较，它提供了某些有趣弹性：</p>
<ul>
<li>同一人物类型之不同实体可以有不同的健康计算函数，例如：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">EvilBadGuy</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : <span class="title">GameCharacter</span><span class="params">(hcf)</span></span></span><br><span class="line"><span class="function">        </span>&#123; ... &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthQuickly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;  <span class="comment">//健康指数计算函数1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loseHealthSlowly</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;   <span class="comment">//健康指数计算函数2</span></span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(loseHealthQuickly)</span></span>;           <span class="comment">//相同类型的人物搭配</span></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(loseHealthSlowly)</span></span>;            <span class="comment">// 不同的健康计算方式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>某已知人物之健康指数计算函数可在运行期变更。例如GameCharacter可提供一个成员函数setHealthCalculator，用来替换当前的健康指数计算函数。</li>
</ul>
<p>&emsp;&emsp;换句话说，“健康指数计算函数不再是GameCharacter继承体系内的成员函数”这一事实意味，这些计算函数并未特别访问“即将被计算健康指数”的那个对象的内部成分。例如defaultHealthCalc并未访问EvilBadGuy的non-public成分。</p>
<p>&emsp;&emsp;如果人物的健康可纯粹根据该人物的public接口得来的信息加以计算，这就没有问题，但如果需要non-public信息进行精确计算，就有问题了。实际上任何时候当你将class内的某个机能（也许取道自某个成员函数）替换为class外部的某个等价机能（也许取道自某个non-member non-friend函数或另一个class的non-friend成员函数），这都是潜在争议点。这个争议将持续至本条款其余篇幅，因为我们即将考虑的所有替代设计也都涉及使用GameCharacter继承体系外的函数。</p>
<p>&emsp;&emsp;一般而言，唯一能够解决“需要以non-member函数访问class的non-public成分”的办法就是：弱化class的封装。例如class可声明那个non-member函数为friends，或是为其实现的某一部分提供public访问函数（其他部分则宁可隐藏起来）。运用函数指针替换virtual函数，其优点（像是“每个对象可各自拥有自己的健康计算函数”和“可在运行期改变计算函数”）是否足以弥补缺点（例如可能必须降低GameCharacter封装性），是你必须根据每个设计情况的不同而抉择的。</p>
<h2 id="藉由std-function完成Strategy模式"><a href="#藉由std-function完成Strategy模式" class="headerlink" title="藉由std::function完成Strategy模式"></a>藉由std::function完成Strategy模式</h2><p>&emsp;&emsp;一旦习惯了templates以及它们对隐式接口的使用，基于函数指针的做法看起来便过分苛刻而死板了。为什么要求“健康指数之计算”必须是个函数，而不能是某种“像函数的东西”（例如函数对象）呢？如果一定得是函数，为什么不能够是个成员函数？为什么一定得返回int而不是任何可被转换为int的类型呢？</p>
<p>&emsp;&emsp;如果我们不再使用函数指针（如前例的healthFunc），而是改用一个类型为std::function的对象，这些约束就全部挥发不见了。这样的对象可持有（保存）任何可调用物（callable entity，也就是函数指针、函数对象、或成员函数指针），只要其签名式兼容于需求端。以下将刚才的设计改为使用std::function：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealthCalc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//HealthCalcFunc可以是任何“可调用物”（callable entity），可被调用并接受</span></span><br><span class="line">        <span class="comment">//任何兼容于GameCharacter之物，返回任何兼容于int的东西。详下。</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc hcf = defaultHealthCalc)</span></span></span><br><span class="line"><span class="function">        : <span class="title">healthFunc</span><span class="params">(hcf)</span></span></span><br><span class="line"><span class="function">        </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如你所见，HealthCalcFunc是个typedef，用来表现std::function的某个具现体，意味着该具现体的行为像一般的函数指针。</p>
<p>&emsp;&emsp;和前一个设计（其GameCharacter持有的是函数指针）比较，这个设计几乎相同。唯一不同的是如今GameCharacter持有一个std::function对象，相当于一个指向函数的泛化指针。这个改变如此细小，我总说它没有什么外显影响，除非客户在“指定健康计算函数”这件事上需要更惊人的弹性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">short <span class="title">calcHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span></span>;  <span class="comment">//健康计算函数；</span></span><br><span class="line">                                         <span class="comment">//注意其返回类型为non-int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HealthCalculator</span> &#123;</span>                <span class="comment">//为计算健康而设计的函数对象</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameLevel</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">float</span> <span class="title">health</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp;)</span> <span class="keyword">const</span></span>;  <span class="comment">//成员函数，用以计算健康；</span></span><br><span class="line">        ...                                        <span class="comment">//注意其non-int返回类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EvilBadGuy</span> :</span> <span class="keyword">public</span> GameCharacter &#123;          <span class="comment">//同前</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EyeCandyCharacter</span> :</span> <span class="keyword">public</span> GameCharacter &#123;   <span class="comment">//另一个人物类型；</span></span><br><span class="line">    ...                                            <span class="comment">//假设其构造函数与</span></span><br><span class="line">&#125;;                                                 <span class="comment">//EvilBadGuy同</span></span><br><span class="line"></span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg1</span><span class="params">(calcHealth)</span></span>;                       <span class="comment">//人物1，使用某个</span></span><br><span class="line">                                                   <span class="comment">//函数计算健康指数</span></span><br><span class="line"></span><br><span class="line"><span class="function">EyeCandyCharacter <span class="title">ecc1</span><span class="params">(HealthCalculator())</span></span>;        <span class="comment">//人物2，使用某个</span></span><br><span class="line">                                                   <span class="comment">//函数对象计算健康指数</span></span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">...</span><br><span class="line"><span class="function">EvilBadGuy <span class="title">ebg2</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::bind(&amp;GameLevel::health, currentLevel, _1)</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先我要声明，为计算ebg2的健康指数，应该使用GameLevel class成员函数health。好，GameLevel::health宣称它自己接受一个参数（那是个reference指向GameCharacter），但它实际上接受两个参数，因为它也获得一个隐式参数GameLevel，也就是this所指的那个。然而GameCharacters的健康计算函数只接受单一参数：GameCharacter（这个对象将被计算出健康指数）。如果我们使用GameLevel::health作为ebg2的健康计算函数，我们必须以某种方式转换它，使它不再接受两个参数（一个GameCharacter和一个GameLevel），转而接受单一参数（一个GameCharacter）。在这个例子中我们必然会想要使用currentLevel作为“ebg2点健康计算函数所需的那个GameLevel对象”，于是我们将currentLevel绑定为GameLevel对象，让它在“每次GameLevel::health被调用用以计算ebg2的健康”时被使用。那正是std::bind的作为：它指出ebg2的健康计算函数应该总是以currentLevel作为GameLevel对象。</p>
<p>&emsp;&emsp;我跳过了一大堆细节，像是为什么“_1”意味“当为ebg2调用GameLevel::health时系以currentLevel作为GameLevel对象”。这样的细节不难阐述，但它们会分散我要说的根本重点：若以std::function替换函数指针，将因此允许客户在计算人物健康指数时使用任何兼容的可调用物。如果这还不酷，什么是酷？</p>
<h2 id="古典的Strategy模式"><a href="#古典的Strategy模式" class="headerlink" title="古典的Strategy模式"></a>古典的Strategy模式</h2><p>&emsp;&emsp;如果你对设计模式比对C++的酷劲更有兴趣，我告诉你，传统（典型）的Strategy做法会将健康计算函数做成一个分离的继承体系中的virtual成员函数。</p>
<p>&emsp;&emsp;比如下面的对应代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>;</span>  <span class="comment">//前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthCalcFunc</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span> <span class="keyword">const</span> </span>&#123; ... &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HealthCalcFunc defaultHealthCal;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">GameCharacter</span><span class="params">(HealthCalcFunc* phcf = &amp;defaultHealthCal)</span></span></span><br><span class="line"><span class="function">        : <span class="title">pHealthCalc</span><span class="params">(phcf)</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pHealthCalc-&gt;calc(*<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        HealthCalcFunc* pHealthCalc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个解法的吸引力在于，熟悉标准Strategy模式的人很容易辨认它，而且它还提供“将一个既有的健康算法纳入使用”的可能性——只要为HealthCalcFunc继承体系添加一个derived class即可。</p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>&emsp;&emsp;本条款的根本忠告是。当你为解决问题而寻找某个设计方法时，不妨考虑virtual函数的替代方案：</p>
<ul>
<li><p>使用non-virtual interface（NVI）手法，这是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性的virtual函数。</p>
</li>
<li><p>将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。</p>
</li>
<li><p>以std::function成员变量替换virtual函数，因而允许使用任何可调用物（callable entity）搭配一个兼容于需求的签名式。这也是Strategy设计模式的某种形式。</p>
</li>
<li><p>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。</p>
</li>
</ul>
<p>&emsp;&emsp;以上并未彻底而详尽地列出virtual函数的所有替换方案，但应该足够让你知道的确有不少替换方案。此外，它们各有其相对的优点和缺点，你应该把它们全部列入考虑。</p>
<p>&emsp;&emsp;为避免陷入面向对象设计路上因常规而形成的凹洞中，偶尔我们需要对着车轮猛推一把。这个世界还有其他许多道路，值得我们花时间加以研究。</p>
<blockquote>
<ul>
<li>virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式。</li>
<li>将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</li>
<li>std::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式兼容”的所有可调用物。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>考虑写出一个不抛出异常的swap函数</title>
    <url>/2020/08/05/%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="考虑写出一个不抛出异常的swap函数"><a href="#考虑写出一个不抛出异常的swap函数" class="headerlink" title="考虑写出一个不抛出异常的swap函数"></a>考虑写出一个不抛出异常的swap函数</h1><p>&emsp;&emsp;swap是个有趣的函数。原本它只是STL的一部分，而后成为异常安全性编程的脊柱，以及用来处理自我赋值可能性的一个常见机制。由于swap如此有用，适当的实现很重要。然而在非凡的重要性之外它也带来了非凡的复杂性。</p>
<p>&emsp;&emsp;所谓swap两对象值，意思是将两对象的值彼此赋予对方。缺省情况下swap动作可由标准程序库提供的swap算法完成。其典型实现完全如你所预期：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;只要类型T支持copying（通过copy构造函数和copy assignment操作符完成），缺省的swap实现代码就会帮你置换类型为T的对象，你不需要为此另外再做任何工作。</p>
<p>&emsp;&emsp;这缺省的swap实现版本十分平淡，无法刺激你的肾上腺。它涉及三个对象的复制：a复制到temp，b复制到a，以及temp复制到b。但是对某些类型而言，这些复制动作无一必要；对它们而言swap缺省行为等于是把高速公路铺设在慢速小巷内。</p>
<p>&emsp;&emsp;其中最主要的就是“以指针指向一个对象，内含真正数据”那种类型。这种设计的常见表现形式是所谓“pimpl手法”。如果是以这种手法设计Widget class，看起来会像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span>          <span class="comment">//针对Widget数据而设计的class</span></span><br><span class="line"><span class="keyword">public</span>:                     <span class="comment">//细节不重要</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b, c;            <span class="comment">//可能有很多数据，</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; v;  <span class="comment">//意味复制时间很长</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>       </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs) &#123;  <span class="comment">//复制Widget时，令它复制其WidgetImpl对象</span></span><br><span class="line">        ...                                 <span class="comment">//关于operator=的一般性实现细节</span></span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一旦要置换两个Widget对象值，我们唯一需要做的就是置换其pImpl指针，但缺省的swap算法不知道这一点。它不只复制三个Widget，还复制三个WidgetImpl对象，非常缺乏效率！一点也不令人兴奋。</p>
<p>&emsp;&emsp;我们希望能够告诉std::swap：当Widget被置换时真正该做的是置换其内部的pImpl指针。确切实践这个思路的一个做法是：将std::swap针对Widget特化。下面是基本构想，但目前这个形式无法通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;  <span class="comment">//目前还不能通过编译。</span></span><br><span class="line">    swap(a.pImpl, b.pImpl);                <span class="comment">//只要置换其pImpl指针就好了。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个函数一开始的“template&lt;&gt;”表示它是std::swap的一个全特化版本，函数名称之后的“&lt;Widget&gt;”表示这一特化版本是针对“T是Widget”而设计。换句话说当一般性的swap template施行于Widget身上便会启用这个版本。通常我们不能够（不被允许）改变std命名空间内的任何东西，但可以为标准template制造特化版本，使它专属于我们自己的class。以上作为正是如此。</p>
<p>&emsp;&emsp;但是，这个函数无法通过编译。因为它企图访问a和b内的pImpl指针，而那却是private。我们可以将这个特化版本说明为friend，但和以往的规矩不太一样：我们令Widget声明一个名为swap的public成员函数做真正的置换工作，然后将std::swap特化，令它调用该成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(pImpl, other.pImpl);  <span class="comment">//若要置换Widget就置换其pImpl指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b) &#123;</span><br><span class="line">    a.swap(b);  <span class="comment">//若要置换Widget，调用其swap成员函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种做法不只能够通过编译，还与STL容器有一致性，因为所有STL容器也都提供有public swap成员函数和std::swap特化版本（用以调用前者）。</p>
<p>&emsp;&emsp;然而假设Widget和WidgetImpl都是class template而非class，也许我们可以试试将WidgetImpl内的数据加以参数化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在Widget内（以及WidgetImpl内，如果需要的话）放个swap成员函数就像以往一样简单，但我们却在特化std::swap时遇上乱流。我们想写成这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> swap&lt; Widget&lt;T&gt; &gt; (Widget&lt;T&gt;&amp; a, Widget&lt;T&gt; b) &#123;  <span class="comment">//错误！不合法！</span></span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;看起来合情合理，却不合法。是这样的，我们企图偏特化一个function template（std::swap），但C++只允许对class template偏特化，在function template身上偏特化是行不通的。这段代码不该通过编译（虽然有些编译器错误地接受了它）。</p>
<p>&emsp;&emsp;当你打算偏特化一个function template时，习惯做法是简单地为它添加一个重载版本，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;  <span class="comment">//这也不合法</span></span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一般而言，重载functon template没有问题，但std是个特殊的命名空间，其管理规则也比较特殊。客户可以全特化std内的template，但不可以添加新的template（或class或function或其它任何东西）到std里头。std的内容完全由C++标准委员会决定，标准委员会禁止我们膨胀那些已经声明好的东西。所谓“禁止”可能会使我们沮丧，其实跨越红线的程序几乎仍可以编译和执行，但它们的行为没有明确定义，如果你希望你的软件有可预期的行为，请不要添加任何新东西到std里头。</p>
<p>&emsp;&emsp;那该如何是好？毕竟我们总是需要一个办法让其它人调用swap时能够取得我们提供的高效的template特定版本。答案很简单，我们还是声明一个non-member swap让它调用member swap，但不再将那个non-member swap声明为std::swap的特化版本或重载版本。为求简化起见，假设Widget的所有相关机能都被置于命名空间WidgetStuff内，整个结果看起来便像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WidgetStuff &#123;</span><br><span class="line">...                   <span class="comment">//模版化的WidgetImpl等等</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//同前，内含swap成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span> ... &#125;;</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，任何地点的任何代码如果打算置换两个Widget对象，因而调用swap，C++的名称查找法则会找到WidgetStuff内的Widget专属版本。那正是我们所要的。</p>
<p>&emsp;&emsp;这个做法对class和class template都行得通，所以似乎我们应该在任何时候都使用它，不幸的是有一个理由使你应该为class特化std::swap，所以如果你想让你的“class专属版”swap在尽可能多的语境下被调用，你需得同时在该class所在命名空间内写一个non-member版本以及一个std::swap特化版本。</p>
<p>&emsp;&emsp;顺带一提，如果没有像上面那样额外使用某个命名空间，上述每件事仍然适用（也就是说你还是需要一个non-member swap来调用member swap）。但，何必在global命名空间内塞满各式各样的class，template，functioin，enum，enumerant以及typedef名称呢？难道你对所谓“得体与适度”失去判断力了吗？</p>
<p>&emsp;&emsp;目前为止我所写的每一样东西都和swap编写者有关。换位思考，从客户观点看看事情也有必要。假设你正在写一个function template，其内需要置换两个对象值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;应该调用哪个swap？是std既有的那个一般化版本？还是某个可能存在的特化版本？抑或是一个可能存在的T专属版本而且可能栖身于某个命名空间（但当然不可能是std）内？你希望的应该是调用T专属版本，并在该版本不存在的情况下调用std内的一般化版本。下面是你希望发生的事：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(T&amp; obj1, T&amp; obj2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;   <span class="comment">//令std::swap在此函数内可用</span></span><br><span class="line">    ...</span><br><span class="line">    swap(obj1, obj2);  <span class="comment">//为T型对象调用最佳swap版本</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一旦编译器看到对swap的调用，它们便查找适当的swap并调用之。C++的名称查找法则确保将找到global作用域或T所在之命名空间内的任何T专属的swap。如果T是Widget并位于命名空间WidgetStuff内，编译器会使用“实参取决之查找范围”找出WidgetStuff内的swap。如果没有T专属之swap存在，编译器就使用std内的swap，只得感谢using声明式让std::swap在函数内曝光。然而即便如此编译器还是比较喜欢std::swap的T专属特化版，而非一般化的那个template，所以如果你已针对T将std::swap特化，特化版会被编译器挑中。</p>
<p>&emsp;&emsp;因此，令适当的swap被调用是很容易的。需要小心的是，别为这一调用添加额外修饰符，因为那会影响C++挑选适当函数。假设你以这种方式调用swap：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::swap(obj1, obj2);  <span class="comment">//这是错误的swap调用方式</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这便迫使编译器只认std内的swap（包括其任何template特化），因而不再可能调用一个定义于它处的较适当T专属版本。某些迷途程序员的确以此方式修饰swap调用式，而那正是“你的class对std::swap进行全特化”的重要原因：它使得类型专属之swap实现版本也可被这些“迷途代码”所用（这样的代码出现在某些标准程序库实现版中，如果你有兴趣不妨帮助这些代码尽可能高效运作）。</p>
<p>&emsp;&emsp;此刻，我们已经讨论过default swap、member swap、non-member swap、std::swap特化版本、以及对swap的调用，现在让我把整个形势做个总结。</p>
<p>&emsp;&emsp;首先，如果swap的缺省实现版的效率不足（那几乎总是意味你的class或template使用了某种pimpl手法），试着做以下事情：</p>
<ol>
<li>提供一个public swap成员函数，让它高效地置换你的类型的两个对象值。这个函数绝不该抛出异常。</li>
<li>在你的class或template所在的命名空间内提供一个non-member swap，并令它调用上述swap成员函数。</li>
<li>如果你正编写一个class（而非class template），为你的class特化std::swap。并令它调用你的swap成员函数。</li>
</ol>
<p>&emsp;&emsp;最后，如果你调用swap，请确定包含一个using声明式，以便让std::swap在你的函数内曝光可见，然后不加任何namespace修饰符，赤裸裸地调用swap。</p>
<p>&emsp;&emsp;唯一还未明确的是我的劝告：成员版swap绝不可抛出异常。那是因为swap的一个最好的应用是帮助class（和class template）提供强烈的异常安全性保障。但此技术基于一个假设：成员版的swap绝不抛出异常。这一约束只施行于成员版！不可施行于非成员版，因为swap缺省版本是以copy构造函数和copy assignment操作符为基础，而一般情况下两者都允许抛出异常。因此当你写下一个自定版本的swap，往往提供的不只是高效置换对象值的办法，而且不抛出异常。一般而言这两个swap特性是连在一起的，因为高效率的swap几乎总是基于对内置类型的操作（例如pimpl手法的底层指针），而内置类型上的操作绝不会抛出异常。</p>
<blockquote>
<p>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数部抛出异常。</p>
<p>如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于class（而非template），也请特化std::swap。</p>
<p>调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</p>
<p>为“用户定义类型”进行std template全特化是好的，但千万不要尝试在std内加入某些队std而言全新的对象。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>若不想使用编译器自动生成的函数就该明确拒绝</title>
    <url>/2020/07/21/%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D/</url>
    <content><![CDATA[<hr>
<h1 id="编译器“令人头疼”的“暗箱操作”"><a href="#编译器“令人头疼”的“暗箱操作”" class="headerlink" title="编译器“令人头疼”的“暗箱操作”"></a>编译器“令人头疼”的“暗箱操作”</h1><p>&emsp;&emsp;地产中介商卖的是房子，一个中介软件系统自然而然想必有个class用来描述待售房屋：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每一位地产中介商都会说，任何一笔交易都是独一无二的，没有两笔完全相像。因此我们也认为，为HomeForSale对象做一份副本有点没道理。我们怎么可以复制某些先天独一无二的东西呢？因此，我们应该乐意看到HomeForSale的对象拷贝动作以失败收场：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HomeForSale h1;</span><br><span class="line">HomeForSale h2;</span><br><span class="line"><span class="function">HomeForSale <span class="title">h3</span><span class="params">(h1)</span></span>;  <span class="comment">//企图拷贝h1，不该通过编译</span></span><br><span class="line">h1 = h2;             <span class="comment">//企图拷贝h2，也不该通过编译</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;通常如果我们不希望class支持某一个特定功能，只要不声明对应函数就是了。但这个策略对copy构造函数和copy assignment操作符却不起作用，因为如果我们不声明它们，而某些人尝试调用它们，编译器会为我们声明它们。</p>
<h1 id="明确拒绝编译器的“暗箱操作”"><a href="#明确拒绝编译器的“暗箱操作”" class="headerlink" title="明确拒绝编译器的“暗箱操作”"></a>明确拒绝编译器的“暗箱操作”</h1><p>&emsp;&emsp;这使我们陷入了两难的境况。问题的关键是，所有编译器产出的函数都是public。为阻止这些函数被创建出来。我们得自行声明它们，但这里并没有什么需求使我们必须将它们声明为public。因此我们可以将copy构造函数或copy assignment操作符声明为private。明确声明一个成员函数，我们阻止了编译器暗自创建其专属版本；而令这些函数为private，使我们得以成功阻止人们调用它。</p>
<p>&emsp;&emsp;一般而言这个做法并不绝对安全，因为member函数和friend函数还是可以调用我们的private函数。除非我们足够聪明，不去定义它们，那么如果某些人不慎调用任何一个，会获得一个连接错误（Linkage error）。“将成员函数声明为private而且故意不实现它们”这一技术是广受欢迎的，因而被用在C++ iostream程序库中阻止copy行为。没错，当我们看看手上的标准程序库实现代码中的ios_base，basic_ios和sentry。我们会发现无论哪一个，其copy构造函数和copy assignment操作符都被声明为private而且没有定义。</p>
<p>&emsp;&emsp;将这个技巧用于HomeForSale也很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">    HomeForSale(<span class="keyword">const</span> HomeForSale);  <span class="comment">//只有声明</span></span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;或许你注意到了，我没有写函数参数的名称。其实，参数名称并非必要，只不过大家总是习惯写出来。这个函数毕竟不会被实现出来，也很少被使用，指定参数名称又有何用？</p>
<p>&emsp;&emsp;有了上述class定义，当客户企图拷贝HomeForSale对象，编译器会阻挠他，如果我们不慎在member函数或friend函数之内那么做，就轮到连接器发出抱怨了。</p>
<p>&emsp;&emsp;将连接期错误移至编译期是可能的（而且这是好事，毕竟越早侦测出错误越好），只要将copy构造函数和copy assignment操作符声明为private就可以办到，但不是在HomeForSale自身，而是在一个专门为了阻止copy动作而设计的base class内。这个base class非常简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:          <span class="comment">//允许derived对象构造和析构             </span></span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);  <span class="comment">//但阻止copy</span></span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为求阻止HomeForSale对象被拷贝，我们唯一需要做的就是继承Uncopyable：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span> <span class="keyword">private</span> Uncopyable &#123;  <span class="comment">//不再声明</span></span><br><span class="line">    ...                                  <span class="comment">//copy构造函数或</span></span><br><span class="line">&#125;;                                       <span class="comment">//copy assignment操作符</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是可行的，因为只要任何人——甚至是member函数或friend函数——尝试拷贝HomeForSale对象，编译器便试着生成一个copy构造函数和一个copy assignment操作符，这些函数的“编译器生成版”会尝试调用其base class的对应兄弟，那些调用会被编译器拒绝，因为其base class的拷贝函数是private。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li>为驳回编译器自动提供的功能，可将相应的成员函数声明为private并且不予实现。使用像Uncopyable这样的base class也是一种做法。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义new和delete的规则</title>
    <url>/2020/11/30/%E8%87%AA%E5%AE%9A%E4%B9%89new%E5%92%8Cdelete%E7%9A%84%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<hr>
<h1 id="C-关于new的奇怪规定"><a href="#C-关于new的奇怪规定" class="headerlink" title="C++关于new的奇怪规定"></a>C++关于new的奇怪规定</h1><p>&emsp;&emsp;在new的规定上面，C++有一点非常奇怪，即使客户要求0bytes，operator new也得返回一个合法指针。这种看似诡异的行为其实是为了简化C++这个语言联邦中的其他“语言成分”。以下是个non-memer operator new伪码：</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>) &#123;  <span class="comment">//处理0-byte申请</span></span><br><span class="line">        <span class="built_in">size</span> = <span class="number">1</span>;    <span class="comment">//将它视为1-byte申请</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        尝试分配<span class="built_in">size</span> bytes;</span><br><span class="line">        <span class="keyword">if</span>(分配成功)</span><br><span class="line">        <span class="keyword">return</span> (一个指针，指向分配得来的内存);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//分配失败；找出目前的new-handler函数</span></span><br><span class="line">        new_handler globalHandler = set_new_handler(<span class="number">0</span>);</span><br><span class="line">        set_new_handler(globalHandler);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(globalHandler) (*globalHandler)();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;你可能会觉得这份代码有点奇怪，它将new-handler函数指针设为null而后又立刻恢复原样。但这是没有办法的事情，因为我们无法直接取得new-handler函数指针，所以必须调用set_new_handler找出它来。</p>
<h1 id="operator-new无限循环内所做的事情"><a href="#operator-new无限循环内所做的事情" class="headerlink" title="operator new无限循环内所做的事情"></a>operator new无限循环内所做的事情</h1><p>&emsp;&emsp;上述伪码内有一个无限循环。退出此循环的唯一办法是：内存被成功分配或new-handler函数使用到了“<a href="/2020/11/23/%E5%AF%B9new-handler%E8%BF%99%E4%B8%80%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8E%A2%E8%AE%A8/" title="对new-handler这一技术的探讨">对new-handler这一技术的探讨</a>”内所谈及到的技术：让更多内存可用、安装另一个new-handler、卸除new-handler、抛出bad_alloc异常（或其派生物），或是承认失败而直接return。</p>
<h1 id="operator-new／delete成员函数会被derived-class继承"><a href="#operator-new／delete成员函数会被derived-class继承" class="headerlink" title="operator new／delete成员函数会被derived class继承"></a>operator new／delete成员函数会被derived class继承</h1><p>&emsp;&emsp;operator new成员函数会被derived class继承，这会导致某些有趣的复杂度。定制型内存管理器是为针对某特定class的对象内存分配行为提供最佳的优化，而不是为了该class的任何derived class。也就是说，针对class X而设计的operator new，其行为只是为大小刚好为sizeof(X)的对象而设计的。然而一旦被继承下去，有可能base class的operator new被调用用以分配derived class对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; ... &#125;;  <span class="comment">//假设Derived未声明operator new</span></span><br><span class="line">Derived* p = <span class="keyword">new</span> Derived;             <span class="comment">//这里调用的是Base::operator new</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果Base class专属的operator new并非是用来为Derived class服务的，那么处理这种情况的最佳做法是将“内存申请量错误”的调用行为改为采用标准operator new，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* Base::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> != <span class="keyword">sizeof</span>(Base))          <span class="comment">//如果大小错误，</span></span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="built_in">size</span>);  <span class="comment">//让标准的operator new来处理</span></span><br><span class="line">    ...                               <span class="comment">//否则在这里处理。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这里，我们将“检验size等于0的情况”与“size与sizeof(Base)的检测”融合在一起了。C++认为所有的非附属（独立式）对象必须有非零大小（见“<a href="/2020/11/12/%E6%98%8E%E6%99%BA%E8%80%8C%E5%AE%A1%E6%85%8E%E5%9C%B0%E4%BD%BF%E7%94%A8private%E7%BB%A7%E6%89%BF/" title="明智而审慎地使用private继承">明智而审慎地使用private继承</a>”。因此sizeof(Base)无论如何不能为零，所以如果size是0，这份申请会被转交到::operator new手上，后者必须以某种合理的方式来处理这种情况。</p>
<h1 id="C-关于delete的规定"><a href="#C-关于delete的规定" class="headerlink" title="C++关于delete的规定"></a>C++关于delete的规定</h1><p>&emsp;&emsp;operator new情况比new要简单些，你唯一需要记住的就是C++保证“删除null指针永远安全”，所以你必须兑现这份承诺。下面是non-member operator delete的伪码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//如果被删除的是个null指针，</span></span><br><span class="line">                                <span class="comment">//那就什么都不做。</span></span><br><span class="line">    现在，归还rawMemory所指的内存;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个函数的member版本也很简单，只需要多加一个动作检查删除数量。万一你的class专属的operator new将大小有误的分配行为转交::operator new执行，你也必须将大小有误的删除行为转交::operator delete执行：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::bad_alloc)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> Base::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* rawMemory, <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="built_in">size</span>)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rawMemory == <span class="number">0</span>) <span class="keyword">return</span>;  <span class="comment">//检查null指针。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> != <span class="keyword">sizeof</span>(Base)) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(rawMemory)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    现在，归还rawMemory所指的内存;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ul>
<li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0bytes申请。class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
<li>operator delete应该在收到null指针时不做任何事。class专属版本则还应该处理“比正确大小更大的（错误）申请”。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>若所有参数皆需类型转换，请为此采用non-member函数</title>
    <url>/2020/08/04/%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8non-member%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<hr>
<h1 id="若所有参数皆需类型转换，请为此采用non-member函数"><a href="#若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="若所有参数皆需类型转换，请为此采用non-member函数"></a>若所有参数皆需类型转换，请为此采用non-member函数</h1><p>&emsp;&emsp;令class支持隐式类型转换通常是个糟糕的主意。当然这条规则有其例外，最常见的例外是在建立数据类型时。假设我们这样开始我们的Rational class：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rational(<span class="keyword">int</span> numerator = <span class="number">0</span>, <span class="keyword">int</span> denominator = <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numerator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">denominator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;你想支持算术运算诸如加法、乘法等等，但你不确定是否该由member函数、non-member函数，或可能的话由non-member friend函数来实现它们。你的直觉告诉你，当你犹豫就该保持面向对象精神。你知道有理数相乘和Rational class有关，因此很自然地似乎该在Rational class内为有理数实现operator*。先研究一下将operator*写成Rational成员函数的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个设计使你能够将两个有理数以最轻松自在的方式相乘：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Rational <span class="title">oneEight</span><span class="params">(<span class="number">1</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="function">Rational <span class="title">oneHalf</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Rational result = oneHalf * oneEight;  <span class="comment">//很好</span></span><br><span class="line">result = result * oneEight;            <span class="comment">//很好</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但我们还不满足。我们希望支持混合运算，也就是拿Rational和例如int相乘。毕竟很少有什么东西会比两个数值相乘更自然的来——即使是两个不同类型的数值。</p>
<p>&emsp;&emsp;然而当我们尝试混合式算术，我们发现只有一半行得通：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;  <span class="comment">//很好！</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这不是好兆头，乘法应该满足交换律，不是吗？</p>
<p>&emsp;&emsp;当我们以对应的函数形式重写上述两个式子，问题所在便一目了然：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf.<span class="keyword">operator</span>*(<span class="number">2</span>);  <span class="comment">//很好！</span></span><br><span class="line">result = <span class="number">2.</span><span class="keyword">operator</span>*(oneHalf);  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;没错，oneHalf是一个内含operator*函数的class的对象，所以编译器调用该函数。然而整数2并没有相应的class，也就没有operator*成员函数。编译器也会尝试寻找可被以下这般调用的non-member operator*（也就是在命名空间内或在global作用域内）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = <span class="keyword">operator</span>*(<span class="number">2</span>, oneHalf);  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;但本例根本并不存在这样一个接受int和Rational作为参数的non-member operator*，因此查找失败。</p>
<p>&emsp;&emsp;再看看先前成功的那个调用，注意其第二参数是整数2，但Rational::operator*需要的实参却是个Rational对象。这里发生了什么事？为什么2在这里可被接受，在另一个调用中却不被接受？</p>
<p>&emsp;&emsp;因为这里发生了所谓隐式转换。编译器知道你正在传递一个int，而函数需要的是Rational；但它也知道只要调用Rational构造函数并赋予你所提供的int，就可以变出一个适当的Rational来。于是它就那样做了。换句话说此调用动作在编译器眼中有点像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Rational <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;   <span class="comment">//根据2建立一个暂时性的Rational对象</span></span><br><span class="line">result = oneHalf * temp;  <span class="comment">//等同于oneHalf.operator*(temp)</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，只因为涉及non-explicit构造函数，编译器才会这样做。如果Rational构造函数是explicit，以下语句没有一个可通过编译：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;  <span class="comment">//错误！</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这就很难让Rational class支持混合式算术运算了，不过至少上述两个句子的行为从此一致。</p>
<p>&emsp;&emsp;然而我们的目标不仅在一致性，也要支持混合式运算。为什么即使Rational构造函数不是explicit，仍然只有一个可通过编译，另一个不可以：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = oneHalf * <span class="number">2</span>;  <span class="comment">//没问题（在non-explicit构造函数的情况下）</span></span><br><span class="line">result = <span class="number">2</span> * oneHalf;  <span class="comment">//错误（甚至在non-explicit构造函数的情况下）</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;结论是，只有当参数被列于参数列内，这个参数才是隐式类型转换的合格参与者。地位相当于“被调用的成员函数所隶属的那个对象”——即this对象——的那个隐喻参数，绝不是隐式转换的合格参与者。这就是为什么上述第一次调用可通过编译，第二次调用则否，因为第一次调用伴随一个放在参数列内的参数，第二次则否。</p>
<p>&emsp;&emsp;然而我们一定也会想要支持混合式算术运算。让operator*成为一个non-member函数，允许编译器在每一个实参身上执行隐式类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span> &#123;</span></span><br><span class="line">    ...  <span class="comment">//不包括operator*</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational&amp; lsh, <span class="keyword">const</span> Rational&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> Rational(lhs.numerator() * rhs.numerator(),</span><br><span class="line">                    lhs.denominator() * rhs.denominator());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">oneFourth</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * <span class="number">2</span>;</span><br><span class="line">result = <span class="number">2</span> * oneFourth;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这当然是个快乐的结局，不过还有一点必须操心：operator*是否应该成为Rational class的一个friend函数呢？</p>
<p>&emsp;&emsp;就本例而言答案是否定的，因为operator*可以完全藉由Rational的public接口完成任务，这导出一个重要的观察：member函数的反面是non-member，不是friend函数。太多C++程序员假设，如果一个“与某class相关”的函数不该成为一个member，就该是个friend。本例表明这样的理由过于牵强。无论何时如果我们可以避免friend函数就该避免，因为就像真实世界一样，朋友带来的麻烦往往多过其价值。当然有时候friend有其正当性，但这个事实依然存在：不能够只因函数不该成为member，就自动让它成为friend。</p>
<blockquote>
<p>如果你需要为某个函数的所有参数（包括this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>视C++为一个语言联邦</title>
    <url>/2020/07/17/%E8%A7%86C++%E4%B8%BA%E4%B8%80%E4%B8%AA%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6/</url>
    <content><![CDATA[<h1 id="视C-为一个语言联邦"><a href="#视C-为一个语言联邦" class="headerlink" title="视C++为一个语言联邦"></a>视C++为一个语言联邦</h1><p>&emsp;&emsp;一开始，C++只是C加上一些面向对象特性。C++最初的名称C with Classes也反映了这个血缘关系。</p>
<p>&emsp;&emsp;但是当这个语言逐渐成熟，它变得更活跃更无拘束，更大胆更冒险，开始接受不同于C with Classes的各种观念、特性和编程战略。Exception（异常）对函数的结构化带来不同的做法，templates（模板）将带来新的设计思考方式，STL则定义了一个全新的伸展性做法。</p>
<p>&emsp;&emsp;今天的C++已经是一个多重范型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。那么该如何理解这样的一个语言呢?</p>
<a id="more"></a>

<p>&emsp;&emsp;最简单的方法是将C++视为一个由相关语言组成的联邦而非单一语言。在其某个次语言中，各种守则与通例都倾向简单、直观易懂、并且容易记住。然而从一个次语言移往另一个次语言，守则可能改变。所幸的是C++的次语言总共只有四个：</p>
<ul>
<li>C。说到底C++仍是以C为基础。区块、语句、预处理器、内置数据类型、数组、指针等统统来自C。许多时候C++对问题的解法其实不过就是较高级的C解法。</li>
<li>Object-Oriented C++。这部分也就是C with Classes所诉求的：classes（包括构造函数和析构函数），封装、继承、多态、virtual函数（动态绑定）……等等。这一部分是面向对象设计之古典守则在C++上的最直接实施。</li>
<li>Template C++。这是C++的泛型编程部分，也是大多数程序员经验最少的部分（C++程序员）。实际上由于templates威力强大，它带来了崭新的编程范式，也就是所谓的templates metaprogramming（TMP，模板元编程）。</li>
<li>STL。STL是个tamplate程序库。它对容器、迭代器、算法以及函数对象的规约有极佳的紧密配合与协调。</li>
</ul>
<p>&emsp;&emsp;当我们从一个次语言切换到另一个，需要改变策略。例如对内置（也就是C-like）类型而言pass-by-value通常比pass-by-reference高效，但当我们从C part of C++移往Object-Oriented C++，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const往往更好。然而一旦跨入STL就会了解，迭代器和函数对象都是在C指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的C pass-by-value守则在此再次适用。</p>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>让接口容易被正确使用，不易被误用</title>
    <url>/2020/07/31/%E8%AE%A9%E6%8E%A5%E5%8F%A3%E5%AE%B9%E6%98%93%E8%A2%AB%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%93%E8%A2%AB%E8%AF%AF%E7%94%A8/</url>
    <content><![CDATA[<hr>
<h1 id="让接口容易被正确使用，不易被误用"><a href="#让接口容易被正确使用，不易被误用" class="headerlink" title="让接口容易被正确使用，不易被误用"></a>让接口容易被正确使用，不易被误用</h1><p>&emsp;&emsp;C++在接口之海漂浮。function接口、class接口、template接口……每一种接口都是客户与我们的代码互动的手段。理想上，如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码不该通过编译；如果代码通过了编译，它的作为就是客户所想要的。</p>
<p>&emsp;&emsp;欲开发一个“容易被正确使用，不容易被误用”的接口，首先必须考虑客户可能做出什么样的错误。假设我们为一个用来表现日期的class设计构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> month, <span class="keyword">int</span> day, <span class="keyword">int</span> year);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;乍看之下这个接口通情达理（至少在美国如此），但它的客户很容易犯下两个错误，第一，他们也许会以错误的次序传递参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>, <span class="number">2020</span>)</span></span>;  <span class="comment">//应该是“2，20”而不是“20，2”</span></span><br></pre></td></tr></table></figure>

<p>第二，他们可能传递一个无效的月份或天数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">3</span>, <span class="number">20</span>, <span class="number">2020</span>)</span>  <span class="comment">//应该是“2，20”而不是“3，20”</span></span></span><br></pre></td></tr></table></figure>

<p>（上面一个例子也许看起来很蠢，但别忘了，键盘上的2就在3旁边。打岔一个键的情况并不是太罕见。）</p>
<p>&emsp;&emsp;许多客户端错误可以因为导入新类型而获得预防。在防范“不值得拥有的代码”上，类型系统是我们的主要同盟国。既然这样，就让我们导入简单的外覆类型来区别天数、月份和年份，然后于Date构造函数中使用这些类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Day</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Day</span><span class="params">(<span class="keyword">int</span> d)</span>: <span class="title">val</span><span class="params">(d)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span>: <span class="title">val</span><span class="params">(m)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">year</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Year</span><span class="params">(<span class="keyword">int</span> y)</span>: <span class="title">val</span><span class="params">(y)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">const</span> Month&amp; m, <span class="keyword">const</span> Day&amp; d, <span class="keyword">const</span> Year&amp; y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>, <span class="number">2020</span>)</span></span>;                    <span class="comment">//错误！不正确的类型</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Day(<span class="number">20</span>), Month(<span class="number">2</span>), Year(<span class="number">2020</span>))</span></span>;  <span class="comment">//错误！不正确的类型</span></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">2</span>), Day(<span class="number">20</span>), Year(<span class="number">2020</span>))</span></span>;  <span class="comment">//正确！</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;令Day，Month和Year成为成熟且经过充分锻炼的class并封装其内部数据，比简单使用上述的struct好。但即使struct也已经足够示范：明智而谨慎地导入新类型对预防“接口被误用”有神奇疗效。</p>
<p>&emsp;&emsp;一旦正确的类型就位，限制其值有时候是通情达理的。例如一年只有12个月份，所以Month应该反映这一事实。办法之一是利用enum表现月份，但enums不具备我们希望拥有的类型安全性，例如enums可被拿来当一个int使用，比较安全的解法是预先定义所有有效的Month：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Month</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Jan</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">1</span>); &#125;  <span class="comment">//函数，返回有效月份</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Feb</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">2</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Month <span class="title">Dec</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Month(<span class="number">12</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Month</span><span class="params">(<span class="keyword">int</span> m)</span></span>;  <span class="comment">//阻止生成新的月份</span></span><br><span class="line">    ...                     <span class="comment">//这是月份专属数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month::Feb(), Day(<span class="number">20</span>), Year(<span class="number">2020</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;“以函数替代对象，表现某个特定月份”这并不像你所想象的那样诡异，这是因为non-local static对象的初始化次序有可能出现问题。</p>
<p>&emsp;&emsp;预防客户错误的另一个办法是，限制类型内什么事可做，什么事不能做。常见的限制是加上const。</p>
<p>&emsp;&emsp;避免无端与内置类型不兼容，真正的理由是为了提供行为一致的接口。很少有其它性质比得上“一致性”更能导致“接口容易被正确使用”，也很少有其它性质比得上“不一致性”更加剧接口的恶化。STL容器的接口十分一致（虽然不是完美地一致），这使它们非常容易被使用。例如每个STL容器都有一个名为size的成员函数，它会告诉调用者目前容器内有多少对象。与此对比的是Java，它允许我们针对数组使用length property，对String使用length method，而对List使用size method；.Net也一样混乱。有些开发人员会以为整合开发环境（IDE）能使这样的不一致性变得不重要，但他们错了。不一致性对开发人员造成的心理和精神上的摩擦与争执，没有任何一个IDE可以完全抹除。</p>
<p>&emsp;&emsp;任何接口如果要求客户必须记得做某些事情，就是有着“不正确使用”的倾向，因为客户有可能会忘记做那件事。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment* <span class="title">createInvestment</span><span class="params">()</span></span>;  ／／factory函数</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;为避免资源泄漏，createInvestment返回的指针最终必须被删除，但这至少给了客户两个犯错的机会：没有删除指针，或删除同一个指针超过一次。</p>
<p>&emsp;&emsp;许多时候较佳接口的设计原则是先发制人，就令factory函数返回一个智能指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这便实质上强迫客户将返回值存储于一个shared_ptr内，几乎消除了忘记删除底部Investment对象的可能性。</p>
<p>&emsp;&emsp;shared_ptr允许当智能指针被建立起来时指定一个资源释放函数（所谓删除器，“deleter”）绑定于智能指针身上。</p>
<p>&emsp;&emsp;假设class设计者期许那些“从createInvestment取得Investment*指针”的客户将该指针传递给一个名为getRidOfInvestment的函数，而不是直接在它身上动刀子（使用delete）。这样一个接口又开启通往另一个客户错误的大门，该错误是“企图使用错误的资源析构机制”（也就是拿delete替换getRidOfInvestment）。createInvestment的设计者可以针对此问题先发制人：返回一个“将getRidOfInvestment绑定为删除器（deleter）”的shared_ptr。</p>
<p>&emsp;&emsp;shared_ptr提供的某个构造函数接受两个实参：一个是被管理的指针，另一个是引用次数变成0时将被调用的“删除器”。这启发我们创建一个null shared_ptr并以getRidOfInvestment作为其删除器，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(<span class="number">0</span>, getRidOfInvestment)</span></span>; </span><br><span class="line"><span class="comment">//此式无法通过编译</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这并不是有效的C++。shared_ptr构造函数坚持其第一参数必须是个指针，而0不是指针，是个int。没错，它可被转换为指针，但在此情况下并不够好，因为shared_ptr坚持要一个不折不扣的指针。转型可以解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt;</span><br><span class="line">    pInv(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>),</span><br><span class="line">        getRidOfInvestment);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;因此，如果我们要实现createInvestment使它返回一个shared_ptr并夹带getRidOfInvestment函数作为删除器，代码看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">retVal</span><span class="params">(<span class="keyword">static_cast</span>&lt;Investment*&gt;(<span class="number">0</span>),</span></span></span><br><span class="line"><span class="function"><span class="params">                                       getRidOfInvestment)</span></span>;</span><br><span class="line">    retVal = ...;  <span class="comment">//令retVal指向正确对象</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然啦，如果被pInv管理的原始指针可以在建立pInv之前先确定下来，那么“将原始指针传给pInv构造函数”会比“先将pInv初始化为null再对它做一次赋值操作”为佳。</p>
<p>&emsp;&emsp;shared_ptr有一个特别好的性质是：它会自动使用它的“每个指针专属的删除器”，因而消除另一个潜在的客户错误：所谓的“cross-DLL problem”。这个问题发生于“对象在动态链接程序库（DLL）中被new创建，却在另一个DLL内被delete销毁”。在许多平台上，这一类“跨DLL之new／delete成对运用”会导致运行期错误。shared_ptr没有这个问题，因为它缺省的删除器是来自“shared_ptr诞生所在的那个DLL”的delete。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">createInvestment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt;(<span class="keyword">new</span> Stock);  <span class="comment">//Stock派生自Investment</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;返回的那个shared_ptr可被传递给任何其它DLL，无需在意“cross-DLL problem”。这个指向Stock的shared_ptr会追踪记录“当Stock的运用次数变成0时该调用的那个DLL’s delete”。</p>
<p>&emsp;&emsp;shared_ptr是原始指针的两倍大，以动态分配内存作为记录用途和“删除器的专属数据”，并以virtual形式调用删除器，并在多线程程序修改运用次数时承受线程同步化的额外开销。（只要定义一个预处理器符号就可以关闭多线程支持）。总之，它比原始指针大且慢，而且使用辅助动态内存。在许多运用程序中这些额外的执行成本并不显著。然而其“降低客户错误”的成效却是每个人都看得到的。</p>
<blockquote>
<p>好的接口很容易被正确使用，不容易被误用。我们应该在所有的接口中努力达成这些性质</p>
<p>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</p>
<p>“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。</p>
<p>shared_ptr支持定制删除器。这可防范DLL问题，可被用来自动解除互斥锁等等。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>透彻了解inlining的里里外外</title>
    <url>/2020/08/12/%E9%80%8F%E5%BD%BB%E4%BA%86%E8%A7%A3inlining%E7%9A%84%E9%87%8C%E9%87%8C%E5%A4%96%E5%A4%96/</url>
    <content><![CDATA[<hr>
<h1 id="透彻了解inlining的里里外外"><a href="#透彻了解inlining的里里外外" class="headerlink" title="透彻了解inlining的里里外外"></a>透彻了解inlining的里里外外</h1><p>&emsp;&emsp;inline函数，多棒的点子！它们看起来像函数，动作像函数，比宏好得多（见“<a href="/2020/07/17/%E5%B0%BD%E9%87%8F%E4%BB%A5const,enum,inline%E6%9B%BF%E6%8D%A2define/" title="尽量以const,enum,inline替换define">尽量以const,enum,inline替换define</a>”），可以调用它们又不需要蒙受函数调用所招致的额外开销。你还能要求更多吗？</p>
<p>&emsp;&emsp;你实际获得的比想到的还多，因为“免除函数调用成本”只是故事的一部分而已。编译器最优化机制通常被设计用来浓缩那些“不含函数调用”的代码，所以当你inline某个函数，或许编译器就因此有能力对它（函数本体）执行语境相关最优化。大部分编译器绝不会对着一个“outlined函数调用”动作执行如此之最优化。</p>
<a id="more"></a>

<p>&emsp;&emsp;然而编写程序就像现实生活一样，没有白吃的午餐。inline函数也不例外。inline函数背后的整体观念是，将“对此函数的每一个调用”都以函数本体替换之。我想不需要统计学博士来告诉你，这样做可能增加你的目标码大小。在一台内存有限的机器上，过度热衷inlining会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline造成的代码膨胀亦会导致额外的换页行为，降低指令高速缓存装置的击中率，以及伴随这些而来的效率损失。</p>
<p>&emsp;&emsp;换个角度说，如果inline函数的本体很小，编译器针对“函数本体”所产出的码可能比针对“函数调用”所产出的码更小。果真如此，将函数inlining确实可能导致较小的目标码和较高的指令高速缓存装置击中率！</p>
<p>&emsp;&emsp;记住，inline只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出。隐喻方式是将函数定义于class定义式内：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> theAge; &#125;  <span class="comment">//一个隐喻的inline申请</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的函数通常是成员函数，但friend函数也可被定义于class内，如果真是那样，它们也是被隐喻声明为inline。</p>
<p>&emsp;&emsp;明确声明inline函数的做法则是在其定义式前加上关键字inline。例如标准的max template（来自&lt;algorithm&gt;）往往这样实现出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> T&amp; <span class="title">std::max</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span> </span>&#123;  <span class="comment">//明确申请inline</span></span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;“max是个template”带出了一项观察结果：我们发现inline函数和template两者通常都是被定义于头文件内。这使得某些程序员以为function template一定必须是inline。这个结论不但无效而且可能有害，值得深入看一看。</p>
<p>&emsp;&emsp;inline函数通常一定被置于头文件内，因为大多数建置环境在编译过程中进行inlining，而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。某些建置环境可以在连接期完成inlining，少量建置环境如基于.NET CLI（Common Language Infrastructure：公共语言基础设施）的托管环境竟可在运行期完成inlining。然而这样的环境毕竟是例外，不是通例。inlining在大多数C++程序中是编译期行为。</p>
<p>&emsp;&emsp;template通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道它长什么样子。（某些建置环境可以在连接期才执行template具现化。只不过编译期完成具现化动作比较常见。）</p>
<p>&emsp;&emsp;template的具现化与inlining无关。如果你正在写一个template而你认为所有根据此template具现出来的函数都应该inline，请将此template声明为inline：这就是上述std::max代码的作为。但如果你写的template没有理由要求它所具现的每一个函数都是inline，就应该避免将这个template声明为inline（不论显式或隐式）。inlining需要成本，你不会想在没有事先考虑的情况下就招来那些成本吧。我已经提过inlining如何引发代码膨胀，但还存在其它成本，稍后再讨论。</p>
<p>&emsp;&emsp;现在让我们先结束“inline是个申请，编译器可以加以忽略”的观察。大部分编译器拒绝将太过复杂的函数inlining，而所有对virtual函数的调用也都会使inlining落空。这不该令你惊讶，因为virtual意味“等待，知道运行期才确定调用哪个函数”，而inline意味“执行前，先将调用动作替换为被调用函数本体”。如果编译器不知道该调用哪个函数，你就很难责备它们拒绝将函数本体inlining。</p>
<p>&emsp;&emsp;这些整合起来的意思就是：一个表面上看似inline的函数是否真是inline，取决于你的建置环境，主要取决于编译器。幸运的是大多数编译器提供了一个诊断级别：如果它们无法将你要求的函数inline化，会给你一个警告信息。</p>
<p>&emsp;&emsp;有时候虽然编译器有意愿inlining某个函数，还是可能为该函数生成一个函数本体。举个例子，如果程序要取某个inline函数的地址，编译器通常必须为此函数生成一个outline函数本体。毕竟编译器哪有能力提出一个指针指向并不存在的函数呢？与此并提的是，编译器通常不对“通过函数指针而进行的调用”实施inlining，这意味对inline函数的调用有可能被inline，也可能不被inline，取决于对该调用的实施方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="keyword">void</span> (*pf)() = f;  <span class="comment">//pf指向f</span></span><br><span class="line">...</span><br><span class="line">f();   <span class="comment">//这个调用将被inline，因为它是一个正常调用</span></span><br><span class="line">pf();  <span class="comment">//这个调用或许不被inline，因为它通过函数指针达成</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;即使你从未使用函数指针，“未被成功inline”的inline函数还是有可能缠住你，因为程序员并非唯一要求函数指针的人。有时候编译器会生成构造函数和析构函数的outline副本，如此一来它们就可以获得指针指向那些函数，在array内部元素的构造和析构过程中使用。</p>
<p>&emsp;&emsp;实际上构造函数和析构函数往往是inlining的糟糕候选人——虽然漫不经心的情况下你不会这么认为。考虑以下Derived class构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bm1, bm2;  <span class="comment">//base成员1和2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> dm1, dm2, dm3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个构造函数看起来是inlining的绝佳候选人，因为它根本不含任何代码。但是你的眼睛可能会欺骗你。</p>
<p>&emsp;&emsp;C++对于“对象被创建和被销毁时发生什么事”做了各式各样的保证。当你使用new，动态创建的对象被其构造函数自动初始化；当你使用delete，对应的析构函数会被调用。当你创建一个对象，其每一个base class及每一个成员变量都会被自动构造；当你销毁一个对象，反向程序的析构行为亦会自动发生。如果有个异常在对象构造期间被抛出，该对象已构造好的那一部分会被自动销毁。在这些情况中C++描述了什么一定会发生，但没有说如何发生。“事情如何发生”是编译器实现者的权责，不过至少有一点很清楚，那就是它们不可能凭空发生。你的程序内一定有某些代码让那些事情发生，而那些代码——由编译器于编译期代为产生并安插到你的程序中的代码——肯定存在于某个地方。有时候就放在你的构造函数和析构函数内，所以我们可以想象，编译器为稍早说的那个表面上看起来为空的Derived构造函数所产生的代码，相当于以下所列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived::Derived() &#123;</span><br><span class="line">    Base::Base();                       <span class="comment">//初始化“Base成分”</span></span><br><span class="line">    <span class="keyword">try</span> &#123; dm1.<span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(); &#125;  <span class="comment">//试图构造代码dm1</span></span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;                        <span class="comment">//如果抛出异常就</span></span><br><span class="line">        Base::~Base();                  <span class="comment">//销毁base class成分，并</span></span><br><span class="line">        <span class="keyword">throw</span>;                          <span class="comment">//传播该异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm2.<span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        dm1.<span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>();</span><br><span class="line">        Base::~Base();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; dm3.<span class="built_in">std</span>::<span class="built_in">string</span>::<span class="built_in">string</span>(); &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        dm2.<span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>();</span><br><span class="line">        dm1.<span class="built_in">std</span>::<span class="built_in">string</span>::~<span class="built_in">string</span>();</span><br><span class="line">        Base::~Base();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码并不能代表编译器真正制造出来的代码，因为真正的编译器会以更精致复杂的做法来处理异常，尽管如此，这已能准确反映Derived的空白构造函数必须提供的行为。不论编译器在其内所做的异常处理多么精致复杂，Derived构造函数至少一定会陆续调用其成员变量和base class两者的构造函数，而那些调用会影响编译器是否对此空白函数inlining。</p>
<p>&emsp;&emsp;相同的道理也适用于Base构造函数，所以如果它被inline，所有替换“Base构造函数调用”而插入的代码也都会被插入到“Derived构造函数调用”内（因为Derived构造函数调用了Base构造函数）。试想下这对于上述代码会带来怎样的灾难。</p>
<p>&emsp;&emsp;程序库设计者必须评估“将函数声明为inline”的冲击：inline函数无法随着程序库的升级而升级。换句话说如果f是程序库内的一个inline函数，客户将“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译。这往往是大家不愿意见到的。然而如果f是non-inline函数，一旦它有任何修改，客户端只需重新连接就好，远比重新编译的负担少很多。如果程序库采取动态连接，升级版函数甚至可以不知不觉地被应用程序吸纳。</p>
<p>&emsp;&emsp;对程序开发而言，将上述所有考虑牢记在心很是重要，但若从纯粹实用观点出发，有一个事实比其它因素更重要：大部分调试器面对inline函数都束手无策。这对你应该不是太大的意外。毕竟你如何在一个并不存在的函数内设立断点呢？虽然某些建置环境勉强支持对inline函数的调试，其它许多建置环境仅仅只能“在调试版程序中禁止发生inlining”。</p>
<blockquote>
<p>将太多inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。</p>
<p>不要只因为function template出现在头文件，就将它们声明为inline。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计class犹如设计type</title>
    <url>/2020/08/01/%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/</url>
    <content><![CDATA[<hr>
<h1 id="设计class犹如设计type"><a href="#设计class犹如设计type" class="headerlink" title="设计class犹如设计type"></a>设计class犹如设计type</h1><p>&emsp;&emsp;C++就像在其它OOP语言一样，当我们定义一个新class，也就定义了一个新type。身为C++程序员，我们的许多时间主要用来扩张我们的类型系统。这意味着我们并不只是class设计者，还是type设计者。</p>
<p>&emsp;&emsp;设计优秀的class是一项艰巨的工作，因为设计好的type是一项艰巨的工作。好的type有自然的语法，直观的语义，以及一或多个高效实现品。在C++中，一个不良规划下的class定义恐怕无法达到上述任何一个目标。</p>
<p>&emsp;&emsp;那么，如何设计高效的class呢？几乎每个class都要求我们面对以下提问，而我们的回答往往导致我们的设计规范：</p>
<a id="more"></a>

<ul>
<li><strong>新type的对象应该如何被创建和销毁？</strong>这会影响到我们的class的构造函数和析构函数以及内存分配函数和释放函数的设计，当然前提是如果我们打算编写它们。</li>
<li><strong>对象的初始化和对象的赋值该有什么样的差别？</strong>这个答案决定我们的构造函数和赋值操作符的行为，以及其间的差异。重要的是别混淆了“初始化”和赋值“，因为它们对应不同的函数调用。</li>
<li><strong>新type的对象如果被passed by value，意味着什么？</strong>记住，copy构造函数用来定义一个type的pass-by-value该如何实现。</li>
<li><strong>什么是新type的“合法值”？</strong>对class的成员变量而言，通常只有某些数值集是有效的，那些数值集决定了我们的class必须维护的约束条件，也就决定了我们的成员函数（特别是构造函数、赋值操作符和所谓“setter”函数）必须进行的错误检查工作，它也影响函数抛出的异常。</li>
<li><strong>你的新type需要配合某个继承图系吗？</strong>如果我们继承自某些既有的class，我们就受那些class的设计的束缚，特别是受到”它们的函数是virtual或non-virtual“的影响。如果我们允许其它class继承我们的class，这会影响我们所声明的函数——尤其是析构函数——是否为virtual。</li>
<li><strong>你的新type需要什么样的转化？</strong>如果希望允许类型T1之物被隐式转换为类型T2之物，就必须在class T1内写一个类型转换函数（operator T2）或在class T2内写一个non-explicit-one-argument（可被单一实参调用）的构造函数。如果我们只允许explicit构造函数存在，就得写出专门负责执行转换的函数，且不得为类型转换操作符或non-explicit-one-argument构造函数。</li>
<li><strong>什么样的操作符和函数对此新type而言是合理的？</strong>这个问题的答案决定你将为你的class声明哪些函数。其中某些该是member函数，某些则否。</li>
<li><strong>什么样的标准函数应该驳回？</strong>那些正是你必须声明为private者。</li>
<li><strong>谁该取用新type的成员？</strong>这个提问可以帮助你决定哪个成员为public，哪个为protected，哪个为private。它也帮助你决定哪一个class或function应该是friend，以及将它们嵌套于另一个之内是否合理。</li>
<li><strong>什么是新type的“未声明接口”？</strong>它对效率、异常安全性以及资源运用提供何种保证？你在这些方面提供的保证将为你的class实现代码加上相应的约束条件。</li>
<li><strong>你的新type有多么一般化？</strong>或许你其实并非定义一个新type，而是定义一整个type家族。果真如此你就不该定义一个新class，而是定义一个新的class template。</li>
<li><strong>你真的需要一个新type吗？</strong>如果只是定义新的derived class以便为既有的class添加机能，那么说不定单纯定义一个或多个non-member函数或template，更能够达到目标。</li>
</ul>
<p>&emsp;&emsp;这些问题不容易回答，所以定义出高效的class是一种挑战。然而如果能够设计出至少像C++内置类型一样好的用户自定义class，一切汗水便都值得。</p>
<blockquote>
<p>class的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款所覆盖的所有讨论主题。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>通过复合塑模出has-a或“根据某物实现出”</title>
    <url>/2020/11/11/%E9%80%9A%E8%BF%87%E5%A4%8D%E5%90%88%E5%A1%91%E6%A8%A1%E5%87%BAhas-a%E6%88%96%E2%80%9C%E6%A0%B9%E6%8D%AE%E6%9F%90%E7%89%A9%E5%AE%9E%E7%8E%B0%E5%87%BA%E2%80%9D/</url>
    <content><![CDATA[<hr>
<h1 id="通过复合塑模出has-a或“根据某物实现出”"><a href="#通过复合塑模出has-a或“根据某物实现出”" class="headerlink" title="通过复合塑模出has-a或“根据某物实现出”"></a>通过复合塑模出has-a或“根据某物实现出”</h1><p>&emsp;&emsp;复合（composition）是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> &#123;</span> ... &#125;;  <span class="comment">//某人的住址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneNumber</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ...</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name;         <span class="comment">//合成成分物（composed object）</span></span><br><span class="line">        Address address;          <span class="comment">//同上</span></span><br><span class="line">        PhoneNumber voiceNumber;  <span class="comment">//同上</span></span><br><span class="line">        PhoneNumber faxNumber;    <span class="comment">//同上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本例之中Person对象由string，Address，PhoneNumber构成。在程序员之间复合这个术语有许多同义词，包括layering（分层），containment（内含），aggregation（聚合）和embedding（内嵌）。</p>
<a id="more"></a>

<p>&emsp;&emsp;实际上复合有它自己的意义。实际上它有两个意义。复合意味has-a（有一个）或is-implemented-in-term-if（根据某物实现出）。那是因为你正打算在你的软件中处理两个不同的领域（domains）。程序中的对象其实相当于你所塑造的世界中的某些事物，例如人、汽车、一张张视频画面等等。这样的对象属于应用域（application domain）部分。其他对象则纯粹是实现细节上的人工制品，像是缓冲区（buffers）、互斥器（mutexs）、查找树（search trees）等等。这些对象相当于你的软件等实现域。当复合发生于应用域内的对象之间，表现出has-a的关系；当它发生于实现域内则是表现is-implemented-in-terms-of的关系。</p>
<p>&emsp;&emsp;上述的Person class示范has-a关系。Person有一个名称，一个地址，以及语音和传真两笔电话号码。你不会说“人是一个名称”或“人是一个地址”，你会说“人有一个名称”和“人有一个地址”。大多数人接受此一区别毫无困难，所以很少人会对is-a和has-a感到困惑。</p>
<p>&emsp;&emsp;比较麻烦的是区分is-a（是一种）和is-implemented-in-terms-of（根据某物实现出）这两种对象关系。假设你需要一个template，希望制造出一组class用来表现由不重复对象组成的sets。由于复用是件美妙无比的事情，你的第一个直觉是采用标准程序库提供的set template。是的，如果他人所写的template合乎需求，我们何必令写一个呢？</p>
<p>&emsp;&emsp;但是容我再说一次，复用是件美好的事。如果你是一位数据结构专家。你就会知道，实现sets的方法太多了，其中一种便是在底层采用linked lists。而你又刚好知道，标准程序库有一个list template，于是你决定复用它。</p>
<p>&emsp;&emsp;更明确地说，你决定让你那个萌芽中的Set template继承std::list。也就是说让Set&lt;T&gt;继承list&lt;T&gt;。毕竟在你的实现理念中Set对象其实是个list对象。你于是声明Set template如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//将list应用于Set。错误做法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Set</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;每件事看起来都很好，但实际上有些东西完全错误。如果D是一种B，对B为真的每一件事对D也都应该为真。但list可以内含重复元素，如果数值3051被安插到list&lt;int&gt;两次，那个list将内含两笔3051。Set不可以内含重复元素，如果数值3051被安插到Set&lt;int&gt;两次，这个set只内含一笔3051。因此“Set是一种list”并不为真，因为对list为真对某些事情对Set对象并不为真。</p>
<p>&emsp;&emsp;由于这两个class之间并非is-a的关系，所以public继承不适合用来塑模它们。正确的做法是，你应当了解，Set对象可根据一个list对象实现出来：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;  //将<span class="title">list</span>应用于<span class="title">Set</span>。正确做法。</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Set</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">member</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; item)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; rep;  <span class="comment">//用来表述Set的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Set成员函数可大量依赖list及标准程序库其他部分提供的机能来完成，所以其实现很直观也很简单，只要你熟悉以STL编写程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> Set&lt;T&gt;::member(<span class="keyword">const</span> T&amp; item) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item) != rep.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!member(item)) rep.push_back(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Set&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; item) &#123;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::iterator it =</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">find</span>(rep.<span class="built_in">begin</span>(), rep.<span class="built_in">end</span>(), item);</span><br><span class="line">    <span class="keyword">if</span>(it != rep.<span class="built_in">end</span>()) rep.erase(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> Set&lt;T&gt;::<span class="built_in">size</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rep.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些函数如此简单，如果Set接口遵循STL容器的协议，就更容易符合对设计接口的警告：“让它容易被正确使用，不易被误用”。但是这儿如果要遵循那些协议，需得为Set添加许多东西，那将模糊了它和list之间的关系。由于Set和list之间的关系是本条款的重点，所以我们以教学清澈度交换STL兼容性。此外，Set接口也不该造成“对Set而言无可置辩的权利”黯然失色，那个权利是指它和list间的关系。这关系并非is-a（虽然最初似乎是），而是is-implemented-in-terms-of。</p>
<blockquote>
<ul>
<li>复合的意义和public继承完全不同。</li>
<li>在应用域，复合意味has-a。在实现域，复合意味is-implemented-in-terms-of。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>避免返回handles指向对象内部成分</title>
    <url>/2020/08/10/%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/</url>
    <content><![CDATA[<hr>
<h1 id="避免返回handles指向对象内部成分"><a href="#避免返回handles指向对象内部成分" class="headerlink" title="避免返回handles指向对象内部成分"></a>避免返回handles指向对象内部成分</h1><p>&emsp;&emsp;假设你的程序设计矩形。每个矩形由其左上角和右下角表示。为了让一个Rectangle对象尽可能小，你可能会决定不把定义矩形的这些点存放在Rectangle对象内，而是放在一个辅助的struct内再让Rectangle去指它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y);</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> newVal)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span> &#123;</span>  <span class="comment">//这些“点”数据用来表现一个矩形</span></span><br><span class="line">    Point ulhc;    <span class="comment">//左上角</span></span><br><span class="line">    Point lrhc;    <span class="comment">//右下角</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>&emsp;&emsp;Rectangle的客户必须能够计算Rectangle的范围，所以这个class提供upperLeft函数和lowerRight函数。Point是个用户自定义类型，这些函数返回reference，代表底层的Point对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function">Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这样的设计可以通过编译，但却是错误的。实际上它是自我矛盾的。一方面upperLeft和lowerRight被声明为const成员函数，因为它们的目的只是为了提供客户一个得知Rectangle相关坐标点的方法，而不是让客户修改Rectangle。另一方面两个函数都返回reference指向private内部数据，调用者于是可以通过这些reference更改内部数据！例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">coord1</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">coord2</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1, coord2)</span></span>;  <span class="comment">//rec是个const矩形，从（0，0）到（100，100）</span></span><br><span class="line">rec.upperLeft().setX(<span class="number">50</span>);             <span class="comment">//现在却变成从（50，0）到（100，100）</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里立刻带给我们两个教训。第一，成员变量的封装性最多只等于“返回其reference”的函数的访问级别。本例之中虽然ulhc和lrhc都被声明为private，它们实际上却是public，因为public函数upperLeft和lowerRight传出它们的reference。第二，如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。这正是bitwise constness的一个附带结果。</p>
<p>&emsp;&emsp;我们在这些函数身上遭遇的两个问题可以轻松去除，只要对它们的返回类型加上const即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;ulhc; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Point&amp; <span class="title">lowerRight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> pData-&gt;lrhc; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;有了这样的改变，客户可以读取矩形的Point，但不能涂写它们。这意味当初声明upperLeft和upperRight为const不再是个谎言，因为它们不在允许客户更改对象状态。至于封装问题，我们总是愿意让客户看到Rectangle的外围Point，所以这里是蓄意放松封装。更重要的是这是个有限度的放松：这些函数只让渡读取权。涂写权仍然是被禁止的。</p>
<p>&emsp;&emsp;但即使如此，upperLeft和lowerRight还是返回了“代表对象内部”的handle，有可能在其它场合带来问题。更明确地说，它可能导致dangling handle（空悬号码牌）：这种handle所指东西（的所属对象）不复存在。这种“不复存在的对象”最常见的来源就是函数返回值。例如某个函数返回GUI对象的外框，这个外框采用矩形形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GUIObject</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">const</span> Rectangle</span><br><span class="line">boundingBox(<span class="keyword">const</span> GUIObject&amp; obj);</span><br></pre></td></tr></table></figure>

<p>现在，客户有可能这么使用这个函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">GUIObject* pgo;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> Point* pUpperLeft = &amp;(boundingBox(*pgo).upperLeft());</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对boundingBox的调用获得一个新的、暂时的Rectangle对象。这个对象没有名称，所以我们权且称它为temp。随后upperLeft作用于temp身上，返回一个reference指向temp的一个内部成分，更具体地说是指向一个用以标示temp的Point。于是pUpperLeft指向那个Point对象。目前为止一切还好，但故事尚未结束，因为在那个语句结束之后，boundingBox的返回值，也就是我们所说的temp，将被销毁，而那间接导致temp内的Point析构。最终导致pUpperLeft指向一个不再存在的对象：也就是说一旦产出pUpperLeft的那个语句结束，pUpperLeft也就变成空悬、虚吊！</p>
<p>&emsp;&emsp;这就是为什么函数如果“返回一个handle代表对象内部成分”总是危险的原因。不论这所谓的handle是个指针或迭代器或reference，也不论这个handle是否为const，也不论那个返回handle的成员函数是否为const。这里的唯一关键是，有个handle被传出去了，一旦如此你就是暴露在“handle比其所指对象更长寿”的风险下。</p>
<p>&emsp;&emsp;这并不意味你绝对不可以让成员函数返回handle。有时候你必须那么做。例如operator[]就允许你“摘采”string和vector的个别元素，而这些operator[]就是返回reference指向“容器内的数据”，那些数据会随着容器被销毁而销毁。尽管如此，这样的函数毕竟是少数，不是常态。</p>
<blockquote>
<p>避免返回handle（包括reference、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”的可能性降至最低。</p>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>避免遮掩继承而来的名称</title>
    <url>/2020/10/28/%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0/</url>
    <content><![CDATA[<hr>
<h1 id="避免继承而来的名称"><a href="#避免继承而来的名称" class="headerlink" title="避免继承而来的名称"></a>避免继承而来的名称</h1><p>&emsp;&emsp;关于“名称”，莎士比亚说过这样一句话：“名称是什么呢？”他问，“一朵玫瑰叫任何名字还是一样芬芳。</p>
<p>&emsp;&emsp;其实这样的讨论与继承无关，而是和作用域有关。我们都知道再诸如这样的代码中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x;              <span class="comment">//global变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;       <span class="comment">//local变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;  <span class="comment">//读一个新值赋予local变量x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这个读取数据的语句指的是local变量x，而不是global变量x，因为内层作用域的名称会遮掩外围作用域的名称。</p>
<a id="more"></a>

<p>&emsp;&emsp;当编译器处于comeFunc的作用域内并遭遇名称x时，它在local作用域内查找是否有什么东西带着这个名称。如果找到就不再找其他作用域。本例到someFunc的x是double类型而global x是int类型，但那不要紧。C++的名称遮掩规则（name-hiding rules）所作的唯一事情就是：遮掩名称。至于名称是否相同或不同的类型，并不重要。本例中一个名为x的double遮掩了一个名为x的int。</p>
<p>&emsp;&emsp;现在导入继承。我们知道，当位于一个derived class成员函数内指涉base class内的某物（也许是个成员函数、typedef、或成员变量）时，编译器可以找出我们所指涉的东西，因为derived class继承了声明于base classes内的所有东西。实际运作方式是，derived class作用域被嵌套在base class作用域内，像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此例内含一组混合例public和private名称，以及一组成员变量和成员函数名称。这些成员函数包括pure virtual，impure virtual和non-virtual三种，这是为了强调我们谈的是名称，和其他无关。这个例子也可以加入各种名称类习惯，例如enums，nested classes和typedefs。整个讨论中唯一重要的是这些东西的名称，至于这些东西是什么并不重要。本例使用单一继承，然而一旦了解单一继承下发生的事，很容易就可以推想C++在多重继承下的行为。</p>
<p>&emsp;&emsp;假设derived class内的mf4的实现代码像这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::mf4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mf2();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当编译器看到这里使用名称mf2，必须估算它指涉什么东西。编译器的做法是查找各作用域，看看有没有某个名为mf2的声明式。首先查找local作用域（也就是mf4覆盖的作用域），在那儿没找到任何东西名为mf2.于是查找其外围作用域，也就是class Derived覆盖的作用域。还是没找到任何东西名为mf2，于是再往外围移动，本例为base class。在那儿编译器找到一个名为mf2的东西了，于是停止查找。如果Base内还是没有mf2，查找动作继续下去，首先找到内含Base的那个namespace的作用域（如果有的话），最后往global作用域找去。</p>
<p>&emsp;&emsp;再次考虑前一个例子，这次让我们重载mf1和mf3，并且添加一个新版mf3到Derived去。这里发生的事情是：Derived重载了mf3，那是一个继承而来的non-virtual函数。这会使整个设计立刻显得疑雾重重，但为了充分认识继承体系内的“名称可视性”，我们暂时安之若素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> puvlic Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这段代码带来的行为会让每一位第一次面对它的C++程序员大吃一惊。以作用域为基础的“名称遮掩规则”并没有改变，因此base class内所有名为mf1和mf3的函数都被derived class内的mf1和mf3函数遮掩掉了。从名称查找观点来看，Base::mf1和Base::mf3不再被Derived继承！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1();   <span class="comment">//没问题，调用Derived::mf1</span></span><br><span class="line">d.mf1(x);  <span class="comment">//错误！因为Derived::mf1遮掩了Base::mf1</span></span><br><span class="line">d.mf2();   <span class="comment">//没问题，调用Base::mf2</span></span><br><span class="line">d.mf3();   <span class="comment">//没问题，调用Derievd::mf3</span></span><br><span class="line">d.mf3(x);  <span class="comment">//错误！因为Derived::mf3遮掩了Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如你所见，上述规则都适用，即使base class和derived class内的函数有不同的参数类型也适用，而且不论函数是virtual或non-virtual都适用。</p>
<p>&emsp;&emsp;这些行为背后的基本理由是为了防止你在程序库或应用框架内建立新的derived class时附带地从疏远的base class继承重载函数。不幸的是你通常会想继承重载函数。实际上如果你正在使用public继承而又不继承那些重载函数，就是违反base和derived class之间的is-a关系，而“<a href="/2020/09/06/%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84public%E7%BB%A7%E6%89%BF%E5%A1%91%E6%A8%A1%E5%87%BAis-a%E5%85%B3%E7%B3%BB/" title="确定你的public继承塑模出is-a关系">确定你的public继承塑模出is-a关系</a>”说过is-a是public继承的基石。因此你几乎总会想要推翻（override）对“继承而来的名称”的缺省遮掩行为。</p>
<p>&emsp;&emsp;你可以使用using声明式达成目标：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">using</span> Base::mf1;  <span class="comment">//让Base class内名为mf1和mf3的所有东西</span></span><br><span class="line">        <span class="keyword">using</span> Base::mf3;  <span class="comment">//在Derived作用域内都可见（并且public）</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;现在，继承机制将一如既往地运作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">...</span><br><span class="line">d.mf1();   <span class="comment">//仍然没问题，仍然调用Derived::mf1</span></span><br><span class="line">d.mf1(x);  <span class="comment">//现在没问题了，调用Base::mf1</span></span><br><span class="line">d.mf2();   <span class="comment">//仍然没问题，仍然调用Base::mf2</span></span><br><span class="line">d.mf3();   <span class="comment">//没问题，调用Derived::mf3</span></span><br><span class="line">d.mf3(x);  <span class="comment">//现在没问题了，调用Base::mf3</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这意味如果你继承base class并加上重载函数，而你又希望重新定义或覆写其中一部分，那么你必须为那些原本会被遮掩的每个名称引入一个using声明式，否则某些你希望继承的名称会被遮掩。</p>
<p>&emsp;&emsp;有时候你并不想继承base class的所有函数，这是可以理解的。在public继承下，这绝不可能发生，因为它违反了public继承所暗示的“base和derived class之间的is-a关系”。（这也就是为什么上述using声明式被放在derived class的public区域的原因：base class内的public名称在publicly derived class内也应该是public。）然而在private继承之下它却可能是有意义的。例如假设Derived以private形式继承Base，而Derived唯一想继承的mf1是那个无参数版本。using声明式在这里派不上用场，因为using声明式会令继承而来的某给定名称之所有同名函数在derived class中都可见。不，我们需要不同的技术，即一个简单的转交函数（forwarding function）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">        ...  <span class="comment">//同前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>&#123;  <span class="comment">//转交函数；</span></span><br><span class="line">            Base::mf1();      <span class="comment">//暗自成为inline</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">d.mf1();   <span class="comment">//很好，调用的是Derived::mf1</span></span><br><span class="line">d.mf1(x);  <span class="comment">//错误！Base::mf1()被遮掩了</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;inline转交函数的另一个用途是为那些不支持using声明式的老旧编译器另辟一条路，将继承而得的名称汇入derived class作用域内。</p>
<p>&emsp;&emsp;这就是继承和名称遮掩的完整故事。但是当继承结合templates，我们又将面对“继承名称被遮掩”的一个全然不同的形式。</p>
<blockquote>
<ul>
<li>Derived class内的名称会遮掩base class内的名称。在public继承下从来没有人希望如此。</li>
<li>为了让被遮掩的名称再见天日，可使用using声明式或转交函数。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>长篇大论</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX高级IO之非阻塞IO</title>
    <url>/2022/08/12/UNIX%E9%AB%98%E7%BA%A7IO%E4%B9%8B%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</url>
    <content><![CDATA[<hr>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>&emsp;&emsp;了解非阻塞<code>I/O</code>的根本原因还需追根溯源——系统调用。为什么需要系统调用呢？将所有接口都直接暴露给用户岂不美哉？非也，由于系统的资源有限，为了保护这些计算机资源设备，操作系统不可能让所有的程序都可以轻松地访问到任何一个文件。因此，进程在系统上的运行会分为两个级别：用户态和内核态。而系统内核通过包装这些特定功能的硬件指令和硬件状态（即内核函数），并通过一组称为系统调用的接口呈现给用户。</p>
<a id="more"></a>

<ul>
<li>用户态（<code>user mode</code>）：用户态运行的进程可以直接读取用户程序的数据；</li>
<li>内核态（<code>kernel mode</code>）：内核态运行的程序可以访问计算机的任何资源，不受限制；</li>
</ul>
<p>&emsp;&emsp;平时我们的进程几乎都是用户态，读取用户数据，当涉及到系统级别的操作（例如文件管理、进程控制和内存管理等）的时候，就要用到系统调用了。那么操作系统如何分辨出哪些内存区域属于用户态，哪些属于内核态呢？</p>
<h2 id="操作系统的权限限制"><a href="#操作系统的权限限制" class="headerlink" title="操作系统的权限限制"></a>操作系统的权限限制</h2><p>&emsp;&emsp;操作系统使用<code>CS:IP</code>中<code>CS</code>的最低两位来表示：0是内核态，3是用户态。</p>
<blockquote>
<p>&emsp;&emsp;<code>CS:IP</code>是两个寄存器，指示了<code>CPU</code>当前将要读取的指令的地址。<code>Shell</code>将可执行文件加载到内存中后，就会设置<code>CPU</code>中的<code>CS:IP</code>寄存器指向可执行文件的起始地址，此后<code>CPU</code>便从这个起始地址开始读取内存中的指令，并执行。也就是说，当一个可执行文件加载到内存中以后，<code>CS:IP</code>这两个寄存器便指向了这个可执行文件的起始地址。</p>
<p>&emsp;&emsp;总结一下：</p>
<ul>
<li>想让<code>CPU</code>执行哪些指令，就可以让<code>CS:IP</code>指向保存对应指令的那块内存即可；</li>
<li>任何时候，<code>CS:IP</code>指向的地址中的内容都是<code>CPU</code>当前执行的指令。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;每次访问时，需要满足以下条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CPL &lt;&#x3D; DPL</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>CPL</code>（<code>Current Privilege Level</code>）当前进程的权限级别</li>
<li><code>DPL</code>（<code>Descriptor Privilege Level</code>）规定了访问该段的权限级别</li>
<li><code>RPL</code>（<code>Request Privilege Level</code>）进程对段访问的请求权限级别</li>
</ul>
<p>实际上在请求某特权级别为<code>DPL</code>的资源时，需要满足：<code>CPL &lt;= DPL</code>并且<code>RPL &lt;= DPL</code>。</p>
</blockquote>
<p>内核段的<code>DPL</code>都是0（在初始化阶段<code>DPL</code>就都设置为0了），这样内核态就可以访问任何数据，用户态不能访问内核数据，通过这种方式，就实现了用户态和内核态的权限隔离。</p>
<h2 id="从用户态切换到内核态（系统调用过程）"><a href="#从用户态切换到内核态（系统调用过程）" class="headerlink" title="从用户态切换到内核态（系统调用过程）"></a>从用户态切换到内核态（系统调用过程）</h2><p>&emsp;&emsp;既然我们使用了系统调用，由于系统调用最终还是进入了内核，其中必然涉及到了内核态，那么从用户态到内核态的切换过程又是如何进行的呢？</p>
<p>&emsp;&emsp;对此，操作系统提供了一个中断指令<code>int 0x80</code>来主动进入内核，这也是用户程序访问内核代码的唯一方式。简单地来说（不做过多的深入，毕竟我们也不是从事汇编工作的）：</p>
<ul>
<li>调用系统函数时会通过内联汇编代码插入<code>int 0x80</code>的中断指令，将系统调用编号设置给<code>%eax</code>寄存器；</li>
<li>内核收到<code>int 0x80</code>中断后，查询<code>IDT</code>表来取出中断处理函数地址（此时<code>int 0x80</code>的<code>IDT</code>表中的<code>DPL</code>被设置成了3，所以才能从用户态直接访问<code>int 0x80</code>中断指令；</li>
<li>然后<code>CPL</code>变为0，此时也就切换为了内核态，<code>system_call</code>会根据<code>%eax</code>来跳转到对应的处理函数执行。</li>
</ul>
<p>&emsp;&emsp;其中涉及到的细节繁琐复杂，要深入下去，怕是要陷入一个技术黑洞，对此点到即止便好，前文所述足以供我们了解UNIX系统调用的大致情况了。</p>
<h1 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h1><p>&emsp;&emsp;有了前文对于系统调用的一个大致概述，这下可以回到主题了：非阻塞<code>IO</code>。</p>
<p>&emsp;&emsp;系统调用可以分为两类：“低速”系统调用和其他。低速系统调用是可能会使进程永远阻塞的一类系统调用。</p>
<p>这类系统调用包括：</p>
<ul>
<li>如果某些文件类型（如读管道、终端设备和网络设备）的数据并不存在，读操作可能会使调用者永远阻塞；</li>
<li>如果数据不被相同的文件类型立即接受（如管道中无空间、网络流控制），写操作可能会使调用者永远阻塞；</li>
<li>对已经加上强制性记录锁的文件进行读写；</li>
<li>某些进程间通信函数；</li>
<li>某些<code>ioctl</code>函数；</li>
<li>等等。</li>
</ul>
<p>&emsp;&emsp;虽然，读写磁盘文件会暂时阻塞调用者，但是并不能将与磁盘<code>IO</code>有关的系统调用视为“低速”。非阻塞<code>IO</code>可以使我们发出<code>open</code>、<code>read</code>和<code>write</code>这样的<code>IO</code>操作，并且使这些操作永远不会阻塞。如果这些操作不能完成，则立即出错返回，表示该操作如继续执行将阻塞。对于一个给定的描述符，有两种方式可以为其指定非阻塞<code>IO</code>：</p>
<ul>
<li>如果调用<code>open</code>获得描述符，则可指定<code>O_NONBLOCK</code>标志；</li>
<li>对于已经打开的一个描述符，则可调用<code>fcntl</code>。由该函数打开<code>O_NONBLOCK</code>文件状态标志。</li>
</ul>
<p>&emsp;&emsp;我们可以观察如下例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了fcntl，更加安全</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ERROR_SYS("fcntl F_GETFL error");</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    val |= flags;</span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ERROR_SYS("fcntl F_SETFL error");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了fcntl，更加安全</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span>((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ERROR_SYS("fcntl F_GETFL error");</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    val &amp;= ~flags;</span><br><span class="line">    <span class="keyword">if</span>(fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ERROR_SYS("fcntl F_SETFL error");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_to_write, n_write;</span><br><span class="line">    <span class="keyword">char</span>* ptr_buf;</span><br><span class="line">    </span><br><span class="line">    n_to_write = <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read %d bytes\n"</span>, n_to_write);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能简单地调用fcntl(STDOUT_FILENO, F_SETFL, O_NONBLOCK);</span></span><br><span class="line">    <span class="comment">// 使用上述定义的set_fl和clr_fl。</span></span><br><span class="line">    set_fl(STDOUT_FILENO, O_NONBLOCK);</span><br><span class="line">  </span><br><span class="line">    ptr = buf;</span><br><span class="line">    <span class="keyword">while</span>(n_to_write &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        errno = <span class="number">0</span>;</span><br><span class="line">        n_write = <span class="built_in">write</span>(STDOUT_FILENO, ptr, n_to_write);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"n_write = %d, errno = %d\n"</span>, n_write, errno);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span>(n_write &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ptr += n_write;</span><br><span class="line">            n_to_write -= n_write;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        clr_fl(STDOUT_FILENO, O_NONBLOCK);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;对于上述代码中，需要注意的是不能直接调用<code>fcntl</code>，要先获得现在的标志值，然后按照需求来修改标志值，最后再设置新的标志值。如果简单地直接执行<code>F_SETFL</code>或<code>F_SETFD</code>命令，则会关闭以前设置的标志位。</p>
<p>&emsp;&emsp;在此实例中，程序假如发出了10000个<code>write</code>调用，可能最后就只有<code>5%</code>不到的调用真正输出了数据，其余都返回错误。这种形式的循环称为轮询，在多用户系统上用这种方式会浪费<code>CPU</code>时间。而非阻塞描述符的<code>IO</code>多路转接（之后将会谈到），是进行这种操作的一种比较有效的方法。有时可以将程序设计为使用多线程的，从而避免使用非阻塞<code>IO</code>。如果能在其他线程中继续进行，则可以允许单个线程在<code>IO</code>调用中阻塞。这种方法有时能简化应用程序的设计，但是，线程间同步的开销有时却可能增加复杂性，终归有点得不偿失。</p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>UNIX高级IO</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX高级IO之各类IO模型</title>
    <url>/2022/08/16/UNIX%E9%AB%98%E7%BA%A7IO%E4%B9%8B%E5%90%84%E7%B1%BBIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<hr>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&emsp;&emsp;当从一个描述符读，然后又写到另一个描述符时，可以在下列形式的循环中使用阻塞<code>IO</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((n = <span class="built_in">read</span>(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">write</span>(STDOUT_FILENO, buf, n) != <span class="number">0</span>)</span><br><span class="line">        ERR_SYS(<span class="string">"write error"</span>);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这种形式的阻塞<code>IO</code>随处可见。但是如果必须从两个描述符读，又该如何呢？在这种情况下，我们不能在任意一个描述符上进行阻塞读，否则可能会因为被阻塞在一个描述符的读操作上而导致另一个描述符即使有数据也无法处理。所以为了应对这种情况就需要另外一种不同的技术了——<code>IO</code>多路转接。</p>
<a id="more"></a>

<h1 id="IO多路转接"><a href="#IO多路转接" class="headerlink" title="IO多路转接"></a>IO多路转接</h1><p>&emsp;&emsp;在了解<code>IO</code>多路转接之前，我们先从一个实例来一步步地探索。可以以<code>telnet</code>这一命令的结构为例。该程序从终端（标准输入）读，将所得数据写到网络连接上；同时从网络连接读，将所得数据写到终端上（标准输出）。在网络连接的另一端，<code>telnetd</code>守护进程将执行用户键入命令而产生的输出通过<code>telnet</code>命令送回给用户，并显示在用户终端上。</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/UNIX%E9%AB%98%E7%BA%A7IO%E4%B9%8BIO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/telnet%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="telnet概况"></p>
<p>&emsp;&emsp;<code>telnet</code>进程有两个输出，两个输入。我们不能对两个输入中的任一个使用阻塞<code>read</code>，因为我们不知道到底哪一个输入会得到数据，万一等待的是“错误的人”，岂不是要“等待一辈子了”？处理这种特殊问题的一种方法是，将一个进程变成两个进程（用<code>fork</code>），每个进程处理一条数据通道。</p>
<h2 id="使用两个进程"><a href="#使用两个进程" class="headerlink" title="使用两个进程"></a>使用两个进程</h2><p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/UNIX%E9%AB%98%E7%BA%A7IO%E4%B9%8BIO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/telnet%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="使用两个进程实现telnet程序"></p>
<p>&emsp;&emsp;如果使用两个进程，则可使每个进程都执行阻塞<code>read</code>。但是这也产生了问题：操作什么时候终止？如果子进程接收到文件结束符（<code>telnetd</code>守护进程使网络连接断开），那么该子进程终止，然后父进程接收到<code>SIGCHLD</code>信号。但是，如果父进程终止（用户在终端上键入了文件结束符），那么父进程应通知子进程停止。为此可以使用一个信号（如<code>SIGUSR1</code>），但这使程序变得更加复杂。</p>
<h2 id="使用一个进程中的两个线程"><a href="#使用一个进程中的两个线程" class="headerlink" title="使用一个进程中的两个线程"></a>使用一个进程中的两个线程</h2><p>&emsp;&emsp;我们可以不使用两个进程，而是用一个进程中的两个线程。虽然这避免了终止的复杂性。但却要求处理两个线程之间的同步，在复杂性方面这可能会得不偿失。</p>
<h2 id="使用一个进程进行非阻塞IO"><a href="#使用一个进程进行非阻塞IO" class="headerlink" title="使用一个进程进行非阻塞IO"></a>使用一个进程进行非阻塞IO</h2><p>&emsp;&emsp;另一个方法仍旧使用一个进程执行该程序，但使用非阻塞<code>IO</code>读取数据。其基本思想是：将两个输入描述符都设置为非阻塞，对第一个描述符发一个<code>read</code>。如果该输入上有数据，则读数据并处理它。如果无数据可读，则该调用立即返回。然后对第二个描述符作同样的处理。在此之后，等待一定的时间（可能是若干秒），然后再尝试从第一个描述符读。这种形式的循环称为轮询。这种方法的不足之处在于浪费了<code>CPU</code>的时间。大多数时间实际上是无数据可读，因此执行<code>read</code>系统调用浪费了时间。在每次循环后要等多长时间再执行下一轮循环也很难确定。虽然轮询技术在支持非阻塞<code>IO</code>的所有系统上都可用，但是在多任务系统中应当避免使用这种方法。</p>
<h2 id="使用信号驱动IO"><a href="#使用信号驱动IO" class="headerlink" title="使用信号驱动IO"></a>使用信号驱动IO</h2><p>&emsp;&emsp;还有一种技术称为信号驱动<code>IO</code>。我们提前在信号集合中设置好<code>IO</code>信号等待，注册好对应的<code>IO</code>处理函数<code>handler</code>，<code>IO</code>数据准备就绪后，会递交信号（可能是<code>SIGIO</code>，也可能是<code>SIGPOLL</code>），通知应用程序中断然后开始举行对应的<code>IO</code>处理逻辑，但是通知处理<code>IO</code>的时候存在将数据从内核空间拷贝到用户空间的过程，这个过程需要阻塞等待。利用这种技术，进程告诉内核：当描述符准备好可以进行<code>IO</code>时，用一个信号通知它。这种技术有两个问题。首先，尽管一些系统提供了各自的受限形式的异步<code>IO</code>，但<code>POSIX</code>采纳了另外一套标准化接口，所以可移植性成为一个问题。</p>
<blockquote>
<p><code>System V</code>提供了<code>SIGPOLL</code>信号来支持受限形式的信号驱动<code>IO</code>，但是仅当描述符引用<code>STREAMS</code>设备时，此信号才起作用。</p>
<p><code>BSD</code>有一个类似的信号<code>SIGIO</code>，但也有类似的限制：仅当描述符引用终端设备或网络时它才能起作用。</p>
</blockquote>
<p>&emsp;&emsp;这种技术的第二个问题是，这种信号对每个进程而言只有一个（<code>SIGPOLL</code>或<code>SIGIO</code>），如果使该信号对两个描述符都起作用（从两个描述符读的例子），那么该进程在接到此信号时将无法判断是哪一个描述符准备好了。尽管<code>POSIX.1</code>异步<code>IO</code>接口允许选择哪个信号作为通知，但能用的信号数量仍远小于潜在的打开文件描述符数量。为了确定是哪一个描述符准备好了，仍需将这两个描述符都设置为非阻塞的，并顺序尝试执行<code>IO</code>。</p>
<h2 id="使用异步IO"><a href="#使用异步IO" class="headerlink" title="使用异步IO"></a>使用异步IO</h2><p>&emsp;&emsp;与信号驱动<code>IO</code>不同，异步<code>IO</code>是数据拷贝完成后内核再通知应用程序直接开始处理，不需要拷贝数据阻塞等待。也就是说，其完全不存在应用程序的阻塞等待，平时应用程序做自己的事情，当数据完全准备好了（数据完成拷贝），直接通知应用程序回调处理函数即可。</p>
<blockquote>
<ul>
<li>任何<code>IO</code>操作都是存在“等待数据准备完成”和“将数据从内核态拷贝到用户态”两个过程的；</li>
<li>两个过程中等待数据消耗的时间一般远超于拷贝数据所花费的时间，所以一般我们进行<code>IO</code>优化，都是尽可能降低等待时间；</li>
<li>上述<code>IO</code>模型中非阻塞<code>IO</code>仅仅只是在数据准备阶段上来说是阻塞的（数据没有准备完毕，则立马返回），但是数据拷贝阶段还是阻塞的，所以本质上还是同步<code>IO</code>，只有异步<code>IO</code>是完全做到了整个过程非阻塞的，当进程发起<code>IO</code>操作之后，就可以直接返回再也不用理睬，直到内核发送一个信号，通知进程<code>IO</code>完成（包括数据拷贝）。</li>
</ul>
</blockquote>
<h2 id="使用IO多路转接"><a href="#使用IO多路转接" class="headerlink" title="使用IO多路转接"></a>使用IO多路转接</h2><p>&emsp;&emsp;一种较好的技术是使用<code>IO</code>多路转接（<code>IO multiplexing</code>）。为了使用这种技术，先构造我们感兴趣的描述符的列表，然后调用一个函数，直到这些描述符中的一个已准备好进行<code>IO</code>时，该函数才返回。<code>poll</code>、<code>pselect</code>和<code>select</code>这三个函数使我们能够执行<code>IO</code>多路转接。在从这些函数返回时，进程会被告知哪些描述符已准备好可以进行<code>IO</code>。这里了解其中的<code>poll</code>和<code>select</code>即可。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>&emsp;&emsp;在所有兼容<code>POSIX</code>的平台上，<code>select</code>函数使我们可以执行<code>IO</code>多路转接。传给<code>select</code>的参数告诉内核：</p>
<ul>
<li>我们所关心的描述符；</li>
<li>对于每个描述符我们所关心的条件（是否想从一个给定的描述符读或写一个给定的描述符，是否关心一个给定描述符的异常条件）；</li>
<li>愿意等待多久（可以永远等待、等待一个固定时间或者根本不等待）。</li>
</ul>
<p>&emsp;&emsp;从<code>select</code>返回时，内核告诉我们：</p>
<ul>
<li>已准备好的描述符的总数；</li>
<li>对于读、写或异常这三个条件中的每一个，哪些描述符已准备好。</li>
</ul>
<p>&emsp;&emsp;使用这种返回信息，就可以调用相应的<code>IO</code>函数（一般是<code>read</code>或<code>write</code>），并且明确知道该函数不会阻塞。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：准备就绪的描述符总数；若超时，返回0；否出错，返回-1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdpl, fd_set* readfds,</span></span></span><br><span class="line"><span class="function"><span class="params">                        fd_set* writefds,</span></span></span><br><span class="line"><span class="function"><span class="params">                        fd_set* exceptfds,</span></span></span><br><span class="line"><span class="function"><span class="params">           struct timeval* tvptr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先说明一下最后一个参数，它指定愿意等待的时间长度，单位为秒和微秒，有以下三种情况：</p>
<ul>
<li><code>tvptr == NULL</code>：永远等待。如果捕捉到一个信号则中断此无限等待。当所指定的描述符中的一个已准备好或捕捉到一个信号则返回。如果捕捉到一个信号，则<code>select</code>返回-1，<code>errno</code>设置为<code>EINTR</code>。</li>
<li><code>tvptr-&gt;tv_sec == 0 &amp;&amp; tvptr-&gt;tv_usec == 0</code>：不等待。测试所有指定的描述符并立即返回。这是轮询系统找到多个描述符状态而不阻塞<code>select</code>函数的方法。</li>
<li><code>tvptr-&gt;tv_sec != 0 || tvptr-&gt;tv_usec != 0</code>：等待指定的时间。当指定的描述符之一已准备好，或当指定的时间值已超时，则立即返回。如果在超时后还没有一个描述符准备好，则返回值为0。这种等待可被捕捉到的信号中断。</li>
</ul>
<p>&emsp;&emsp;中间三个参数<code>readfds</code>、<code>writefds</code>和<code>exceptfds</code>是指向描述符集的指针。这三个描述符集说明了我们关心的可读、可写或处于异常条件的描述符集合。每个描述符集存储在一个<code>fd_set</code>数据类型中。这个数据类型是由实现选择的，它可以为每一个可能的描述符保持一位，可以认为其是一个很大的字节数组。</p>
<p>&emsp;&emsp;对于<code>fd_set</code>数据类型，唯一可以进行的处理是：分配一个这种类型的变量，将这种类型的一个变量赋给同类型的另一个变量，或对这种类型的变量使用下列4个函数中的一个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：若fd在描述符集中，返回非0值；否则，返回0</span></span><br><span class="line"><span class="comment">// 可以测试描述符集中的一个指定位是否已打开</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除一位描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启描述符集中的一位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个fd_set变量的所有位设置为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set* fdset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这些借口可以实现为宏或函数。需要注意的是，在声明了一个描述符集之后，必须用<code>FD_ZERO</code>将这个描述符集置为0，然后在其中设置我们关心的各个描述符的位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd_set rset;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line">FD_SET(fd, &amp;rset);</span><br><span class="line">FD_SET(STDIN_FILENO, &amp;rset);</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从<code>select</code>返回时，可以用<code>FD_ISSET</code>测试该集中的一个给定位是否仍处于打开状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(FD_ISSET(fd, &amp;rset)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这三个参数任意一个（或全部）可以是空指针，这表示对相应条件并不关心。如果所有三个指针都是<code>NULL</code>，则<code>select</code>提供了比<code>sleep</code>更为精确的定时器（<code>sleep</code>等待整数秒，而<code>select</code>等待时间则可以小于1秒）。</p>
<p>&emsp;&emsp;<code>select</code>的第一个参数<code>maxfdpl</code>的意思是“最大文件描述符编号值加一”。考虑所有三个描述符集，在这些描述符集中找出最大描述符编号值，然后加一，这就是第一个参数值。至于为什么要加一，这是因为，描述符的编号是从0开始的，所以要在最大描述符编号值上加一，这样结果才是描述符的最大数量。亦可以将其值设置为<code>FD_SETSIZE</code>，指定了最大描述符数（通常是1024），但是对于大多数应用程序而言，这样的值过于大了。通过指定我们所关注的最大描述符，内核只需在此范围内寻找打开的位，而不必在3个描述符集中的数百个没有使用的位内搜索。</p>
<p><img src="https://hex-0-1300395569.cos.ap-shanghai.myqcloud.com/hexo-site-arzhe/UNIX%E9%AB%98%E7%BA%A7IO%E4%B9%8BIO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5/%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86.png" alt="描述符集"></p>
<p>&emsp;&emsp;<code>select</code>的返回值有三种：</p>
<ul>
<li>返回-1。表示出错，例如，在指定的描述符一个都没有准备好时就捕捉到一个信号；</li>
<li>返回0。表示没有描述符准备好。若指定的描述符一个都没有准备好，并且指定的等待时间超时了，就会发生这种情况。此时，所有描述符集都会置为0；</li>
<li>正返回值。说明了已经准备好的描述符数。该值是三个描述符集中已准备好的描述符之和，所以如果同一个描述符已准备好读和写，那么在返回值中会对其计两次数。</li>
</ul>
<p>&emsp;&emsp;这里的“准备好”的含义需要做进一步的说明：</p>
<ul>
<li>若对读写集中的一个描述符进行<code>read</code>，<code>write</code>操作不会阻塞，则认为此描述符是准备好的；</li>
<li>对于读、写和异常条件，普通文件的文件描述符总是返回准备好。</li>
</ul>
<p>&emsp;&emsp;需要注意的是一个描述符阻塞与否并不影响<code>select</code>是否阻塞，也就是说，如果希望读一个非阻塞描述符，并且以超时值为5秒调用<code>select</code>，则<code>select</code>最多阻塞5s，而不会受到描述符本身是否阻塞的影响。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>&emsp;&emsp;<code>poll</code>函数类似于<code>select</code>，但是接口有所不同。虽然<code>poll</code>函数是<code>System V</code>引入来支持<code>STREAMS</code>子系统的，但是<code>poll</code>函数可用于任何类型的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值：准备就绪的描述符数目；若超时，返回0；若出错，返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与<code>select</code>不同，<code>poll</code>不是为每个条件（可读、可写和异常条件）构造一个描述符集，而是构造一个<code>pollfd</code>结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    short events;</span><br><span class="line">    short revents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;<code>fdarray</code>数组中的元素数由<code>nfds</code>指定，对于<code>events</code>成员有对应的参数表来设置其数值，通过这些值告诉内核我们关心的是每个描述符的哪些事件。返回时，<code>revents</code>成员由内核设置，用于说明每个描述符发生了哪些事件。需要注意的是<code>poll</code>并没有更改<code>events</code>成员，这点与<code>select</code>不同，<code>select</code>修改其参数以指示哪一个描述符已准备好了。</p>
<p>&emsp;&emsp;最后一个参数指定的是我们愿意等待多久，同<code>select</code>一样，不同的是当其值为-1时，为永远等待。</p>
]]></content>
      <categories>
        <category>UNIX长篇大论</category>
      </categories>
      <tags>
        <tag>UNIX高级IO</tag>
      </tags>
  </entry>
  <entry>
    <title>安装编译Sonic</title>
    <url>/2022/08/16/%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91Sonic/</url>
    <content><![CDATA[<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;本系列用于记录在<code>Sonic</code>的<code>gdNOS-v2</code>分支下安装编译的过程，以及其中所遇到的问题和尝试的解决方案。</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>&emsp;&emsp;需要在大小至少200G的磁盘空间的<code>Ubuntu</code>系统上进行编译，实例环境是在<code>VBox</code>上面进行安装的20.04.3服务器版<code>Ubuntu</code>系统，在安装过程中，一同安装<code>docker</code>，后续编译需要使用（也可以不安装，后续手动安装更好）。安装完毕后，需要配置<code>git</code>的密钥。</p>
<h2 id="准备GitLab的账号"><a href="#准备GitLab的账号" class="headerlink" title="准备GitLab的账号"></a>准备GitLab的账号</h2><p>&emsp;&emsp;在<code>http://git.gdcni.cn/</code>上注册一个账号，用自己的工作邮箱注册，例如：<code>zhangsan@gdcni.cn</code>，然后应该是需要管理人赋予该账号权限，再可以进行后续的项目下拉和上传。注册完毕后，进入虚拟机的<code>Ubuntu</code>环境下，用户权限下执行：<code>cd ~</code>进入当前用户目录下，执行<code>ll</code>后，应该会看到一个<code>.ssh</code>的目录（Ubuntu一般都会默认安装了<code>git</code>），进入该目录下，输入命令：<code>ssh-keygen -t rsa -C &quot;注册时的邮箱&quot;</code>，此后一直按回车即可，该目录下会生成2个文件<code>id_rsa</code>和<code>id_rsa.pub</code>，进入后者，复制其内容，随后找到<code>gitlab</code>设置中的<code>SSH KEYS</code>一项，将前述文件内容复制到里面。</p>
<blockquote>
<p>如果安装的<code>Ubuntu</code>不支持在宿主机与虚拟机之间复制粘贴，则可以在<code>VBox</code>内设置共享文件夹，将<code>id_rsa.pub</code>文件复制到该共享文件夹中，随后，宿主机便可以间接地从虚拟机中复制粘贴。</p>
</blockquote>
<h2 id="下拉代码"><a href="#下拉代码" class="headerlink" title="下拉代码"></a>下拉代码</h2><p>&emsp;&emsp;在完成上述准备工作后，在用户目录的代码仓库下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone http://git.gdcni.cn/switch/sonic-buildimage.git</span><br></pre></td></tr></table></figure>

<p>成功下拉代码后，需要切换分支<code>gdNOS-v2</code>，顺序执行命令<code>cd sonic-buildimage</code>，<code>git checkout gdNOS-v2</code>。</p>
<h2 id="安装C／C-编译环境"><a href="#安装C／C-编译环境" class="headerlink" title="安装C／C++编译环境"></a>安装C／C++编译环境</h2><p>&emsp;&emsp;在编译该项目前，需要安装配置编译环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<p>然后查看是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br><span class="line">make -v</span><br></pre></td></tr></table></figure>

<h2 id="安装Sonic编译环境"><a href="#安装Sonic编译环境" class="headerlink" title="安装Sonic编译环境"></a>安装Sonic编译环境</h2><p>&emsp;&emsp;按照官方的编译文档，在编译前需安装额外工具：</p>
<ol>
<li>安装<code>python</code>的包工具<code>pip</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y python-pip</span><br></pre></td></tr></table></figure>

<p>运行该命令后，提示该安装包不可用，并且有另外的<code>python3-pip</code>包可用，考虑到应该是<code>ubuntu</code>的<code>/etc/apt/source.list</code>中的源比较旧了，需要更新一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y update</span><br></pre></td></tr></table></figure>

<p>更新完毕后，继续安装<code>python-pip</code>，发现仍然找不到安装包，则考虑添加国内的源，例如阿里源。<code>Ubuntu</code>的源位于<code>/etc/apt/source.list</code>文件中，仍然使用前述建立的共享文件夹来导入阿里源到该该源文件中，在宿主机的共享文件中建立一个文本文件，将阿里源拷贝到其中（例如<code>aliyun_source_list</code>文件），随后在<code>Ubuntu</code>中的共享文件夹中（例如<code>~/share</code>中找到该文件，执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">cat /home/gd/share/aliyun_source_list &gt;&gt; /etc/apt/source.list</span><br><span class="line">apt-get install update</span><br></pre></td></tr></table></figure>

<p>这样便将源更新到<code>Ubuntu</code>中了，最后再次执行安装命令时，提示缺少依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python-pip : Depends: python-pip-wh1 (=9.0.1-2.3~ubuntu1.18.04.5) but 20.0.2-5ubuntu1.6 is to be installed</span><br></pre></td></tr></table></figure>

<p>也就是如果在<code>Ubuntu20.04</code>以下版本的系统下，该安装命令会成功运行。其实从<code>Ubuntu20.04</code>开始，<code>python3</code>就被包括在系统安装之中了，<code>python2</code>在通用源仓库中可用，官方鼓励用户切换到<code>pyhon3</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装pip-9.0.3</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo python3 -m pip install -U pip=9.0.3</span><br></pre></td></tr></table></figure>

<p>出现<code>successfully installed pip-9.0.3</code>，则安装成功。</p>
<ol start="3">
<li>安装jinja</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install --force-reinstall --upgrade jinja</span><br></pre></td></tr></table></figure>

<p>执行该命令后，提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">You are using pip version 9.0.3, however version 22.2.2 is available.</span><br><span class="line">You should consider upgrading via the 'pip install --upgrade pip' command.</span><br></pre></td></tr></table></figure>

<p>原因是我们安装的<code>pip</code>版本有点落后，需要更新：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install --upgrade pip</span><br></pre></td></tr></table></figure>

<p>更新完毕后，再次执行安装<code>jinja</code>的命令，提示成功。</p>
<ol start="4">
<li>安装j2cli</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install j2cli</span><br></pre></td></tr></table></figure>

<h2 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h2><p>&emsp;&emsp;由于<code>sonic</code>的编译都是位于用户权限下，并且是在一个隔离的容器环境中进行的。也就是说需要在不运行<code>sudo</code>的前提下来运行<code>docker</code>，进行如下操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建docker用户组</span></span><br><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>docker</code>命令会使用<code>Unix socket</code>与<code>Docker</code>引擎通讯。而只有<code>root</code>用户和<code>docker</code>组的用户才可以访问<code>Docker</code>引擎的<code>Unix socket</code>。出于安全考虑，一般<code>Linux</code>系统上不会直接使用<code>root</code>用户。因此，更好地做法就是将需要使用<code>docker</code>的用户加入<code>docker</code>用户组。</p>
<p>&emsp;&emsp;由于运行<code>docker</code>时，提示报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Failed to restart docker.service: Unit docker.service not found</span><br></pre></td></tr></table></figure>

<h3 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h3><p>这是因为安装<code>docker</code>时，没有使用官方安装包，也没有使用<code>apt</code>，而是安装<code>Ubuntu</code>的时候选择了一同安装<code>docker</code>，所以是使用<code>snap</code>安装的。解决方式：<code>sudo snap restart docker</code>或者卸载并重新安装<code>docker</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo snap list</span><br><span class="line">sudo snap remove &lt;snap name&gt;</span><br><span class="line">sudo snap remove --purge docker</span><br></pre></td></tr></table></figure>

<h3 id="使用apt安装docker"><a href="#使用apt安装docker" class="headerlink" title="使用apt安装docker"></a>使用apt安装docker</h3><p>&emsp;&emsp;添加最新的官方<code>Docker</code>源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line">sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9</span><br><span class="line">sudo bash -c "echo deb https://get.docker.io/ubuntu docker main &gt; /ect/apt/sources.list.d/docker.list"</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>安装最新版本的<code>Docker</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y lxc-docker</span><br></pre></td></tr></table></figure>

<p>更新<code>Docker</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update -y lxc-docker</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Sonic</category>
      </categories>
      <tags>
        <tag>Sonic编译</tag>
      </tags>
  </entry>
</search>
